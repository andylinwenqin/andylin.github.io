<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>网络知识总结 | Andylin's Blog</title><meta name="keywords" content="面试,网络"><meta name="author" content="林文钦,andylin0119@163.com"><meta name="copyright" content="林文钦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程与线程的区别进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位 线程: 是进程的一部分，一个没有线程的进程可以被看作是单线程的，线程有时又被称为轻权进程或轻量级进程，也是CPU调度的一个基本单位 区别:  (1). 进程是资源分配的最小单位，线程是程序执行的最小单位(资源调度的最小单位); (2). 进程有自己的独立地址空间，每启动一个进">
<meta property="og:type" content="article">
<meta property="og:title" content="网络知识总结">
<meta property="og:url" content="https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Andylin&#39;s Blog">
<meta property="og:description" content="进程与线程的区别进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位 线程: 是进程的一部分，一个没有线程的进程可以被看作是单线程的，线程有时又被称为轻权进程或轻量级进程，也是CPU调度的一个基本单位 区别:  (1). 进程是资源分配的最小单位，线程是程序执行的最小单位(资源调度的最小单位); (2). 进程有自己的独立地址空间，每启动一个进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://andylinwenqin.github.io/img/10.jpg">
<meta property="article:published_time" content="2021-09-05T14:32:36.000Z">
<meta property="article:modified_time" content="2021-09-05T16:18:23.532Z">
<meta property="article:author" content="林文钦">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://andylinwenqin.github.io/img/10.jpg"><link rel="shortcut icon" href="/andylin.github.io/img/favicon.png"><link rel="canonical" href="https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/andylin.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/andylin.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络知识总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-06 00:18:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/andylin.github.io/atom.xml" title="Andylin's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/andylin.github.io/img/OIP-C.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/andylin.github.io/archives/"><div class="headline">文章</div><div class="length-num">58</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/andylin.github.io/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/andylin.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/andylin.github.io/img/10.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/andylin.github.io/">Andylin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/andylin.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络知识总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-05T14:32:36.000Z" title="发表于 2021-09-05 22:32:36">2021-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-05T16:18:23.532Z" title="更新于 2021-09-06 00:18:23">2021-09-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络知识总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位</p>
<p>线程: 是进程的一部分，一个没有线程的进程可以被看作是单线程的，线程有时又被称为轻权进程或轻量级进程，也是CPU调度的一个基本单位</p>
<p>区别: </p>
<p>(1). 进程是资源分配的最小单位，线程是程序执行的最小单位(资源调度的最小单位);</p>
<p>(2). 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段，这种操作非常昂贵，而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多;</p>
<p>(3). 线程之间的通信更方便，同一进程下的线程恭喜全局变量，静态变量等数据，而进程之间的通信要以通信的方式(IPC)进行;</p>
<p>(4). 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间;</p>
<h2 id="session-cookie-sessionsotrage-localstorage"><a href="#session-cookie-sessionsotrage-localstorage" class="headerlink" title="session, cookie, sessionsotrage, localstorage"></a>session, cookie, sessionsotrage, localstorage</h2><p>cookie中domain属性<br>为了保证安全性，cookie无法设置除当前域名或者其父域名之外的其他domain。<br>在此，分为两种情况：<br>1.一种是前端范围内的是指cookie，如果网站的域名为，i.xiaohan.com,那么前端cookie的domain只能设置，i.xiaohan.com和其父域名xiaohan.com，如果设置成同级域名如api.xiaohan.com或者子域名api.i.xiaohan.com 那么cookie设置将无效。<br>2.同样在服务端上，如果制定你的server服务的域名为server.xiaohan.com那么在服务端生成的cookie的domain只能指定为server.xiaohan.com或者xiaohan.com 其他domain都无法成功设置cookie。</p>
<p>(1). cookie和session的区别</p>
<p>1.cookie数据存放在客户端，session数据存放在服务器端;</p>
<p>2.cookie安全性一般，他人可以通过分析存放在本地的cookie并进行cookie欺骗，在安全性第一的前提下，选择session更优，重要交互信息比如权限等就要放在session中，一般的信息记录放在cookie中;</p>
<p>3.单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie而session原则上没有限制;</p>
<p>4.session会在一定的时间内保存在服务器上，当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie</p>
<p>5.session运行以来Session ID,而Session ID是存在Cookie中，也就是说，如果浏览器禁用了Cookie，Session也会失效(但是可以通过其他方式实现，比如在url中传递Session ID，也就是地址重写)</p>
<p>(2). localStorage和sessionStorage的区别</p>
<p>localStorage和sessionStorage存储数据大小一般为5MB,并且仅在客户端(即浏览器)中保存，不参与和服务器的通信</p>
<p>其实，localStorage最大容量5M的意思是每一个域名下的localStorage容量是5M，假如现在a.com域名下localstorage存不下了，我们可以使用iframe创建b.com域框架（子页面）用于存储a.com剩下的数据。然后使用postMessage读写数据。</p>
<p>localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除</p>
<p>set-cookie: 开始状态管理所使用的Cookie信息    响应首部字段<br>Cookie  服务器接收到的 Cookie 信息   请求首部字段</p>
<p>cookie属性</p>
<pre><code>name: cookie名称
value: cookie值
domain: 即可访问此cookie的域名(不同级有不同限制)
path: 可访问此cookie的页面路径
expires/Max-Age: cookie超时时间, 默认为Session
Size: cookie大小
http: 即httponly属性, true时只有http请求头会带有此信息, 而不能通过document.cookie来访问, 加以限制，使 Cookie 不能被 JavaScript 脚本访问
secure: 设置是否只可通过https来传递此条cookie
</code></pre>
<p>怎么避免localstorage存满了怎么办</p>
<p>(1). 划分域名。各域名下的存储空间由各业务组统一规划使用</p>
<p>(2). 跨页面传数据：考虑单页应用、优先采用 url 传数据</p>
<p>(3). 最后的兜底方案：清掉别人的存储</p>
<p>给每个文件设置时间，当存满后，对localstorage里面的文件进行排序，删除时间最久的插入最新的</p>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p><strong>指一个域下的文档或脚本试图去请求另一个域下的资源，由于浏览器同源策略限制而产生</strong></p>
<p><strong>同源策略: 协议+域名+端口三者相同且必须相同</strong></p>
<h3 id="1-JSONP实现跨域"><a href="#1-JSONP实现跨域" class="headerlink" title="(1). JSONP实现跨域"></a>(1). JSONP实现跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;http://example.com/jsonp/getSomething?uid=123&amp;callback=hadleResponse&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br><span class="line"><span class="comment">/*handleResponse(&#123;&quot;data&quot;: &quot;hey&quot;&#125;)*/</span></span><br></pre></td></tr></table></figure>

<p>动态添加<code>script</code>的标签，可控的去请求远端js并执行，这种跨域方式只能进行GET请求</p>
<p>当我们通过新建一个script标签请求时，后台会根据相应的参数来生成相应的JSON数据。比如说上面这个链接，传递了handleResponse给后台，然后后台根据这个参数再结合数据生成了handleResponse({“data”: “hey”})。</p>
<p>紧接着，这个返回的JSON数据其实就可以被当成一个js脚本，就是对一个函数的调用。<br>由于我们事先已经声明了这么一个回调函数，于是当资源加载进来的时候，直接就对函数进行调用，于是数据当然就能获取到了。</p>
<h3 id="2-CORS跨域"><a href="#2-CORS跨域" class="headerlink" title="(2). CORS跨域"></a>(2). CORS跨域</h3><pre><code>只要同时满足以下两大条件，就属于简单请求。
</code></pre>
<p>（1) 请求方法是以下三种方法之一：</p>
<p><strong>HEAD GET POST</strong></p>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure>

<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<h4 id="a-Access-Control-Allow-Origin"><a href="#a-Access-Control-Allow-Origin" class="headerlink" title="a. Access-Control-Allow-Origin"></a>a. Access-Control-Allow-Origin</h4><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<h4 id="b-Access-Control-Allow-Credentials"><a href="#b-Access-Control-Allow-Credentials" class="headerlink" title="b. Access-Control-Allow-Credentials"></a>b. Access-Control-Allow-Credentials</h4><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性</p>
<h4 id="c-Access-Control-Expose-Headers"><a href="#c-Access-Control-Expose-Headers" class="headerlink" title="c. Access-Control-Expose-Headers"></a>c. Access-Control-Expose-Headers</h4><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<p>总的来说，CORS实现跨域的方法就是根据请求头的Origin值和响应头的Access-Control-Request-Headers和Access-Control-Request-Method的值进行比对，通过了就可以请求成功，没通过就请求失败。</p>
<h3 id="3-Nginx反向代理接口跨域"><a href="#3-Nginx反向代理接口跨域" class="headerlink" title="(3). Nginx反向代理接口跨域"></a>(3). Nginx反向代理接口跨域</h3><p>实现思路：通过Nginx配置一个代理服务器（域名与example1相同，端口不同）做跳板机，反向代理访问example2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<h2 id="用户输入url到页面展示的流程"><a href="#用户输入url到页面展示的流程" class="headerlink" title="用户输入url到页面展示的流程"></a>用户输入url到页面展示的流程</h2><p>(1). 输入地址: 浏览器会自动在书签和浏览历史中搜寻，如果匹配则自动补全，在chrome中如果地址命中了缓存，会直接调用缓存展示页面;</p>
<p>(2). 浏览器查询域名的IP地址(发送请求至DNS服务器): 浏览器会在本地寻找是否有匹配的映射，如果有直接使用映射的IP地址，如果没有，浏览器会发送DNS请求DNS服务器，DNS服务器的作用在于根据请求中的域名返回与之对应IP地址;</p>
<p>DNS查找顺序: 浏览器缓存–&gt; 操作系统缓存–&gt; 本地host文件 –&gt; 路由器缓存–&gt; ISP DNS缓存 –&gt; 顶级DNS服务器/根DNS服务器</p>
<p>本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问</p>
<p>(3). 浏览器获取IP地址请求TCP/IP连接，客户端和服务器之间进行三次握手的链接，随后发送HTTP请求:</p>
<p>浏览器获取IP地址后会使用一个随机端口发送TCP连接请求，经过层层路由设备进入服务端，建立TCP/IP连接，随后浏览器会发送一个http请求;</p>
<p>(4). 服务器解析TCP连接解析HTTP请求;</p>
<p>(5). 服务器返回一个http响应: http响应由三个部分构成: 状态行，响应头，响应正文;</p>
<p>(6). 浏览器解析html: 构建dom树 =&gt; 构建render树 =&gt; 布局render树 =&gt; 绘制render树;</p>
<p>(7). 浏览器解析外联js css: 在解析html的过程中如果碰到外联的js脚本,会中断html的解析,等待js脚本下载解析完成后再恢复html的解析流程,构建完dom树,dom样式树,执行脚本后,页面就正确的展示出来了 </p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p>
<p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说同一时间内只能做一件事情，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。这就涉及到事件循环的问题</p>
<p>(8). 连接结束四次挥手</p>
<h2 id="OSI网络分层模型，五层协议，-TCP-IP网络分层模型"><a href="#OSI网络分层模型，五层协议，-TCP-IP网络分层模型" class="headerlink" title="OSI网络分层模型，五层协议， TCP/IP网络分层模型"></a>OSI网络分层模型，五层协议， TCP/IP网络分层模型</h2><h3 id="OSI网络分层模型"><a href="#OSI网络分层模型" class="headerlink" title="OSI网络分层模型"></a>OSI网络分层模型</h3><p>(1). 应用层: 文件传输，常用协议http, snmp, ftp; 报文</p>
<p>(2). 表示层: 数据格式化，代码转换，数据加密;</p>
<p>(3). 会话层: 建立，解除会话; </p>
<p>(4). 传输层: 提供端对端的接口， tcp，udp; 报文段/用户数据报</p>
<p>(5). 网络层: 为数据包选择路由， ip, icmp; 数据报</p>
<p>(6). 数据链路层: 传输有地址的帧; （Ethernet, FDDI）帧</p>
<p>(7). 物理层: 二进制的数据形式在物理媒体上传输数据; 比特</p>
<h3 id="五层"><a href="#五层" class="headerlink" title="五层:"></a>五层:</h3><p>(1). 物理层<br>(2). 数据链路层<br>(3). 网络层<br>(4). 运输层<br>(5). 应用层</p>
<h3 id="TCP-IP网络分层模型"><a href="#TCP-IP网络分层模型" class="headerlink" title="TCP/IP网络分层模型"></a>TCP/IP网络分层模型</h3><p>(1). 网络接口层<br>(2). 网际层IP<br>(3). 运输层(TCP或UDP)<br>(4). 应用层(Telnet, FTP, SMTP)</p>
<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>(1). UDP: 无连接; 面向报文，只是报文的搬运工; 不可靠，没有拥塞控制; 高效，头部开销只有8字节; 支持一对一，一对多，多对多，多对一; 适合直播，视频，语音，会议等实时性要求高的</p>
<p>(2). TCP: 面向连接: 传输前需要先连接; 可靠的传输; 流量控制: 发送方不会发送速度过快，超过接收方的处理能力; 拥塞控制: 当网络负载过多时能限制发送方的发送速率; 不能提供延时保障; 不提供最小带宽保障</p>
<h3 id="TCP协议保证可靠传输的手段"><a href="#TCP协议保证可靠传输的手段" class="headerlink" title="TCP协议保证可靠传输的手段"></a>TCP协议保证可靠传输的手段</h3><p>(1). 应用数据块分割成TCP认为合适发送的数据块;<br>(2). TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层;<br>(3). 校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。TCP的接收端会丢弃重复的数据.;<br>(4). TCP 的接收端会丢弃重复的数据。;<br>(5). 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）;<br>(6). 当网络拥塞时，减少数据的发送。;<br>(7). ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。;<br>(8). 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 </p>
<h3 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因:"></a>三次握手的原因:</h3><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放</p>
<p>四次挥手的原因: TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送，之后就会中断这次TCP连接。</p>
<h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p> HTTP是一个在计算机世界里专门在两点之间传输文字，图片，音频等超文本数据的约定和规范</p>
<h2 id="常见HTTP请求方法"><a href="#常见HTTP请求方法" class="headerlink" title="常见HTTP请求方法"></a>常见HTTP请求方法</h2><p> 在HTTP1.0中有三种方法分别是<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>GET</code>是从指定资源中请求数据，<code>POST</code>向指定的资源提交要被处理的数据，<code>HEAD</code>类似于<code>GET</code>请求但不返回具体内容，只有头部，可检查超链接的有效性和检查网页是否被修改</p>
<p>HTTP1.1中加入了<code>PUT</code>替换或创建指定资源，<code>DELETE</code>对指定资源进行删除</p>
<p>HTTP1.1在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content)</p>
<p>HTTP2.0中加入了<code>OPTION</code>用于获取目的资源所支持的通信选项，比如服务器支持的请求方式, <code>TRACE</code>: 实现沿通向目标资源的路径的消息环回(loop-back)测试，提供一种实用的debug机制，<code>connect</code>为代理服务器准备的</p>
<h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a><code>GET</code>和<code>POST</code>的区别</h2><p>(1). get参数通过url传递，post放在request body中；</p>
<p>(2). get请求在url中传递的参数是有长度限制的，而post没有；</p>
<p>(3). get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息；</p>
<p>(4). get只能进行url编码，而post支持多种编码方式</p>
<h2 id="HTTP2-0与HTTP1-1区别"><a href="#HTTP2-0与HTTP1-1区别" class="headerlink" title="HTTP2.0与HTTP1.1区别"></a>HTTP2.0与HTTP1.1区别</h2><p>(1). HTTP2.0允许多路复用 (通过二进制分帧层实现);</p>
<p>(2). 首部压缩，在HTTP1中HTTP请求和响应都是由状态行，请求/响应头部，消息主题三部分组成;</p>
<p>(3). 设置请求的优先级，可以设置让某些重要的数据优先被服务器处理并返回。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="(1). 对称加密"></a>(1). 对称加密</h4><p>对称加密就是通信的双方都持有同一个密钥，加密和解密都是使用这一个密钥进行的</p>
<p>优点: 加密和解密的速度快，不会造成性能上太大的损失，尤其是在加密大量数据的情况下</p>
<p>缺点: 商定加密规则的时候不安全</p>
<h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="(2). 非对称加密"></a>(2). 非对称加密</h4><p>非对称加密存在两个密钥，一个称为公钥一个称为私钥，既可以使用公钥加密，也可以使用私钥加密，但是使用公钥加密那么就只有私钥才能解密，使用私钥加密就只能使用公钥解密</p>
<p>优点: 公钥是任何人都可以获取的，经过公钥加密的内容，只有私钥才可以解开</p>
<p>缺点: 必须保证私钥不能泄露，否则将无加密可言; 非对称加密相对于对称加密而言性能损耗较大，非对称加密还有一个最大的漏洞，中间人攻击</p>
<p>https = http + tls/ssl</p>
<h3 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h3><p>(1). 客户端发送’client hello’ 包含密码信息和随机字符串’client random’等;<br>(2). 服务器响应’server hello’包含密码组合和数字证书以及随机字符串’server random等’;<br>(3). 客户端验证数字证书并从证书种获取公钥，生成下一个随机字符串’premaster secret’并用公钥将其加密;<br>(4). 客户端发送加密后的premaster secret给服务器;<br>(5). 服务器使用私钥解密获取premaster secret;<br>(6). 客户端和服务器双方使用相同的算法，并使用client random, server random和premaster secret生产相同的密钥key，用于后面的对称加密;<br>(7). 客户端发送finished;<br>(8). 服务器发送finished;;<br>(9). 成功简历安全连接，双方使用共同的密钥key对称加密进行安全通信;</p>
<p>使用数字签名，我们能够鉴别信息的发送者，(私钥加密签名)</p>
<h2 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h2><p>(1). HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费;</p>
<p>(2). HTTP协议运行在TCP之上，所有的传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都是经过加密的;</p>
<p>(3). HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不太一样，前者是80，后者是443;</p>
<p>(4). HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题;</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>解析顺序首先从浏览器缓存，操作系统缓存和本地DNS缓存逐级查找，然后从本地DNS服务器，根DNS，顶级DNS以及权威DNS层层递归查询</p>
<p>不过传统的 DNS 有很多问题(解析慢、更新不及时)，HTTPDNS 通过客户端 SDK 和服务端配合，直接通过 HTTP 调用解析 DNS 的方式，可以绕过传统 DNS 这些缺点，实现智能调度。</p>
<h3 id="DNS查询的两种方式"><a href="#DNS查询的两种方式" class="headerlink" title="DNS查询的两种方式"></a>DNS查询的两种方式</h3><h4 id="1-递归解析"><a href="#1-递归解析" class="headerlink" title="(1). 递归解析;"></a>(1). 递归解析;</h4><p>局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端</p>
<h4 id="2-迭代解析"><a href="#2-迭代解析" class="headerlink" title="(2). 迭代解析;"></a>(2). 迭代解析;</h4><p>局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。</p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>浏览器缓存是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者子啊次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览</p>
<h3 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h3><p>浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；</p>
<p>下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；</p>
<p>服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；</p>
<p>如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>通常浏览器缓存策略分为两种：强缓存（Expires，cache-control）和协商缓存（Last-modified ，Etag），并且缓存策略都是通过设置 HTTP Header 来实现的。</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强制缓存。</p>
<p>Cache-Control<br>当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
<p>Expires和Cache-Control的区别<br>Expires 是http1.0的产物，Cache-Control是http1.1的产物</p>
<p>两者同时存在的话，Cache-Control优先级高于Expires；</p>
<p>在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法</p>
<p>Expires是一个具体的服务器时间，这就导致一个问题，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control是一个时间段，控制就比较容易</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>ETag和If-None-Match</p>
<p>这两个要一起说。Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存</p>
<p>Last-Modified和If-Modified-Since</p>
<p>这两个也要一起说。Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。</p>
<p>ETag和Last-Modified区别</p>
<p>在方式上，Etag是对资源的一种唯一标识，而Last-Modified是该资源文件最后一次更改时间</p>
<p>在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p>
<p>在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p>
<p>在优先级上，服务器校验优先考虑Etag。</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h3 id="1-1xx-Informational-收到请求，正在处理"><a href="#1-1xx-Informational-收到请求，正在处理" class="headerlink" title="(1). 1xx (Informational): 收到请求，正在处理"></a>(1). 1xx (Informational): 收到请求，正在处理</h3><p>100 (继续): 请求者应当继续提出请求，服务器返回此代码表示已经收到请求的第一部分，正在等待其余部分;</p>
<p>101 (切换协议): 请求者已要求服务器切换协议，服务器确认并准备切换;</p>
<h3 id="2-2xx-Successful-该请求已成功收到，理解并接受"><a href="#2-2xx-Successful-该请求已成功收到，理解并接受" class="headerlink" title="(2). 2xx (Successful): 该请求已成功收到，理解并接受"></a>(2). 2xx (Successful): 该请求已成功收到，理解并接受</h3><p>200 (成功): 服务器完成已成功处理了请求，通常，这表示服务器提供了请求的网页;</p>
<p>201 (已创建): 请求成功并且服务器创建了新的资源;</p>
<p>202 (已接受): 服务器已接收请求，但尚未处理;</p>
<p>203 (非授权信息): 服务器已成功处理了请求，但返回的信息可能来自另一来源;</p>
<p>204 (无内容): 服务器成功处理了请求，但没有返回任何内容;</p>
<p>205 (重置内容): 响应执行成功，重置页面(Form表单)，方便用户下次输入;</p>
<p>206 (部分内容): 服务器成功处理了部分<code>get</code>请求;</p>
<h3 id="3-3xx-Redirection-重定向"><a href="#3-3xx-Redirection-重定向" class="headerlink" title="(3). 3xx (Redirection): 重定向"></a>(3). 3xx (Redirection): 重定向</h3><p>300 (多种选择): 针对请求，服务器可执行多种操作，服务器可根据请求者(user agent)选择一项操作，或提供操作列表供请求者选;</p>
<p>301 (永久移动): 请求的网页已永久移动到新位置，服务器返回此响应(对<code>GET</code>或<code>HEAD</code>请求的响应)时，会自动将请求者转到新位置;</p>
<p>302 (临时移动): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;</p>
<p>303 (查看其他位置): 请求者应当对不同的位置使用单独的<code>GET</code>请求来检索响应时，服务器返回此代码;</p>
<p>304 (未修改): 自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容;</p>
<p>305 (使用代理): 请求者只能使用代理访问请求的网页，如果服务器返回此响应，还表示请求者应使用代理;</p>
<p>307 (临时重定向): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;</p>
<h3 id="4-4xx-Client-Error-该请求包含错误的语法或不能为完成"><a href="#4-4xx-Client-Error-该请求包含错误的语法或不能为完成" class="headerlink" title="(4). 4xx (Client Error): 该请求包含错误的语法或不能为完成"></a>(4). 4xx (Client Error): 该请求包含错误的语法或不能为完成</h3><p>400 (错误请求): 服务器不理解请求的语法;</p>
<p>401 (未授权): 请求要求身份验证，对于需要登陆的网页，服务器可可能返回此响应;</p>
<p>403 (禁止): 服务器拒绝请求;</p>
<p>404 (未找到): 服务器找不到请求的网页;</p>
<p>405 (方法禁用): 禁用请求中指定的方法;</p>
<p>406 (不接受): 无法使用请求的内容特性响应请求的网页;</p>
<p>407 (需要代理授权): 此状态码与401(未授权)类似，但指定请求者应当授权使用代理;</p>
<p>408 (请求超时): 服务器等候请求时发生超时;</p>
<p>409 (冲突): 服务器在完成请求时发生冲突，服务器必须在响应中包含有关冲突的信息;</p>
<p>410 (已删除): 如果请求的资源已永久删除，服务器就会返回此响应;</p>
<p>411 (需要有效长度): 服务器不接受不含有效内容长度标头字段的请求;</p>
<p>412 (未满足前提条件): 服务器未满足请求者在请求中设置的其中一个前提条件;</p>
<p>413 (请求实体过大): 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力;</p>
<p>414 (请求URL过长): 请求的URL(通常为网址)过长，服务器无法处理;</p>
<p>415 (不支持的媒体类型): 请求的格式不接受请求页面的支持;</p>
<p>416 (请求范围不符合要求): 如果页面无法提供请求的范围，则服务器会返回此状态状态码;</p>
<p>417 (未满足期望值): 服务器未满足”期望”请求标头字段的要求;</p>
<h3 id="5-5xx-Server-Error-服务器错误-504-网关超时"><a href="#5-5xx-Server-Error-服务器错误-504-网关超时" class="headerlink" title="(5). 5xx (Server Error): 服务器错误 504 - 网关超时"></a>(5). 5xx (Server Error): 服务器错误 504 - 网关超时</h3><p>500 (服务器内部错误): 服务器遇到错误，无法完成请求;</p>
<p>501 (尚未实施): 服务器不具备完成请求的功能。例如服务器无法识别请求方法时可能会返回此代码;</p>
<p>502 (错误网关): 服务器作为网关或代理，从上游服务器收到无效响应;</p>
<p>503 (服务不可用): 服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态;</p>
<p>504 (网关超时): 服务器作为网关或代理，但是没有及时从上游服务器收到请求;</p>
<p>505 (HTTP版本不受支持): 服务器不支持请求中所用的HTTP版本协议;</p>
<h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><p>请求报文: 请求行 (方法字段，URL字段，HTTP协议版本字段)，请求头，空行，请求数据</p>
<p>响应报文: 响应行(协议版本，状态码以及描述)，响应头，空行，响应体</p>
<h2 id="HTTP常用的首部字段"><a href="#HTTP常用的首部字段" class="headerlink" title="HTTP常用的首部字段"></a>HTTP常用的首部字段</h2><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>Cache-Control 控制缓存<br>Connection 连接管理<br>Transfor-Encoding 报文主体的传输编码格式<br>Date 创建报文的时间<br>Upgrade 升级为其他协议</p>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>Host 请求资源所在的服务器 (唯一一个HTTP/1.1规范里要求必须出现的字段)Accept 客户端或者代理能够处理的媒体类型If-Match 比较实体标记 (ETag)If-None-Match 比较实体标记 (ETag)，与 If-Match 相反If-Modified-Since 比较资源更新时间 (Last-Modified)If-Unmodified-Since 比较资源更新时间 (Last-Modified)， 与 If-Modified-Since 相反Range 实体的字节范围请求User-Agent 客户端信息</p>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>Accept-Ranges 能接受的字节范围<br>Location 命令客户端重定向的 URI<br>ETag 能够表示资源唯一资源的字符串<br>Server 服务器的信息</p>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>Allow 资源可支持 HTTP 请求方法Last-Modified 资源最后修改时间Expires 实体主体过期时间Content-Language 实体资源语言Content-Encoding 实体编码格式Content-Length 实体大小Content-Type 实体媒体类型</p>
<h2 id="URL包含哪几个部分"><a href="#URL包含哪几个部分" class="headerlink" title="URL包含哪几个部分"></a>URL包含哪几个部分</h2><p>(1). 协议类型;<br>(2). 主机名;<br>(3). 端口号;<br>(4). 路径;<br>(5). 参数(:parameters);<br>(6). 查询(?query);<br>(7). 信息片段(fragment);</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:andylin0119@163.com">林文钦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andylinwenqin.github.io" target="_blank">Andylin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/andylin.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/andylin.github.io/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="/andylin.github.io/img/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/andylin.github.io/2021/09/05/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"><img class="prev-cover" src="/andylin.github.io/img/5.jpg" onerror="onerror=null;src='/andylin.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">安全知识总结</div></div></a></div><div class="next-post pull-right"><a href="/andylin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><img class="next-cover" src="/andylin.github.io/img/8.jpg" onerror="onerror=null;src='/andylin.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue框架面试总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/andylin.github.io/2021/09/04/CSS动画/" title="CSS动画"><img class="cover" src="/andylin.github.io/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-04</div><div class="title">CSS动画</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/CSS性能优化/" title="CSS性能优化"><img class="cover" src="/andylin.github.io/img/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">CSS性能优化</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/CSS盒模型/" title="CSS盒模型"><img class="cover" src="/andylin.github.io/img/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">CSS盒模型</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/CSS选择器/" title="CSS选择器"><img class="cover" src="/andylin.github.io/img/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">CSS选择器</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/ES6新增内容/" title="Es6新增内容"><img class="cover" src="/andylin.github.io/img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">Es6新增内容</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/JS的基础知识点/" title="JS的基础知识点"><img class="cover" src="/andylin.github.io/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">JS的基础知识点</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/andylin.github.io/img/OIP-C.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">林文钦</div><div class="author-info__description">个人知识积累</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/andylin.github.io/archives/"><div class="headline">文章</div><div class="length-num">58</div></a></div><div class="card-info-data-item is-center"><a href="/andylin.github.io/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/andylinwenqin"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">此博客仅用于个人学习，如有内容需要备注原地址，联系博主</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">进程与线程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session-cookie-sessionsotrage-localstorage"><span class="toc-number">2.</span> <span class="toc-text">session, cookie, sessionsotrage, localstorage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JSONP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F"><span class="toc-number">3.1.</span> <span class="toc-text">(1). JSONP实现跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CORS%E8%B7%A8%E5%9F%9F"><span class="toc-number">3.2.</span> <span class="toc-text">(2). CORS跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-Access-Control-Allow-Origin"><span class="toc-number">3.2.1.</span> <span class="toc-text">a. Access-Control-Allow-Origin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-Access-Control-Allow-Credentials"><span class="toc-number">3.2.2.</span> <span class="toc-text">b. Access-Control-Allow-Credentials</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-Access-Control-Expose-Headers"><span class="toc-number">3.2.3.</span> <span class="toc-text">c. Access-Control-Expose-Headers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%8E%A5%E5%8F%A3%E8%B7%A8%E5%9F%9F"><span class="toc-number">3.3.</span> <span class="toc-text">(3). Nginx反向代理接口跨域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">用户输入url到页面展示的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8C-TCP-IP%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">OSI网络分层模型，五层协议， TCP&#x2F;IP网络分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">OSI网络分层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%B1%82"><span class="toc-number">5.2.</span> <span class="toc-text">五层:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">TCP&#x2F;IP网络分层模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">TCP与UDP的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E6%89%8B%E6%AE%B5"><span class="toc-number">6.1.</span> <span class="toc-text">TCP协议保证可靠传输的手段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">7.</span> <span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">7.1.</span> <span class="toc-text">三次握手的原因:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.2.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.</span> <span class="toc-text">什么是HTTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">常见HTTP请求方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">GET和POST的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP2-0%E4%B8%8EHTTP1-1%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">HTTP2.0与HTTP1.1区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-number">12.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">12.1.1.</span> <span class="toc-text">(1). 对称加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">12.1.2.</span> <span class="toc-text">(2). 非对称加密</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">12.2.</span> <span class="toc-text">TLS握手过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E4%B8%8EHTTP%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">HTTPS与HTTP的一些区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">14.</span> <span class="toc-text">DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">14.1.</span> <span class="toc-text">DNS查询的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90"><span class="toc-number">14.1.1.</span> <span class="toc-text">(1). 递归解析;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%9E%90"><span class="toc-number">14.1.2.</span> <span class="toc-text">(2). 迭代解析;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-number">15.</span> <span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B"><span class="toc-number">15.1.</span> <span class="toc-text">浏览器缓存过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5"><span class="toc-number">15.2.</span> <span class="toc-text">策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">15.2.1.</span> <span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">15.2.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">16.</span> <span class="toc-text">HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1xx-Informational-%E6%94%B6%E5%88%B0%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%AD%A3%E5%9C%A8%E5%A4%84%E7%90%86"><span class="toc-number">16.1.</span> <span class="toc-text">(1). 1xx (Informational): 收到请求，正在处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2xx-Successful-%E8%AF%A5%E8%AF%B7%E6%B1%82%E5%B7%B2%E6%88%90%E5%8A%9F%E6%94%B6%E5%88%B0%EF%BC%8C%E7%90%86%E8%A7%A3%E5%B9%B6%E6%8E%A5%E5%8F%97"><span class="toc-number">16.2.</span> <span class="toc-text">(2). 2xx (Successful): 该请求已成功收到，理解并接受</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3xx-Redirection-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">16.3.</span> <span class="toc-text">(3). 3xx (Redirection): 重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4xx-Client-Error-%E8%AF%A5%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB%E9%94%99%E8%AF%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E6%88%96%E4%B8%8D%E8%83%BD%E4%B8%BA%E5%AE%8C%E6%88%90"><span class="toc-number">16.4.</span> <span class="toc-text">(4). 4xx (Client Error): 该请求包含错误的语法或不能为完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5xx-Server-Error-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF-504-%E7%BD%91%E5%85%B3%E8%B6%85%E6%97%B6"><span class="toc-number">16.5.</span> <span class="toc-text">(5). 5xx (Server Error): 服务器错误 504 - 网关超时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">17.</span> <span class="toc-text">HTTP报文结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">18.</span> <span class="toc-text">HTTP常用的首部字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">18.1.</span> <span class="toc-text">通用首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">18.2.</span> <span class="toc-text">请求首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">18.3.</span> <span class="toc-text">响应首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">18.4.</span> <span class="toc-text">实体首部字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL%E5%8C%85%E5%90%AB%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-number">19.</span> <span class="toc-text">URL包含哪几个部分</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试算法题整理(持续更新)"><img src="/andylin.github.io/img/2.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="面试算法题整理(持续更新)"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试算法题整理(持续更新)">面试算法题整理(持续更新)</a><time datetime="2021-09-21T16:34:02.000Z" title="发表于 2021-09-22 00:34:02">2021-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/22/Vue-nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="Vue nextTick实现原理"><img src="/andylin.github.io/img/7.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="Vue nextTick实现原理"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/22/Vue-nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="Vue nextTick实现原理">Vue nextTick实现原理</a><time datetime="2021-09-21T16:29:24.000Z" title="发表于 2021-09-22 00:29:24">2021-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/20/Vue-slot%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Vue slot的使用"><img src="/andylin.github.io/img/5.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="Vue slot的使用"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/20/Vue-slot%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Vue slot的使用">Vue slot的使用</a><time datetime="2021-09-20T12:04:29.000Z" title="发表于 2021-09-20 20:04:29">2021-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/12/Git%E6%8B%89%E5%8F%96%E8%BF%9C%E7%AB%AF%E6%89%80%E6%9C%89%E5%88%86%E6%94%AF/" title="Git拉取远端所有分支"><img src="/andylin.github.io/img/5.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="Git拉取远端所有分支"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/12/Git%E6%8B%89%E5%8F%96%E8%BF%9C%E7%AB%AF%E6%89%80%E6%9C%89%E5%88%86%E6%94%AF/" title="Git拉取远端所有分支">Git拉取远端所有分支</a><time datetime="2021-09-12T06:15:20.000Z" title="发表于 2021-09-12 14:15:20">2021-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/12/Git%E5%A4%8D%E5%88%B6%E5%B7%B2%E6%9C%89%E7%9A%84%E5%88%86%E6%94%AF%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF/" title="Git复制已有的分支到新分支"><img src="/andylin.github.io/img/1.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="Git复制已有的分支到新分支"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/12/Git%E5%A4%8D%E5%88%B6%E5%B7%B2%E6%9C%89%E7%9A%84%E5%88%86%E6%94%AF%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF/" title="Git复制已有的分支到新分支">Git复制已有的分支到新分支</a><time datetime="2021-09-12T06:10:50.000Z" title="发表于 2021-09-12 14:10:50">2021-09-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 林文钦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/andylin.github.io/js/utils.js"></script><script src="/andylin.github.io/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>