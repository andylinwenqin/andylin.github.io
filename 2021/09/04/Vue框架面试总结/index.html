<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vue框架面试总结 | Andylin's Blog</title><meta name="keywords" content="面试,vue"><meta name="author" content="林文钦,andylin0119@163.com"><meta name="copyright" content="林文钦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="真实DOM和其解析流程(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵DOM树; (2). 生成样式表，用css分析器，分析css文件和元素上的inline样式，生成页面的样式表; (3). 构建Render树: 将DOM树和样式表关联起来，构建一颗Render树(Attachment) 每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名rende">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue框架面试总结">
<meta property="og:url" content="https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Andylin&#39;s Blog">
<meta property="og:description" content="真实DOM和其解析流程(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵DOM树; (2). 生成样式表，用css分析器，分析css文件和元素上的inline样式，生成页面的样式表; (3). 构建Render树: 将DOM树和样式表关联起来，构建一颗Render树(Attachment) 每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名rende">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://andylinwenqin.github.io/img/11.jpg">
<meta property="article:published_time" content="2021-09-04T15:39:19.000Z">
<meta property="article:modified_time" content="2021-09-05T16:18:23.520Z">
<meta property="article:author" content="林文钦">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://andylinwenqin.github.io/img/11.jpg"><link rel="shortcut icon" href="/andylin.github.io/img/favicon.png"><link rel="canonical" href="https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/andylin.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/andylin.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue框架面试总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-06 00:18:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/andylin.github.io/atom.xml" title="Andylin's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/andylin.github.io/img/OIP-C.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/andylin.github.io/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/andylin.github.io/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/andylin.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/andylin.github.io/img/11.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/andylin.github.io/">Andylin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/andylin.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/andylin.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue框架面试总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-04T15:39:19.000Z" title="发表于 2021-09-04 23:39:19">2021-09-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-05T16:18:23.520Z" title="更新于 2021-09-06 00:18:23">2021-09-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue框架面试总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="真实DOM和其解析流程"><a href="#真实DOM和其解析流程" class="headerlink" title="真实DOM和其解析流程"></a>真实DOM和其解析流程</h2><p>(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵DOM树;</p>
<p>(2). 生成样式表，用css分析器，分析css文件和元素上的inline样式，生成页面的样式表;</p>
<p>(3). 构建Render树: 将DOM树和样式表关联起来，构建一颗Render树(Attachment) 每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)，这些render对象最终会构建成一颗render树;</p>
<p>(4). 确定节点坐标: 根据Render树结构，为每个Render树上的节点确定一个在显示屏上出现的精确坐标;</p>
<p>(5). 绘制页面: 根据Render树和节点显示坐标，然后调用每个节点的paint方法，将它门绘制出来;</p>
<p>注意点:</p>
<p>(1). 构建DOM树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个HTML文档解析完成之后才开始构建render树和布局;</p>
<p>(2). Render树DOM树和CSS样式表这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析以及一边渲染;</p>
<p>(3). CSS的解析是从右往左逆向解析的，嵌套标签越多，解析越慢;</p>
<p>(4). 用我们传统的开发模式，原声JS操作DOM时，浏览器会从构建DOM树开始从头到尾执行一边流程，在一次操作中，我们需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会立即马上执行流程，最终执行10次，这样会导致页面卡顿并且影响用户体验;</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>虚拟DOM的好处：</p>
<p>虚拟DOM就是为了解决浏览器性能问题而被设计出来的，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attach到DOM树上，再进行后续操作，避免大量无谓的计算量，所以用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制</p>
<p>比较两颗虚拟DOM树的差异 - diff算法</p>
<p>diff算法用来比较virtual dom树的差异，如果两颗树完全比较，那么diff算法的时间复杂度位O(n^3)，但是在前端当中，会很少跨越层级地移动DOM元素，所以virtual dom只会对同一层级的元素进行对比，这样算法复杂度就可以达到O(n)</p>
<p>(1).深度优先遍历记录差异;</p>
<p>(2). 差异类型;</p>
<ol>
<li><p>节点替换：节点改变了，例如将上面的 div 换成 h1;</p>
</li>
<li><p>顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；</p>
</li>
<li><p>属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；</p>
</li>
<li><p>文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”;</p>
</li>
</ol>
<p>(3). 列表对比算法</p>
<p>子节点的对比算法，例如:p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动</p>
<h2 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h2><p>(1). Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能而React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染;</p>
<p>(2). Vue支持双向绑定，而React的数据流一直提倡单向数据流，他称之为 onChange/setState()模式。;</p>
<p>(3). 模版渲染方式不同 React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现;</p>
<h2 id="SPA单页面应用"><a href="#SPA单页面应用" class="headerlink" title="SPA单页面应用"></a>SPA单页面应用</h2><p>其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。</p>
<p>优 点: 减轻服务端的压力，可维护性高</p>
<p>缺点: 首次加载速度慢，搜索引擎优化效果不好</p>
<p>为什么首屏时间慢，SEO 差？<br>单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。</p>
<p>SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。</p>
<p>多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。</p>
<h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的contorller演变成ViewModel,Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p>
<h2 id="介绍下Vue的响应式数据"><a href="#介绍下Vue的响应式数据" class="headerlink" title="介绍下Vue的响应式数据"></a>介绍下Vue的响应式数据</h2><p>Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)</p>
<p><strong>Vue3.x响应式数据原理</strong><br>    Vue3.x该用proxy代替Object.defineProperty. 因为Proxy可以直接监听对象和数组的变化<br>    <strong>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</strong><br>        判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>    <strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong><br>        我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p>
<h2 id="Vue2-x中如何监测数组变化"><a href="#Vue2-x中如何监测数组变化" class="headerlink" title="Vue2.x中如何监测数组变化"></a>Vue2.x中如何监测数组变化</h2><p>​    使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控，这样就实现了监测数组变化。</p>
<h2 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理"></a>nextTick实现原理</h2><p>在下次DOM更新循环结束之后执行延迟回调，nextTick主要使用了宏任务和微任务，根据执行环境分别尝试采用(1).promise;(2).MutationObserver;(3).setImmediate;(4).如果以上都不行采用setTimeout定义一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p> Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模版，挂载Dom,渲染, 更新 再渲染， 销毁等一系列过程，我们称这个为vue的生命周期。</p>
<p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段: 初始化，运行中，销毁</p>
<p>(1). 实例，组件通过new Vue()创建出来之后会初始化事件和生命周期，然后就会执行<code>beforeCreate</code>钩子函数，这个时候数据还没有挂载，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</p>
<p>(2). 挂载数据，绑定事件等，然后执行<code>created</code>函数，这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发update函数，在这里可以再渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以再这里初始数据的获取</p>
<p>(3). 接下里开始实例或者组件对应的模版，编译模版为虚拟dom放入到render函数中准备渲染，然后执行<code>beforeMount</code>钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染，在这里也可以更改数据，不会触发update，这里是渲染前最后一次更改数据的机会，不会触发其他钩子函数，一般可以在这里做初始数据的获取</p>
<p>(4). 接下来开始render，渲染出真实dom，然后执行<code>mounted</code>钩子函数，此时，组件已经出现在页面中，数据，真实dom都已经处理好了，事件已经挂载好了，可以在这里操作真实dom等事情；</p>
<p>(5). 当组件或实例的数据更改之后，会立即执行<code>beforeUpdate</code>,然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用<code>diff</code>算法进行对比之后重新渲染，一般不做什么事</p>
<p>(6). 当更新完成后，执行<code>updated</code>，数据已经更新完成，dom也重新render完成，可以操作更新后的虚拟dom</p>
<p>(7). 当经过某种途径调用$destory方法之后，立即执行<code>beforeDestroy</code>,一般在这里做一些善后工作，例如清除计时器，清除非指令绑定的事件等</p>
<p>(8). 组件的数据绑定，监听去掉后只剩下dom空壳，这个时候执行<code>destoryed</code>,在这里做善后工作也可以</p>
<p> 嵌套组件的生命周期的执行顺序：</p>
<pre><code>vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted
</code></pre>
<p>更改组件数据　　修改子组件的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted ——&gt; son.beforeUpdate ——&gt; son.updated</span><br></pre></td></tr></table></figure>

<p> Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。</p>
<p>当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它</p>
<h2 id="Vue的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue的父组件和子组件生命周期钩子函数执行顺序"></a>Vue的父组件和子组件生命周期钩子函数执行顺序</h2><p><strong>加载渲染过程</strong></p>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<p><strong>子组件更新过程</strong></p>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<p><strong>父组件更新过程</strong></p>
<p>父 beforeUpdate -&gt; 父 updated</p>
<p><strong>销毁过程</strong></p>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<p><strong>在哪个生命周期内调用异步请求</strong></p>
<p>可以在钩子函数created，beforeMount, mounted中进行调用，因为在这三个钩子函数中，data已经创建，可以将服务端返回的数据进行赋值，</p>
<p><strong>在什么阶段才能访问操作</strong>DOM</p>
<p>在钩子函数mounted被调用前，Vue已经将编译号的模版挂载到页面上，所以在mounted中可以访问操作DOM</p>
<h2 id="created和mounted的区别"><a href="#created和mounted的区别" class="headerlink" title="created和mounted的区别"></a>created和mounted的区别</h2><p><code>created</code>: 在模版渲染成html前调用，即挂载数据和绑定事件等等，此时是无法对html的dom节点进行操作的，此时更改数据不会触发<code>update</code>函数</p>
<p><code>mounted</code>: 在模版渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作，此时更改数据会触发<code>update</code>函数</p>
<h2 id="Vue双向绑定的原理"><a href="#Vue双向绑定的原理" class="headerlink" title="Vue双向绑定的原理"></a>Vue双向绑定的原理</h2><p>vue数据双向绑定事通过数据劫持结合发布者-订阅者模式的方式来实现的。<br>vue通过<code>Object.defineProperty()</code>这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p>
<p><code>Object.defineProperty()</code>的第一个缺陷，无法监听数组变化，第二个缺陷是只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历</p>
<ol>
<li><p>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p>
</li>
<li><p>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对 应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
</li>
<li><p>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p>
</li>
</ol>
<p>在自身实例化时往属性订阅器(dep)里面添加自己 ，自身必须有一个 update() 方法，待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</p>
<ol start="4">
<li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听<br>自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变 更的双向绑定效果。</li>
</ol>
<p><strong>v-model本质上是一个父子通信组件的语法糖，通过props和$emit实现</strong></p>
<h2 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h2><p>v-if: 是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块</p>
<p>v-show: 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的‘display’属性进行切换</p>
<p>所以v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景</p>
<h2 id="v-for中-key-值的作用"><a href="#v-for中-key-值的作用" class="headerlink" title="v-for中 key 值的作用"></a>v-for中 key 值的作用</h2><p>在列表渲染过程中，key可以提高列表渲染的效率，提高页面的性能，因为<code>v-for</code>更新已渲染的元素列表时，默认用就地复用的原则对列表进行修改，他会根据key的值去判断某个值是否修改，如果修改了key，则重新渲染这一项，否则复用之前的元素。</p>
<h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><p>父传子: 通过<code>v-on</code>绑定一个变量名称，在子组件中用props进行接收</p>
<p>子传父: 在子组件中绑定一个方法，将参数传入之后通过<code>$emit()</code>传递出去， <code>$emit()</code>里的参数是父组件中定义的方法名称以及参数</p>
<h2 id="为什么组件里的data必须是函数而不是对象？"><a href="#为什么组件里的data必须是函数而不是对象？" class="headerlink" title="为什么组件里的data必须是函数而不是对象？"></a>为什么组件里的<code>data</code>必须是函数而不是对象？</h2><p> 因为组件在Vue中是可以重复调用的，那么如果这个组件被多次调用并且<code>data</code>是对象的话，所有这个组件的实例会共同share一份<code>data</code>这样就会造成数据的泄漏，并且组件中的数据会对不上号，可能实例a的数据应用在了实例b上， 所以如果<code>data</code>是函数，就能确保每一个实例都有一份自己的<code>data</code>,使得统一组件的不同实例间的<code>data</code>不会互相影响。</p>
<h2 id="怎样理解Vue的单向数据流"><a href="#怎样理解Vue的单向数据流" class="headerlink" title="怎样理解Vue的单向数据流"></a>怎样理解Vue的单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<h2 id="Vue中key的作用"><a href="#Vue中key的作用" class="headerlink" title="Vue中key的作用"></a>Vue中key的作用</h2><p> key是为Vue中vnode的唯一标记，通过key，我们的diff操作可以更加准确，更快速，Vue的diff过程可以概括为: oldCh和newCh各有两个头尾的变量oldStartIndex, oldEndIndex和newStartIndex, newEndIndex，新旧节点会两两对比，即一共有四种比较方式, 如果以上4种都没有匹配，如果设置了key，就会用key再进行比较，在比较的过程中，遍历会往中间靠，一旦StartIndex &gt; EndIndex表明oldCh和newCh至少一个已经遍历完了，就会结束比较(如果没有key,4种都没有匹配成功就会将newStartIndex所在的节点直接生成新的节点且插入到原有的root的子节点中)</p>
<p>VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。</p>
<p>所以key是Vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确，更快速</p>
<p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。<br>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p>
<h2 id="Vue2-x和Vue3-x渲染器的diff不同处"><a href="#Vue2-x和Vue3-x渲染器的diff不同处" class="headerlink" title="Vue2.x和Vue3.x渲染器的diff不同处"></a>Vue2.x和Vue3.x渲染器的diff不同处</h2><p>简单来说，diff算法的过程</p>
<p>(1). 同级比较，再比较子节点;<br>(2). 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除);<br>(3). 比较都有子节点的情况;<br>(4). 递归比较子节点;</p>
<p>正常Diff两个树的时间复杂度时O(N ^ 3),但实际情况下我们很少会进行跨层级的移动DOM,所以Vue将Diff进行优化，从O(N^3) -&gt; O(N)只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较</p>
<h3 id="vue2-vu3算法区别"><a href="#vue2-vu3算法区别" class="headerlink" title="vue2 vu3算法区别"></a>vue2 vu3算法区别</h3><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。</p>
<p>Vue3的diff算法在创建VNode时就确定其类型1，以及在mounted/patch的过程中采用位运算来判断一个VNode的类型，在这个基础上再配合核心的Diff算法</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点：</p>
<p>首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；</p>
<p>在vnode没有文本节点的情况下，进入子节点的 diff；</p>
<ul>
<li>当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；</li>
</ul>
<ul>
<li>若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中；</li>
</ul>
<ul>
<li>若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；</li>
</ul>
<ul>
<li>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。</li>
</ul>
<h2 id="Vue事件绑定原理"><a href="#Vue事件绑定原理" class="headerlink" title="Vue事件绑定原理"></a>Vue事件绑定原理</h2><p>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p>
<h2 id="watch中deep和immediate的作用？"><a href="#watch中deep和immediate的作用？" class="headerlink" title="watch中deep和immediate的作用？"></a>watch中deep和immediate的作用？</h2><p>deep，默认值是 false，代表是否深度监听。<br>immediate:true代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。</p>
<h2 id="Vue模版编译原理"><a href="#Vue模版编译原理" class="headerlink" title="Vue模版编译原理"></a>Vue模版编译原理</h2><p>简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：</p>
<ol>
<li>生成AST树</li>
<li>优化</li>
<li>codegen</li>
</ol>
<p>首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。</p>
<p>使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p>
<p>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p>
<p>编译的最后一步是将优化后的AST树转换为可执行的代码。</p>
<h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><ul>
<li>Vue-router是什么？有哪些组件？</li>
</ul>
<p>Vue-router是<code>Vue.js</code>官方的路由管理器，它和<code>Vue.js</code>的核心深度集成，让构建单页面应用变得易如反掌</p>
<p>共有三个组件分别是<code>&lt;router-link&gt;, &lt;router-view&gt;和&lt;keep-alive&gt;(vue2.0提供)</code></p>
<ul>
<li>Vue-router有几种钩子函数？具体时什么以及参数</li>
</ul>
<p>(1). 前置守卫 在进入这个路由之前;<br>(2). 全局解析守卫;<br>(3). 后置钩子 ;<br>(4). 路由独享的钩子;<br>(5). 组件内的导航钩子</p>
<ul>
<li>导航解析流程</li>
</ul>
<p>(1). 导航被触发;</p>
<p>(2). 在失活的组件里调用<code>beforeRouteLeave</code>守卫;</p>
<p>(3). 调用全局的<code>beforeEach</code>守卫;</p>
<p>(4). 在重用的组件里调用<code>beforeRouteUpdate</code>守卫;</p>
<p>(5). 在路由配置里调用<code>beforeEnter</code>;</p>
<p>(6). 解析异步路由组件;</p>
<p>(7). 在被激活的组件里调用<code>beforeRouterEnter</code>;</p>
<p>(8). 调用全局的<code>beforeResolve</code>守卫;</p>
<p>(9). 导航被确认;</p>
<p>(10). 调用全局的<code>afterEach</code>钩子;</p>
<p>(11). 触发DOM更新;</p>
<p>(12). 调用<code>beforeRouterEnter</code>守卫中传给<code>next</code>的回调函数，创建好的组件实例会作为回调函数的参数传入;</p>
<h2 id="route和-router的区别是什么？"><a href="#route和-router的区别是什么？" class="headerlink" title="$route和$router的区别是什么？"></a>$route<code>和</code>$router的区别是什么？</h2><p><code>router</code>为vue-router的实例，是一个全局路由对象，包含了路由跳转的方法，钩子函数等</p>
<p><code>route</code>是路由信息对象和跳转的路由对象，每一个路由都一个route对象，是一个局部对象，包含<code>path, params, hash, query, fullpath, matched, name</code>等路由信息参数</p>
<h2 id="Vue-router传参方式"><a href="#Vue-router传参方式" class="headerlink" title="Vue-router传参方式"></a>Vue-router传参方式</h2><p>(1). 直接调用<code>$router.push</code>实现携带参数的跳转;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;path: `/describe/$&#123;id&#125;`&#125;)</span><br><span class="line"></span><br><span class="line">// 对应的路由配置</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/describe/:id&#x27;,</span><br><span class="line">    name: &#x27;Describe&#x27;,</span><br><span class="line">    component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure>

<p>(2).父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。</p>
<pre><code>this.$router.push(&#123;
    name: &#39;Describe&#39;,
    params: &#123;
        id: id
    &#125;
&#125;)

&#123;
    path: &#39;/describe/:id&#39;,
    name: &#39;Describe&#39;,
    component: Describe
&#125;

this.$route.params.id
</code></pre>
<p>(3). 父组件：使用path来匹配路由，然后通过query来传递参数;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">  path: &#x27;/describe&#x27;,</span><br><span class="line">  query: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> path: &#x27;/describe&#x27;,</span><br><span class="line"> name: &#x27;Describe&#x27;,</span><br><span class="line"> component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.query.id</span><br></pre></td></tr></table></figure>

<h2 id="Vue-router的跳转方式"><a href="#Vue-router的跳转方式" class="headerlink" title="Vue-router的跳转方式"></a>Vue-router的跳转方式</h2><p>(1). router-link;<br>(2). this.$router.push();<br>(3). this.$router.replace();<br>(4). this.$router.go();<br>(5). this.$router.forward();<br>(6). this.$router.back();</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取新的state的值，重新渲染Vue componments,界面随之更新</p>
<p><strong>vuex为什么需要用 mutation 这些来修改 state 数据，而不是直接更改</strong></p>
<p>Vuex 单向数据流有关，因为需要知道数据修改的来源。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:andylin0119@163.com">林文钦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andylinwenqin.github.io" target="_blank">Andylin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/andylin.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/andylin.github.io/tags/vue/">vue</a></div><div class="post_share"><div class="social-share" data-image="/andylin.github.io/img/11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/andylin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"><img class="prev-cover" src="/andylin.github.io/img/2.jpg" onerror="onerror=null;src='/andylin.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网络知识总结</div></div></a></div><div class="next-post pull-right"><a href="/andylin.github.io/2021/09/04/v-bind/"><img class="next-cover" src="/andylin.github.io/img/9.jpg" onerror="onerror=null;src='/andylin.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">v-bind</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/andylin.github.io/2021/09/04/CSS动画/" title="CSS动画"><img class="cover" src="/andylin.github.io/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-04</div><div class="title">CSS动画</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/CSS性能优化/" title="CSS性能优化"><img class="cover" src="/andylin.github.io/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">CSS性能优化</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/CSS盒模型/" title="CSS盒模型"><img class="cover" src="/andylin.github.io/img/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">CSS盒模型</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/JS的基础知识点/" title="JS的基础知识点"><img class="cover" src="/andylin.github.io/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">JS的基础知识点</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/JS的获取，更新，添加，删除/" title="JS的获取，更新，添加，删除"><img class="cover" src="/andylin.github.io/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">JS的获取，更新，添加，删除</div></div></a></div><div><a href="/andylin.github.io/2021/06/26/CSS选择器/" title="CSS选择器"><img class="cover" src="/andylin.github.io/img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-26</div><div class="title">CSS选择器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/andylin.github.io/img/OIP-C.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">林文钦</div><div class="author-info__description">个人知识积累</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/andylin.github.io/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="card-info-data-item is-center"><a href="/andylin.github.io/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/andylinwenqin"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">此博客仅用于个人学习，如有内容需要备注原地址，联系博主</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9EDOM%E5%92%8C%E5%85%B6%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">真实DOM和其解析流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-DOM"><span class="toc-number">2.</span> <span class="toc-text">Virtual DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%8EReact%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">Vue与React的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">SPA单页面应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">MVVM模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BVue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">6.</span> <span class="toc-text">介绍下Vue的响应式数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-x%E4%B8%AD%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">Vue2.x中如何监测数组变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">nextTick实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.</span> <span class="toc-text">Vue的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">Vue的父组件和子组件生命周期钩子函数执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#created%E5%92%8Cmounted%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">created和mounted的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">Vue双向绑定的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">v-show和v-if的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">v-for中 key 值的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">15.</span> <span class="toc-text">父子组件的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E9%87%8C%E7%9A%84data%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">为什么组件里的data必须是函数而不是对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3Vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">17.</span> <span class="toc-text">怎样理解Vue的单向数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">18.</span> <span class="toc-text">Vue中key的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-x%E5%92%8CVue3-x%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84diff%E4%B8%8D%E5%90%8C%E5%A4%84"><span class="toc-number">19.</span> <span class="toc-text">Vue2.x和Vue3.x渲染器的diff不同处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-vu3%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-number">19.1.</span> <span class="toc-text">vue2 vu3算法区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff"><span class="toc-number">19.2.</span> <span class="toc-text">diff</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">Vue事件绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%E4%B8%ADdeep%E5%92%8Cimmediate%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">watch中deep和immediate的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text">Vue模版编译原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-router"><span class="toc-number">23.</span> <span class="toc-text">Vue-router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#route%E5%92%8C-router%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">$route和$router的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-router%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F"><span class="toc-number">25.</span> <span class="toc-text">Vue-router传参方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-router%E7%9A%84%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F"><span class="toc-number">26.</span> <span class="toc-text">Vue-router的跳转方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex"><span class="toc-number">27.</span> <span class="toc-text">Vuex</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" title="深拷贝"><img src="/andylin.github.io/img/4.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="深拷贝"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" title="深拷贝">深拷贝</a><time datetime="2021-09-05T15:50:57.000Z" title="发表于 2021-09-05 23:50:57">2021-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/05/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="安全知识总结"><img src="/andylin.github.io/img/1.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="安全知识总结"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/05/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="安全知识总结">安全知识总结</a><time datetime="2021-09-05T15:46:52.000Z" title="发表于 2021-09-05 23:46:52">2021-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="网络知识总结"><img src="/andylin.github.io/img/2.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="网络知识总结"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="网络知识总结">网络知识总结</a><time datetime="2021-09-05T14:32:36.000Z" title="发表于 2021-09-05 22:32:36">2021-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="Vue框架面试总结"><img src="/andylin.github.io/img/11.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="Vue框架面试总结"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="Vue框架面试总结">Vue框架面试总结</a><time datetime="2021-09-04T15:39:19.000Z" title="发表于 2021-09-04 23:39:19">2021-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/andylin.github.io/2021/09/04/v-bind/" title="v-bind"><img src="/andylin.github.io/img/9.jpg" onerror="this.onerror=null;this.src='/andylin.github.io/img/404.jpg'" alt="v-bind"/></a><div class="content"><a class="title" href="/andylin.github.io/2021/09/04/v-bind/" title="v-bind">v-bind</a><time datetime="2021-09-04T12:04:21.000Z" title="发表于 2021-09-04 20:04:21">2021-09-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 林文钦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/andylin.github.io/js/utils.js"></script><script src="/andylin.github.io/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>