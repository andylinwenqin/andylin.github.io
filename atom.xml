<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andylin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/d2d617c7604cf8dda9f78dd0f6fa3899</icon>
  <subtitle>永无止境，奋斗不息</subtitle>
  <link href="https://andylinwenqin.github.io/atom.xml" rel="self"/>
  
  <link href="https://andylinwenqin.github.io/"/>
  <updated>2021-09-04T16:09:03.531Z</updated>
  <id>https://andylinwenqin.github.io/</id>
  
  <author>
    <name>林文钦</name>
    <email>andylin0119@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue框架面试总结</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-04T15:39:19.000Z</published>
    <updated>2021-09-04T16:09:03.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="真实DOM和其解析流程"><a href="#真实DOM和其解析流程" class="headerlink" title="真实DOM和其解析流程"></a>真实DOM和其解析流程</h2><p>(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵DOM树;</p><p>(2). 生成样式表，用css分析器，分析css文件和元素上的inline样式，生成页面的样式表;</p><p>(3). 构建Render树: 将DOM树和样式表关联起来，构建一颗Render树(Attachment) 每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)，这些render对象最终会构建成一颗render树;</p><p>(4). 确定节点坐标: 根据Render树结构，为每个Render树上的节点确定一个在显示屏上出现的精确坐标;</p><p>(5). 绘制页面: 根据Render树和节点显示坐标，然后调用每个节点的paint方法，将它门绘制出来;</p><p>注意点:</p><p>(1). 构建DOM树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个HTML文档解析完成之后才开始构建render树和布局;</p><p>(2). Render树DOM树和CSS样式表这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析以及一边渲染;</p><p>(3). CSS的解析是从右往左逆向解析的，嵌套标签越多，解析越慢;</p><p>(4). 用我们传统的开发模式，原声JS操作DOM时，浏览器会从构建DOM树开始从头到尾执行一边流程，在一次操作中，我们需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会立即马上执行流程，最终执行10次，这样会导致页面卡顿并且影响用户体验;</p><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>虚拟DOM的好处：</p><p>虚拟DOM就是为了解决浏览器性能问题而被设计出来的，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attach到DOM树上，再进行后续操作，避免大量无谓的计算量，所以用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制</p><p>比较两颗虚拟DOM树的差异 - diff算法</p><p>diff算法用来比较virtual dom树的差异，如果两颗树完全比较，那么diff算法的时间复杂度位O(n^3)，但是在前端当中，会很少跨越层级地移动DOM元素，所以virtual dom只会对同一层级的元素进行对比，这样算法复杂度就可以达到O(n)</p><p>(1).深度优先遍历记录差异;</p><p>(2). 差异类型;</p><ol><li><p>节点替换：节点改变了，例如将上面的 div 换成 h1;</p></li><li><p>顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；</p></li><li><p>属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；</p></li><li><p>文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”;</p></li></ol><p>(3). 列表对比算法</p><p>子节点的对比算法，例如:p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动</p><h2 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h2><p>(1). Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能而React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染;</p><p>(2). Vue支持双向绑定，而React的数据流一直提倡单向数据流，他称之为 onChange/setState()模式。;</p><p>(3). 模版渲染方式不同 React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现;</p><h2 id="SPA单页面应用"><a href="#SPA单页面应用" class="headerlink" title="SPA单页面应用"></a>SPA单页面应用</h2><p>其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。</p><p>优 点: 减轻服务端的压力，可维护性高</p><p>缺点: 首次加载速度慢，搜索引擎优化效果不好</p><p>为什么首屏时间慢，SEO 差？<br>单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。</p><p>SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。</p><p>多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。</p><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的contorller演变成ViewModel,Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p><h2 id="介绍下Vue的响应式数据"><a href="#介绍下Vue的响应式数据" class="headerlink" title="介绍下Vue的响应式数据"></a>介绍下Vue的响应式数据</h2><p>Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)</p><p><strong>Vue3.x响应式数据原理</strong><br>    Vue3.x该用proxy代替Object.defineProperty. 因为Proxy可以直接监听对象和数组的变化<br>    <strong>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</strong><br>        判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>    <strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong><br>        我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h2 id="Vue2-x中如何监测数组变化"><a href="#Vue2-x中如何监测数组变化" class="headerlink" title="Vue2.x中如何监测数组变化"></a>Vue2.x中如何监测数组变化</h2><p>​    使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控，这样就实现了监测数组变化。</p><h2 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理"></a>nextTick实现原理</h2><p>在下次DOM更新循环结束之后执行延迟回调，nextTick主要使用了宏任务和微任务，根据执行环境分别尝试采用(1).promise;(2).MutationObserver;(3).setImmediate;(4).如果以上都不行采用setTimeout定义一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p> Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模版，挂载Dom,渲染, 更新 再渲染， 销毁等一系列过程，我们称这个为vue的生命周期。</p><p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段: 初始化，运行中，销毁</p><p>(1). 实例，组件通过new Vue()创建出来之后会初始化事件和生命周期，然后就会执行<code>beforeCreate</code>钩子函数，这个时候数据还没有挂载，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</p><p>(2). 挂载数据，绑定事件等，然后执行<code>created</code>函数，这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发update函数，在这里可以再渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以再这里初始数据的获取</p><p>(3). 接下里开始实例或者组件对应的模版，编译模版为虚拟dom放入到render函数中准备渲染，然后执行<code>beforeMount</code>钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染，在这里也可以更改数据，不会触发update，这里是渲染前最后一次更改数据的机会，不会触发其他钩子函数，一般可以在这里做初始数据的获取</p><p>(4). 接下来开始render，渲染出真实dom，然后执行<code>mounted</code>钩子函数，此时，组件已经出现在页面中，数据，真实dom都已经处理好了，事件已经挂载好了，可以在这里操作真实dom等事情；</p><p>(5). 当组件或实例的数据更改之后，会立即执行<code>beforeUpdate</code>,然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用<code>diff</code>算法进行对比之后重新渲染，一般不做什么事</p><p>(6). 当更新完成后，执行<code>updated</code>，数据已经更新完成，dom也重新render完成，可以操作更新后的虚拟dom</p><p>(7). 当经过某种途径调用$destory方法之后，立即执行<code>beforeDestroy</code>,一般在这里做一些善后工作，例如清除计时器，清除非指令绑定的事件等</p><p>(8). 组件的数据绑定，监听去掉后只剩下dom空壳，这个时候执行<code>destoryed</code>,在这里做善后工作也可以</p><p> 嵌套组件的生命周期的执行顺序：</p><pre><code>vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted</code></pre><p>更改组件数据　　修改子组件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted ——&gt; son.beforeUpdate ——&gt; son.updated</span><br></pre></td></tr></table></figure><p> Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。</p><p>当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它</p><h2 id="Vue的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue的父组件和子组件生命周期钩子函数执行顺序"></a>Vue的父组件和子组件生命周期钩子函数执行顺序</h2><p><strong>加载渲染过程</strong></p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><p><strong>子组件更新过程</strong></p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><p><strong>父组件更新过程</strong></p><p>父 beforeUpdate -&gt; 父 updated</p><p><strong>销毁过程</strong></p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p><p><strong>在哪个生命周期内调用异步请求</strong></p><p>可以在钩子函数created，beforeMount, mounted中进行调用，因为在这三个钩子函数中，data已经创建，可以将服务端返回的数据进行赋值，</p><p><strong>在什么阶段才能访问操作</strong>DOM</p><p>在钩子函数mounted被调用前，Vue已经将编译号的模版挂载到页面上，所以在mounted中可以访问操作DOM</p><h2 id="created和mounted的区别"><a href="#created和mounted的区别" class="headerlink" title="created和mounted的区别"></a>created和mounted的区别</h2><p><code>created</code>: 在模版渲染成html前调用，即挂载数据和绑定事件等等，此时是无法对html的dom节点进行操作的，此时更改数据不会触发<code>update</code>函数</p><p><code>mounted</code>: 在模版渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作，此时更改数据会触发<code>update</code>函数</p><h2 id="Vue双向绑定的原理"><a href="#Vue双向绑定的原理" class="headerlink" title="Vue双向绑定的原理"></a>Vue双向绑定的原理</h2><p>vue数据双向绑定事通过数据劫持结合发布者-订阅者模式的方式来实现的。<br>vue通过<code>Object.defineProperty()</code>这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p><p><code>Object.defineProperty()</code>的第一个缺陷，无法监听数组变化，第二个缺陷是只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历</p><ol><li><p>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p></li><li><p>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对 应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></li><li><p>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p></li></ol><p>在自身实例化时往属性订阅器(dep)里面添加自己 ，自身必须有一个 update() 方法，待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</p><ol start="4"><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听<br>自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变 更的双向绑定效果。</li></ol><p><strong>v-model本质上是一个父子通信组件的语法糖，通过props和$emit实现</strong></p><h2 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h2><p>v-if: 是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块</p><p>v-show: 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的‘display’属性进行切换</p><p>所以v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景</p><h2 id="v-for中-key-值的作用"><a href="#v-for中-key-值的作用" class="headerlink" title="v-for中 key 值的作用"></a>v-for中 key 值的作用</h2><p>在列表渲染过程中，key可以提高列表渲染的效率，提高页面的性能，因为<code>v-for</code>更新已渲染的元素列表时，默认用就地复用的原则对列表进行修改，他会根据key的值去判断某个值是否修改，如果修改了key，则重新渲染这一项，否则复用之前的元素。</p><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><p>父传子: 通过<code>v-on</code>绑定一个变量名称，在子组件中用props进行接收</p><p>子传父: 在子组件中绑定一个方法，将参数传入之后通过<code>$emit()</code>传递出去， <code>$emit()</code>里的参数是父组件中定义的方法名称以及参数</p><h2 id="为什么组件里的data必须是函数而不是对象？"><a href="#为什么组件里的data必须是函数而不是对象？" class="headerlink" title="为什么组件里的data必须是函数而不是对象？"></a>为什么组件里的<code>data</code>必须是函数而不是对象？</h2><p> 因为组件在Vue中是可以重复调用的，那么如果这个组件被多次调用并且<code>data</code>是对象的话，所有这个组件的实例会共同share一份<code>data</code>这样就会造成数据的泄漏，并且组件中的数据会对不上号，可能实例a的数据应用在了实例b上， 所以如果<code>data</code>是函数，就能确保每一个实例都有一份自己的<code>data</code>,使得统一组件的不同实例间的<code>data</code>不会互相影响。</p><h2 id="怎样理解Vue的单向数据流"><a href="#怎样理解Vue的单向数据流" class="headerlink" title="怎样理解Vue的单向数据流"></a>怎样理解Vue的单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h2 id="Vue中key的作用"><a href="#Vue中key的作用" class="headerlink" title="Vue中key的作用"></a>Vue中key的作用</h2><p> key是为Vue中vnode的唯一标记，通过key，我们的diff操作可以更加准确，更快速，Vue的diff过程可以概括为: oldCh和newCh各有两个头尾的变量oldStartIndex, oldEndIndex和newStartIndex, newEndIndex，新旧节点会两两对比，即一共有四种比较方式, 如果以上4种都没有匹配，如果设置了key，就会用key再进行比较，在比较的过程中，遍历会往中间靠，一旦StartIndex &gt; EndIndex表明oldCh和newCh至少一个已经遍历完了，就会结束比较(如果没有key,4种都没有匹配成功就会将newStartIndex所在的节点直接生成新的节点且插入到原有的root的子节点中)</p><p>VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。</p><p>所以key是Vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确，更快速</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。<br>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p><h2 id="Vue2-x和Vue3-x渲染器的diff不同处"><a href="#Vue2-x和Vue3-x渲染器的diff不同处" class="headerlink" title="Vue2.x和Vue3.x渲染器的diff不同处"></a>Vue2.x和Vue3.x渲染器的diff不同处</h2><p>简单来说，diff算法的过程</p><p>(1). 同级比较，再比较子节点;<br>(2). 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除);<br>(3). 比较都有子节点的情况;<br>(4). 递归比较子节点;</p><p>正常Diff两个树的时间复杂度时O(N ^ 3),但实际情况下我们很少会进行跨层级的移动DOM,所以Vue将Diff进行优化，从O(N^3) -&gt; O(N)只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较</p><h3 id="vue2-vu3算法区别"><a href="#vue2-vu3算法区别" class="headerlink" title="vue2 vu3算法区别"></a>vue2 vu3算法区别</h3><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。</p><p>Vue3的diff算法在创建VNode时就确定其类型1，以及在mounted/patch的过程中采用位运算来判断一个VNode的类型，在这个基础上再配合核心的Diff算法</p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点：</p><p>首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；</p><p>在vnode没有文本节点的情况下，进入子节点的 diff；</p><ul><li>当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；</li></ul><ul><li>若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中；</li></ul><ul><li>若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；</li></ul><ul><li>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。</li></ul><h2 id="Vue事件绑定原理"><a href="#Vue事件绑定原理" class="headerlink" title="Vue事件绑定原理"></a>Vue事件绑定原理</h2><p>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p><h2 id="watch中deep和immediate的作用？"><a href="#watch中deep和immediate的作用？" class="headerlink" title="watch中deep和immediate的作用？"></a>watch中deep和immediate的作用？</h2><p>deep，默认值是 false，代表是否深度监听。<br>immediate:true代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。</p><h2 id="Vue模版编译原理"><a href="#Vue模版编译原理" class="headerlink" title="Vue模版编译原理"></a>Vue模版编译原理</h2><p>简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：</p><ol><li>生成AST树</li><li>优化</li><li>codegen</li></ol><p>首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。</p><p>使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p><p>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的AST树转换为可执行的代码。</p><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><ul><li>Vue-router是什么？有哪些组件？</li></ul><p>Vue-router是<code>Vue.js</code>官方的路由管理器，它和<code>Vue.js</code>的核心深度集成，让构建单页面应用变得易如反掌</p><p>共有三个组件分别是<code>&lt;router-link&gt;, &lt;router-view&gt;和&lt;keep-alive&gt;(vue2.0提供)</code></p><ul><li>Vue-router有几种钩子函数？具体时什么以及参数</li></ul><p>(1). 前置守卫 在进入这个路由之前;<br>(2). 全局解析守卫;<br>(3). 后置钩子 ;<br>(4). 路由独享的钩子;<br>(5). 组件内的导航钩子</p><ul><li>导航解析流程</li></ul><p>(1). 导航被触发;</p><p>(2). 在失活的组件里调用<code>beforeRouteLeave</code>守卫;</p><p>(3). 调用全局的<code>beforeEach</code>守卫;</p><p>(4). 在重用的组件里调用<code>beforeRouteUpdate</code>守卫;</p><p>(5). 在路由配置里调用<code>beforeEnter</code>;</p><p>(6). 解析异步路由组件;</p><p>(7). 在被激活的组件里调用<code>beforeRouterEnter</code>;</p><p>(8). 调用全局的<code>beforeResolve</code>守卫;</p><p>(9). 导航被确认;</p><p>(10). 调用全局的<code>afterEach</code>钩子;</p><p>(11). 触发DOM更新;</p><p>(12). 调用<code>beforeRouterEnter</code>守卫中传给<code>next</code>的回调函数，创建好的组件实例会作为回调函数的参数传入;</p><h2 id="route和-router的区别是什么？"><a href="#route和-router的区别是什么？" class="headerlink" title="$route和$router的区别是什么？"></a>$route<code>和</code>$router的区别是什么？</h2><p><code>router</code>为vue-router的实例，是一个全局路由对象，包含了路由跳转的方法，钩子函数等</p><p><code>route</code>是路由信息对象和跳转的路由对象，每一个路由都一个route对象，是一个局部对象，包含<code>path, params, hash, query, fullpath, matched, name</code>等路由信息参数</p><h2 id="Vue-router传参方式"><a href="#Vue-router传参方式" class="headerlink" title="Vue-router传参方式"></a>Vue-router传参方式</h2><p>(1). 直接调用<code>$router.push</code>实现携带参数的跳转;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;path: `/describe/$&#123;id&#125;`&#125;)</span><br><span class="line"></span><br><span class="line">// 对应的路由配置</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/describe/:id&#x27;,</span><br><span class="line">    name: &#x27;Describe&#x27;,</span><br><span class="line">    component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure><p>(2).父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。</p><pre><code>this.$router.push(&#123;    name: &#39;Describe&#39;,    params: &#123;        id: id    &#125;&#125;)&#123;    path: &#39;/describe/:id&#39;,    name: &#39;Describe&#39;,    component: Describe&#125;this.$route.params.id</code></pre><p>(3). 父组件：使用path来匹配路由，然后通过query来传递参数;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">  path: &#x27;/describe&#x27;,</span><br><span class="line">  query: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> path: &#x27;/describe&#x27;,</span><br><span class="line"> name: &#x27;Describe&#x27;,</span><br><span class="line"> component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.query.id</span><br></pre></td></tr></table></figure><h2 id="Vue-router的跳转方式"><a href="#Vue-router的跳转方式" class="headerlink" title="Vue-router的跳转方式"></a>Vue-router的跳转方式</h2><p>(1). router-link;<br>(2). this.$router.push();<br>(3). this.$router.replace();<br>(4). this.$router.go();<br>(5). this.$router.forward();<br>(6). this.$router.back();</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取新的state的值，重新渲染Vue componments,界面随之更新</p><p><strong>vuex为什么需要用 mutation 这些来修改 state 数据，而不是直接更改</strong></p><p>Vuex 单向数据流有关，因为需要知道数据修改的来源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;真实DOM和其解析流程&quot;&gt;&lt;a href=&quot;#真实DOM和其解析流程&quot; class=&quot;headerlink&quot; title=&quot;真实DOM和其解析流程&quot;&gt;&lt;/a&gt;真实DOM和其解析流程&lt;/h2&gt;&lt;p&gt;(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue" scheme="https://andylinwenqin.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>v-bind</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/v-bind/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/v-bind/</id>
    <published>2021-09-04T12:04:21.000Z</published>
    <updated>2021-09-04T15:27:40.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><hr><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A-HTML-Class">绑定 HTML Class</a></h2><p><a href="https://learning.dcloud.io/#/?vid=7">观看本节视频讲解</a></p><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95">对象语法</a></h3><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据 property <code>isActive</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthiness</a>。</p><p>你可以在对象中传入更多字段来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class attribute 共存。当有如下模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p><p>绑定的数据对象不必内联定义在模板里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#x27;text-danger&#x27;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<a href="https://cn.vuejs.org/v2/guide/computed.html">计算属性</a>。这是一个常用且强大的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95">数组语法</a></h3><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#x27;active&#x27;,</span><br><span class="line">  errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 是 truthy[<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1">1]</a> 时才添加 <code>activeClass</code>。</p><p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A">用在组件上</a></h3><blockquote><p>这个章节假设你已经对 <a href="https://cn.vuejs.org/v2/guide/components.html">Vue 组件</a>有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p></blockquote><p>当在一个自定义组件上使用 <code>class</code> property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。</p><p>例如，如果你声明了这个组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在使用它的时候添加一些 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>HTML 将被渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>对于带数据绑定 class 也同样适用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 为 truthy[<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1">1]</a> 时，HTML 将被渲染成为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F">绑定内联样式</a></h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-1">对象语法</a></h3><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &#x27;red&#x27;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &#x27;red&#x27;,</span><br><span class="line">    fontSize: &#x27;13px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对象语法常常结合返回对象的计算属性使用。</p><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-1">数组语法</a></h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80">自动添加前缀</a></h3><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix">浏览器引擎前缀</a>的 CSS property 时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%A4%9A%E9%87%8D%E5%80%BC">多重值</a></h3><blockquote><p>2.3.0+</p></blockquote><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p><p><strong>译者注</strong><br>[1] truthy 不是 <code>true</code>，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">MDN</a> 的解释。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Class-与-Style-绑定&quot;&gt;&lt;a href=&quot;#Class-与-Style-绑定&quot; class=&quot;headerlink&quot; title=&quot;Class 与 Style 绑定&quot;&gt;&lt;/a&gt;Class 与 Style 绑定&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;操作元素的 cla</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS动画</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/CSS%E5%8A%A8%E7%94%BB/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/CSS%E5%8A%A8%E7%94%BB/</id>
    <published>2021-09-04T08:42:38.000Z</published>
    <updated>2021-09-04T09:30:02.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS动画和实现方法"><a href="#CSS动画和实现方法" class="headerlink" title="CSS动画和实现方法"></a>CSS动画和实现方法</h1><hr><h2 id="css3颜色渐变"><a href="#css3颜色渐变" class="headerlink" title="css3颜色渐变"></a>css3颜色渐变</h2><p>CSS 渐变使您可以显示两种或多种指定颜色之间的平滑过渡。</p><p>CSS 定义了两种渐变类型：</p><ul><li><em>线性渐变</em>（向下/向上/向左/向右/对角线）</li><li><em>径向渐变</em>（由其中心定义）</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom right, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904164739.png"></p><h3 id="使用角度"><a href="#使用角度" class="headerlink" title="使用角度"></a>使用角度</h3><p>如果希望对渐变角度做更多的控制，您可以定义一个角度，来取代预定义的方向（向下、向上、向右、向左、向右下等等）。值 0deg 等于向上（to top）。值 90deg 等于向右（to right）。值 180deg 等于向下（to bottom）。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(-<span class="number">90deg</span>, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用透明度"><a href="#使用透明度" class="headerlink" title="使用透明度"></a>使用透明度</h3><p>CSS 渐变还支持透明度，也可用于创建渐变效果。</p><p>如需添加透明度，我们使用 rgba() 函数来定义色标。 rgba() 函数中的最后一个参数可以是 0 到 1 的值，它定义颜色的透明度：0 表示全透明，1 表示全彩色（无透明）。</p><p>下面的例子展示了从左开始的线性渐变。它开始完全透明，然后过渡为全色红色：</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background-image: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css3使用animation属性实现背景颜色动态渐变的效果"><a href="#css3使用animation属性实现背景颜色动态渐变的效果" class="headerlink" title="css3使用animation属性实现背景颜色动态渐变的效果"></a>css3使用animation属性实现背景颜色动态渐变的效果</h2><p>首先我们来看一下CSS3关键帧动画的基础知识</p><p>让我们先了解逐渐改变元素的动画！在CSS 3 animation属性中，您可以设置关键帧并绘制详细的运动。关于动画的时间和时机、无限的循环，只有CSS就可以指定了！</p><h3 id="什么是关键帧？"><a href="#什么是关键帧？" class="headerlink" title="什么是关键帧？"></a>什么是关键帧？</h3><p>关键帧（传递点）是在动画中定义更改的帧。我们@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，您需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。</p><p>@keyframes规则的名称声明为“ @keyframes +任意名称 ”。我将写入0％到100％的关键帧信息。0％表示开始动画，100％表示结束时间。0％from，100％可以用to替换。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> name &#123;</span><br><span class="line"> <span class="number">0%</span> &#123; <span class="attribute">background</span>: red; &#125;</span><br><span class="line"> <span class="number">50%</span> &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line"> <span class="number">100%</span> &#123; <span class="attribute">background</span>: pink; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="animation相关属性"><a href="#animation相关属性" class="headerlink" title="animation相关属性"></a>animation相关属性</h3><p><strong>animation-name（动画名）</strong></p><p>@keyframes指定中定义的名称。如果未指定此项，则不会执行动画。此外，如果指定的动画名称与任何关键帧都不匹配，则不会执行该关键帧。</p><p><strong>animation-duration（动画持续时间）</strong></p><p>通过“秒+ s”指定执行一个动画的时间长度。例如，“5秒”持续5秒。如果为0，则不会执行。即使指定了负值，也会将其视为0。</p><p><strong>animation-timing-function（动画定时功能）</strong></p><p>指定动画的时间以及如何继续。您可以通过调整动画进度速度的比例来表达平滑运动。</p><p><strong>ease（初期値）</strong></p><p>ease-in</p><p>ease-out</p><p>ease-in-out</p><p>linear</p><p><strong>animation-delay（动画延迟）</strong></p><p>读取元素时，从“元素编号+ s”指定“动画开始”的时间。例如，“5秒”持续5秒。初始值0将立即执行。</p><p><strong>animation-iteration-count（动画迭代计数）</strong></p><p>指定使用数字重复动画的次数。infinite要指定无限循环，请指定。</p><p><strong>animation-direction（动画方向）</strong></p><p>指定重复动画的方向。</p><p><strong>normal …正常方向播放（初始值）</strong></p><p>alternate …在正常和偶数时间以相反方向重新生成奇数次（返回并返回…）</p><p>reverse…向后播放</p><p>alternate-reverse…反向播放</p><p><strong>animation-play-state（动画播放状态）</strong></p><p>指定动画暂停（paused）和播放（running）。但是，似乎没有太多使用。</p><p>animation-fill-mode（动画填充模式）</p><p>指定播放动画之前和之后的状态。</p><p>none（默认值）</p><p>forwards..播放后保持最后一个关键帧的状态</p><p>backwards…在播放前应用第一个关键帧的状态</p><p>both … forwards ……向前和向后都应用</p><h3 id="属性总结"><a href="#属性总结" class="headerlink" title="属性总结"></a>属性总结</h3><p>animation属性允许您分别指定每个属性的值，用空格分隔。项目可以省略，但动画名称必须在执行前写入。建议按以下顺序列出。</p><p>animation-name（动画名）</p><p>animation-duration（动画持续时间）</p><p>animation-timing-function（动画定时功能）</p><p>animation-delay（动画延迟）</p><p>animation-iteration-count（动画迭代计数）</p><p>animation-direction（动画方向）</p><p>animation-fill-mode（动画填充模式）</p><p>animation-play-state（动画播放状态）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: test <span class="number">5s</span> ease <span class="number">1s</span> infinite forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面我们来看看背景颜色改变的具体内容</strong></p><p>在了解了基础的知识之后，我们来详细看看具体的实现方法。首先，将关键帧的名称设置为“bg - color”，并将背景颜色设置为从0到100％的过渡。如果将相同的颜色设置为0％和100％，则在循环动画时它会平滑移动。我们还将描述您为基于Webkit的浏览器启用的版本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@-webkit-keyframes</span> bg-color &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">  <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span><br><span class="line">  <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span><br><span class="line">  <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span><br><span class="line">  <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> bg-color &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">  <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span><br><span class="line">  <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span><br><span class="line">  <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span><br><span class="line">  <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于此时指定整个网页的背景颜色，body以animation指定属性。值为“关键帧名称”，bg-color“更改”在10秒内添加，“，10s”指定无限循环infinite。不要忘记webkit的版本。background-color让我们指定基本背景颜色作为背景色，为动画不起作用的情况做准备。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">              <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line"><span class="css">              <span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="css">              -webkit-<span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="keyword">@-webkit-keyframes</span> bg-color &#123;</span></span><br><span class="line"><span class="css">                <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="keyword">@keyframes</span> bg-color &#123;</span></span><br><span class="line"><span class="css">                <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">            &#125; </span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>andyLin博客<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904170016.gif"></p><h2 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h2><h2 id="实现一个简单的三角形"><a href="#实现一个简单的三角形" class="headerlink" title="实现一个简单的三角形"></a>实现一个简单的三角形</h2><p>使用CSS盒模型中的border（边框）即可实现如下所示的三角形：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904170941.webp"></p><p>CSS实现简单三角形</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>首先来看在为元素添加border时，border的样子；假设有如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    border: 2px solid orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171004.webp"></p><p>border的一般使用</p><p>这是我们平常使用border最普遍的情况——往往只给border一个较小的宽度（通常为1-2px）；然而这样的日常用法就会容易让大家对border的形成方式产生<strong>误解</strong>，即认为元素的border是由四个矩形边框拼接而成。</p><p>然而事实并不是这样。实际上，元素的border是由<strong>三角形</strong>组合而成，为了说明这个问题，我们可以增大border的宽度，并为各border边设置不同的颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171017.webp"></p><p>border的形成方式</p><p>既然如此，那么更进一步，把元素的内容尺寸设置为0会发生什么情况呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171026.webp"></p><p>元素内容尺寸为0</p><p>我们将惊奇地发现，此时元素由上下左右4个三角形“拼接”而成；那么，为了实现最终的效果，即保留最下方的三角形，还应该怎么做？很简单，我们只需要把其它border边的颜色设置为<strong>白色</strong>或<strong>透明色</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171041.webp"></p><p>Duang~ 最终的简单三角形就绘制出来了。同理，如果想要得到其它边上的三角形，只需要将剩余的border边颜色设置为白色或透明色即可。</p><p>不过，被“隐藏”的上border仍然占据着空间，要想使得绘制出的三角形尺寸最小化，还需要将上border的宽度设置为0（其它情况同理）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">40px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出自-CSS绘制三角形—border法"><a href="#出自-CSS绘制三角形—border法" class="headerlink" title="出自 CSS绘制三角形—border法"></a>出自 <a href="https://www.jianshu.com/p/9a463d50e441">CSS绘制三角形—border法</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS动画和实现方法&quot;&gt;&lt;a href=&quot;#CSS动画和实现方法&quot; class=&quot;headerlink&quot; title=&quot;CSS动画和实现方法&quot;&gt;&lt;/a&gt;CSS动画和实现方法&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;css3颜色渐变&quot;&gt;&lt;a href=&quot;#css3颜色渐变</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>watch和computed</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/watch%E5%92%8Ccomputed/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/watch%E5%92%8Ccomputed/</id>
    <published>2021-09-04T07:31:54.000Z</published>
    <updated>2021-09-04T15:38:06.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算属性computed："><a href="#计算属性computed：" class="headerlink" title="计算属性computed："></a>计算属性computed：</h1><ul><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li><li>如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li></ul><h1 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a>侦听属性watch：</h1><ul><li>不支持缓存，数据变，直接会触发相应的操作；</li><li>watch支持异步；</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li></ul><h1 id="watch和computed的区别和应用场景（面试版）"><a href="#watch和computed的区别和应用场景（面试版）" class="headerlink" title="watch和computed的区别和应用场景（面试版）"></a>watch和computed的区别和应用场景（面试版）</h1><pre><code>计算属性`computed`和监听器`watch`都可以观察属性的变化从而做出响应，不同的是: 计算属性`computed`更多是作为缓存功能的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，`computed`不会立即重新计算生成新的值，而是先标记为脏数据，当下次`computed`被获取的时候，才会进行重新计算并返回;而监听器`watch`并不具备缓存性，监听器`watch`提供一个监听函数，当监听的属性发生变化时，会立即执行该函数异步请求就用`watch`computed: 是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时，才会重新计算computed的值watch: 更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续的操作应用场景:    (1).当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可利用computed的缓存特性，避免每次获取值时，都要重新计算;    (2). 当我们需要在数据变化时执行异步或者开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的;</code></pre><p><strong>immediate</strong>：<strong>组件加载立即触发回调函数执行</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = newName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 代表在wacth里声明了firstName这个方法之后立即执行handler方法</span></span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    <span class="built_in">handler</span>(newName, oldName) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&#x27;obj.a changed&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h1><table><thead><tr><th></th><th>watch</th><th align="right">computed</th></tr></thead><tbody><tr><td>定义格式</td><td>必须监听存在的属性(data、props、computed)</td><td align="right">不能和data定义的变量相同</td></tr><tr><td>异步</td><td>支持异步操作</td><td align="right">不支持异步</td></tr><tr><td>开销</td><td>适合一些开销较大的操作</td><td align="right">适合做一些简单依赖的计算</td></tr></tbody></table><p>对于computed能做的 watch都可以做，至于选择哪个去做，都应该去看使用场景</p><h2 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h2><p>第一个输入框+第二个输入框 进行拼接</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904153613.png"></p><pre><code>&lt;input type=&quot;text&quot; v-model=&quot;num1&quot; name=&quot;&quot; id=&quot;&quot;&gt;+&lt;input type=&quot;text&quot; v-model=&quot;num2&quot; name=&quot;&quot; id=&quot;&quot;&gt;=&#123;&#123;num3&#125;&#125;&#123;&#123;res&#125;&#125;</code></pre><h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">      res()&#123;</span><br><span class="line">      this.num3= this.num1+this.num2</span><br><span class="line">      &#125;,</span><br><span class="line">      num2()&#123;</span><br><span class="line">      this.num3= this.num1+this.num2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  res() &#123;</span><br><span class="line">    return this.num1+this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><p>从代码量来看 显然更适合 用计算属性去做，而使用watch 就要检测两个值的变化 稍微繁琐了些</p></li><li><p>但是 watch 可以做一些异步的事情 并且可以设置改变多个值   这是计算属性做不到的</p></li></ul><h2 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h2><p>关于缓存问题 个人感觉 这两个并不能比，可以用computed和methods去比</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre><code>&#123;&#123;res()&#125;&#125;&#123;&#123;res()&#125;&#125; methods: &#123;  res() &#123;    console.log(&#39;方法被执行了&#39;);   return this.num1+this.num2  &#125;&#125;,</code></pre><p> 如果视图上多个使用这个方法 每个调用都会执行 </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904153529.png"></p><h3 id="计算属性-1"><a href="#计算属性-1" class="headerlink" title="计算属性"></a>计算属性</h3><p> 而计算属性不同，只有当值发生改变的时候他才会执行，如果上次没有改变他会取从缓存拿值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;res&#125;&#125;</span><br><span class="line">&#123;&#123;res&#125;&#125;</span><br><span class="line"> </span><br><span class="line">computed: &#123;</span><br><span class="line">  res() &#123;</span><br><span class="line">    console.log(&#x27;计算属性执行了&#x27;);</span><br><span class="line">    return this.num1+this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算属性computed：&quot;&gt;&lt;a href=&quot;#计算属性computed：&quot; class=&quot;headerlink&quot; title=&quot;计算属性computed：&quot;&gt;&lt;/a&gt;计算属性computed：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;支持缓存，只有依赖数据发生改变，才会重新</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>属性选择器</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2021-09-04T06:36:46.000Z</published>
    <updated>2021-09-04T07:31:58.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><hr><p>CSS <strong>属性选择器</strong>通过已经存在的属性名或属性值匹配元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存在title属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在class属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">&quot;logo&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p><code>[attr]</code></p><p>表示带有以 attr 命名的属性的元素。</p></li><li><p><code>[attr=value]</code></p><p>表示带有以 attr 命名的属性，且属性值为 value 的元素。</p></li><li><p><code>[attr~=value]</code></p><p>表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 value。</p></li><li><p><code>[attr|=value]</code></p><p>表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（”<code>-</code>“为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。</p></li><li><p><code>[attr^=value]</code></p><p>表示带有以 attr 命名的属性，且属性值是以 value 开头的元素。</p></li><li><p><code>[attr$=value]</code></p><p>表示带有以 attr 命名的属性，且属性值是以 value 结尾的元素。</p></li><li><p><code>[attr*=value]</code></p><p>表示带有以 attr 命名的属性，且属性值至少包含一个 value 值的元素。</p></li><li><p><code>[*attr* *operator* *value* i]</code></p><p>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>i</code>（或 <code>I</code>），可以在匹配属性值时忽略大小写（支持 ASCII 字符范围之内的字母）。</p></li><li><p><code>[*attr* *operator* *value* s]</code> </p><p>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>s</code>（或 <code>S</code>），可以在匹配属性值时区分大小写（支持 ASCII 字符范围之内的字母）。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以 &quot;#&quot; 开头的页面本地链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;#&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;example&quot; 的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: silver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;insensitive&quot; 的链接,不区分大小写 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;insensitive&quot;</span> i]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: cyan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;cAsE&quot; 的链接，区分大小写 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;cAsE&quot;</span> s]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以 &quot;.org&quot; 结尾的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;属性选择器&quot;&gt;&lt;a href=&quot;#属性选择器&quot; class=&quot;headerlink&quot; title=&quot;属性选择器&quot;&gt;&lt;/a&gt;属性选择器&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;CSS &lt;strong&gt;属性选择器&lt;/strong&gt;通过已经存在的属性名或属性值匹配元素。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误</title>
    <link href="https://andylinwenqin.github.io/2021/08/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux-centos7%E7%B3%BB%E7%BB%9F-%E5%8F%8A-mysql8%EF%BC%88%E8%80%81%E7%89%88%E6%9C%AC%EF%BC%89%E9%85%8D%E7%BD%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://andylinwenqin.github.io/2021/08/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux-centos7%E7%B3%BB%E7%BB%9F-%E5%8F%8A-mysql8%EF%BC%88%E8%80%81%E7%89%88%E6%9C%AC%EF%BC%89%E9%85%8D%E7%BD%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/</id>
    <published>2021-08-23T07:11:19.000Z</published>
    <updated>2021-08-23T09:16:08.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误"><a href="#虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误" class="headerlink" title="虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误"></a>虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误</h1><hr><h2 id="VMware安装虚拟机centos7的步骤，截图讲解"><a href="#VMware安装虚拟机centos7的步骤，截图讲解" class="headerlink" title="VMware安装虚拟机centos7的步骤，截图讲解"></a><a href="https://zhuanlan.zhihu.com/p/87740022">VMware安装虚拟机centos7的步骤，截图讲解</a></h2><p>安装前准备以下路径下载centOS7镜像：<a href="https://link.zhihu.com/?target=https://mirrors.aliyun.com/centos/7/isos/x86_64/">https://mirrors.aliyun.com/cent</a></p><h3 id="安装虚拟机的步骤"><a href="#安装虚拟机的步骤" class="headerlink" title="安装虚拟机的步骤"></a>安装虚拟机的步骤</h3><p>1.点击“创建虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153337.jpg"></p><p>2.点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153405.jpg"></p><p>3.点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153416.jpg"></p><p>4.选择“稍后安装操作系统”，然后“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153430.jpg"></p><p>5.选择Linux—&gt;&gt;版本号CentOS–&gt;&gt;下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153442.jpg"></p><p>6.填写“虚拟机名称”以及选择存放路径 ，然后点击下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153451.jpg"></p><p>7.选择处理器数显 默认是1 我这里选项2，然后“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153936.jpg"></p><p>8.选择内存，我这里选着2，默认是1 然后下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153513.jpg"></p><p>9.选择网络类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153525.jpg"></p><p>10.控制器类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153538.jpg"></p><p>11.磁盘类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153548.jpg"></p><p>12.选着“创建新虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153559.jpg"></p><p>13.这里磁盘大小，随便多少都行，5GB也行，磁盘存储单文件或者多文件都行，然后点击下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153606.jpg"></p><p>14。点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154107.jpg"></p><p>15。选自定义，然后选择刚才下载的镜像，然后点击“关闭”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153704.jpg"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153716.jpg"></p><p>16.点击“完成”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154256.jpg"></p><p>17.点击“开始此虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154400.jpg"></p><p>18.等待安装中</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154423.jpg"></p><p>19.选择键盘操作语言，我选择“中文简体”，然后点击“继续”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154513.jpg"></p><p>然后选择“软件选择”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154551.jpg"></p><p>然后顺便你选择 我闲着图形界面，点击“完成”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154611.jpg"></p><p>20 点击 选择时间</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154629.jpg"></p><p>然后选择亚洲–上海时间，———》点击完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154723.jpg"></p><p>21.选分区</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155241.jpg"></p><p>22.选着网络配置</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155256.jpg"></p><p>首先要打开网卡，然后查看是否能获取到IP地址</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155508.jpg"></p><p>23.点击“开始安装”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160228.jpg"></p><p>24.点击设置“密码”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160243.jpg"></p><p>填写密码，点击完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160256.jpg"></p><p>这里也可以创建用户，但是我创建用户，然后<strong>等待安装中</strong></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160307.jpg"></p><p>25.安装完成，点击重启</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160323.jpg"></p><p>26.点击重启后，点击然后接受–完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160350.jpg"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160413.jpg"></p><p>然后完成配置</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160423.jpg"></p><p>设置用户名</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160433.jpg"></p><p>安装成功</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160458.jpg"></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>1.在终端中切换目录 ：cd /etc/sysconfig/network-scripts/</p><p>2.在查看当前目录的文件：ls -a</p><p>3.输入su 切换到根目录root中，输入根目录的密码，点击Enter键</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160630.jpg"></p><p>4.输入vi ifcfg-ens33 打开网络配置文件点击“i”进入可编辑文件</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160842.jpg"></p><p>将ONBOOT=no改为ONBOOT=yes，即可配置开机自启动。多增加这几行</p><p>IPADDR=192.168.117.128(ip地址)</p><p>NETMASK=255.255.255.0(子网掩码)</p><p>GATEWAY=192.168.117.13(默认路由)</p><p>DNS1=114.114.114.114(dns)</p><p>按ESC后，再输入:wq，按Enter键，即可保存并退出编辑。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823161006.png"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160938.jpg"></p><p>退出到命令行界面，然后输入重启命令reboot，重启一下系统即可。</p><p>测试外网成功</p><p>ping baidu.com</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823161204.jpg"></p><h2 id="Linux环境-Centos-7-安装MySQL数据库"><a href="#Linux环境-Centos-7-安装MySQL数据库" class="headerlink" title="Linux环境(Centos 7)安装MySQL数据库"></a><a href="https://www.cnblogs.com/guoxiangyue/p/12768560.html">Linux环境(Centos 7)安装MySQL数据库</a></h2><h3 id="1-卸载mariadb"><a href="#1-卸载mariadb" class="headerlink" title="1.卸载mariadb"></a>1.卸载mariadb</h3><p>查看是否已安装mariadb</p><p># yum list installed mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164227.png"></p><p>系统中已经安装mariadb，进行卸载。</p><p># yum remove mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164237.png"></p><p>查看是否卸载成功</p><p># yum list installed mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164251.png"></p><p>删除mariadb配置文件</p><p># rm -f /etc/my.cnf </p><p>删除mariadb数据目录</p><p># rm -rf /var/lib/mysql/  </p><h3 id="2-下载MySQL-使用rpm来安装MySQL"><a href="#2-下载MySQL-使用rpm来安装MySQL" class="headerlink" title="2.下载MySQL 使用rpm来安装MySQL"></a>2.下载MySQL 使用rpm来安装MySQL</h3><p>因为CentOS 7默认安装的数据库是Mariadb,所以使用YUM命令是无法安装MySQL的，只会更新Mariadb。使用rpm来进行安装。可以在<a href="https://links.jianshu.com/go?to=http://repo.mysql.com/">mysql的repo源仓库</a>右键复制指定版本的数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># wget http:<span class="comment">//repo.mysql.com/mysql80-community-release-el7-1.noarch.rpm</span></span></span><br></pre></td></tr></table></figure><p>安装mysql80-community-release-el7-1.noarch.rpm包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo rpm -ivh mysql80-community-release-el7-<span class="number">1</span><span class="selector-class">.noarch</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><p>安装完成后会在 /etc/yum.repos.d文件夹里面获得两个文件：mysql-community.repo &amp;&amp; mysql-community-source.repo</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165019.webp"><br> 使用yum安装mysql服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo yum install mysql-server</span></span><br></pre></td></tr></table></figure><p>如果显示以下内容说明安装成功<br> <strong>Complete!</strong><br> 检查是否已经设置为开机启动MySQL服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl list-unit-files|grep mysqld</span></span><br></pre></td></tr></table></figure><p>如果显示</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165122.webp"></p><p> 则表示已经设置为开机启动，如果没有设置为开机启动则执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl enable mysqld.service</span></span><br></pre></td></tr></table></figure><p>查看MySQL是否启动未启动则执行启动服务命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看是否启动MySQL服务</span><br><span class="line"><span class="comment"># ps -ef|grep mysql</span></span><br><span class="line"></span><br><span class="line">启动服务</span><br><span class="line"><span class="comment"># systemctl start mysqld.service</span></span><br></pre></td></tr></table></figure><p>初始化MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld --initialize</span></span><br></pre></td></tr></table></figure><p>查看MySQL初始默认密码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grep <span class="string">&#x27;temporary password&#x27;</span> /<span class="keyword">var</span>/log/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165150.webp"> 复制 root@localhost: 后面的密码。登录mysql，并粘贴默认密码<br> 因为MySQL8.0的更改，导致必须要重置密码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;12345678&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果设置密码时候出现提示</p><blockquote><p>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</p></blockquote><p>代表需要降低policy的等级后在执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>开启MySQL远程连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="comment">#修改root账户权限</span></span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="comment">#刷新权限</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>到此完成mysql基本安装和配置  快拍一个虚拟机快照啊</p><h2 id="登录mysql和退出mysql"><a href="#登录mysql和退出mysql" class="headerlink" title="登录mysql和退出mysql"></a>登录mysql和退出mysql</h2><p>linux中登录mysql的方式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 127.0.0.1 -p；</span><br></pre></td></tr></table></figure><p>退出MySQL  输入 exit    摁enter</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><p>1.通过yum -y install python-pip命令进行安装提示没有可用软件包 python-pip</p><p>2、接着执行：yum -y install epel-release python-pip命令</p><p>3、最后在次执行：yum -y install python-pip即可成功</p><p>4、然后可通过pip -V查看版本</p><p>5、然后通过：pip install –upgrade pip –user进行升级</p><p>6、然后在执行：pip install –upgrade pip</p><p>7、此时在pip -V看版本即可升级成功</p><h2 id="mysql-老版本-配置问题及解决方法"><a href="#mysql-老版本-配置问题及解决方法" class="headerlink" title="mysql(老版本)配置问题及解决方法"></a>mysql(老版本)配置问题及解决方法</h2><h3 id="1、缺少libmysqlclient-so-18"><a href="#1、缺少libmysqlclient-so-18" class="headerlink" title="1、缺少libmysqlclient.so.18"></a>1、缺少libmysqlclient.so.18</h3><p> 发生服务器错误： Error loading MySQLdb module: libmysqlclient.so.18: cannot open shared object file: No such file or directory</p><h4 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h4><p>这个错误出现的原因是找不到 libmysqlclient.so.18 这个文件，根本原因是，一般我们使用的mysql都是自己从新安装的，不是系统自带的，所以在我们安装我们自己的mysql的时候，会把删除原来的mysql，此时会连带这删掉这个文件，32的目录是 /usr/lib/mysql/，64位的为 /usr/lib64/mysql/下面有这个文件。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>　　1、解决问题的关键是，在找一台未装过mysql的服务器，然后把此文件夹下面的 libmysqlclient.so.18.0.0 文件拷贝到此服务器的这个目录中，然后做软连接。</p><p>​        我选择更好的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/lib/libmysqlclient.so.18 http://files.directadmin.com/services/es_7.0_64/libmysqlclient.so.18</span><br></pre></td></tr></table></figure><p>直接下载缺失文件到对应位置</p><p>　　2、然后 vi /etc/ld.so.conf 后面增加一条记录：/usr/lib64/mysql （libmysqlclient.so.18 和libmysqlclient.so.18.0.0所在目录）</p><p>　　3、运行 ldconfig 命令，让其生效。</p><p>　　ok,完美解决。</p><h3 id="2-Django启动服务器时，报错mysql的2059错误的解决办法。"><a href="#2-Django启动服务器时，报错mysql的2059错误的解决办法。" class="headerlink" title="2.Django启动服务器时，报错mysql的2059错误的解决办法。"></a>2.Django启动服务器时，报错mysql的2059错误的解决办法。</h3><p>启动方式为如下：</p><blockquote><p>python manage.py runserver 0.0.0.0:8000</p></blockquote><p>经过一番查询，调试，最终发现了问题所在。主要就是mysql8.0的问题。<br>目前最新的mysql8.0对用户密码的加密方式为caching_sha2_password, django暂时还不支持这种新增的加密方式。只需要将用户加密方式改为老的加密方式即可。</p><p>解决步骤：<br>1.登录mysql，连接用户为root。</p><blockquote><p>mysql -u root -p</p></blockquote><p>2.执行命令查看加密方式</p><blockquote><p>use mysql;<br>select user,plugin from user where user=’root’;</p></blockquote><p>3.执行命令修改加密方式</p><blockquote><p>alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘yourpassword’</p></blockquote><p>4.属性权限使配置生效</p><blockquote><p>flush privileges</p></blockquote><p>其中遇到两个小问题</p><h4 id="1-Your-password-does-not-satisfy-the-current-policy-requirements"><a href="#1-Your-password-does-not-satisfy-the-current-policy-requirements" class="headerlink" title="1.Your password does not satisfy the current policy requirements"></a>1.Your password does not satisfy the current policy requirements</h4><p>密码策略问题异常信息</p><p>不符合正确密码规范</p><p>解决办法：</p><p>1、查看 mysql 初始的密码策略，<br>输入语句 “ SHOW VARIABLES LIKE ‘validate_password%’; ” 进行查看</p><p>2、首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，<br>输入设值语句 “ set global validate_password_policy=LOW; ” 进行设值，</p><p>3、当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，<br>输入设值语句 “ set global validate_password_length=6; ” 进行设值，</p><p>4、现在可以为 mysql 设置简单密码了，只要满足六位的长度即可，<br>输入修改语句 “ ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; ” 可以看到修改成功，表示密码策略修改成功了！！！</p><p>关于 mysql 密码策略相关参数；<br>1）、validate_password_length  固定密码的总长度；<br>2）、validate_password_dictionary_file 指定密码验证的文件路径；<br>3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；<br>4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；<br>5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；<br>关于 validate_password_policy 的取值：<br>0/LOW：只验证长度；<br>1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；<br>6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</p><h4 id="2-Operation-ALTER-USER-failed-for-‘root‘-’localhost’"><a href="#2-Operation-ALTER-USER-failed-for-‘root‘-’localhost’" class="headerlink" title="2.Operation ALTER USER failed for ‘root‘@’localhost’"></a>2.Operation ALTER USER failed for ‘root‘@’localhost’</h4><p>先登录mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select user,host from user;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| root             | %         |</span><br><span class="line">| admin            | localhost |</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| zhangj           | localhost |</span><br><span class="line">+------------------+-----------+</span><br></pre></td></tr></table></figure><p>注意root，host是’%’</p><p>你可能执行的是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p>改成:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">针对github开源项目wechat-spider的部署</summary>
    
    
    
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Linux" scheme="https://andylinwenqin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件传值</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2021-08-19T15:31:21.000Z</published>
    <updated>2021-09-04T05:22:52.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue组件传值"><a href="#Vue组件传值" class="headerlink" title="Vue组件传值"></a>Vue组件传值</h1><hr><p>先看一张总结图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210820002412.png"></p><h2 id="方法一-父组件向子组件传值-（props传参）"><a href="#方法一-父组件向子组件传值-（props传参）" class="headerlink" title="方法一 父组件向子组件传值 （props传参）"></a>方法一 父组件向子组件传值 （props传参）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son</span><br><span class="line">      str=&quot;字符串&quot;</span><br><span class="line">      :num=&quot;5&quot;</span><br><span class="line">      :obj=&quot;&#123; name: &#x27;对象信息&#x27; &#125;&quot;</span><br><span class="line">      :func=&quot;() =&gt; &#123;this.list()&#125;&quot;</span><br><span class="line">      :arr=&quot;arr&quot;</span><br><span class="line">    &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        arr: [1, 2, 3],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      list() &#123;</span><br><span class="line">        console.log(&#x27;list&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      arr: Array, //定义参数类型</span><br><span class="line">      num: Number,</span><br><span class="line">      str: String,</span><br><span class="line">      str2: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;默认是字符串&#x27;, //定义默认值</span><br><span class="line">      &#125;,</span><br><span class="line">      func: &#123;</span><br><span class="line">        type: Function,</span><br><span class="line">        require: false, // 定义参数是否必须值</span><br><span class="line">      &#125;,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        require: false,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(this.str) //字符串</span><br><span class="line">      console.log(this.str2) //默认字符串</span><br><span class="line">      console.log(this.num) //5</span><br><span class="line">      console.log(this.arr) //[1,2,3]</span><br><span class="line">      console.log(this.func()) // list</span><br><span class="line">      console.log(this.obj) // name:&#x27;对象信息&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法二-子组件向父组件传值-（事件传递）"><a href="#方法二-子组件向父组件传值-（事件传递）" class="headerlink" title="方法二 子组件向父组件传值 （事件传递）"></a>方法二 子组件向父组件传值 （事件传递）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son @func=&quot;speak&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">    methods: &#123;</span><br><span class="line">      speak(msg) &#123;</span><br><span class="line">        console.log(msg) //我是子组件发送的消息</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      this.$emit(&#x27;func&#x27;, &#x27;我是子组件发送的消息！&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法三-事件监听"><a href="#方法三-事件监听" class="headerlink" title="方法三 事件监听"></a>方法三 事件监听</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son ref=&quot;son&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">   mounted() &#123;</span><br><span class="line">     this.$refs[&#x27;son&#x27;].$on(&#x27;func&#x27;,(msg)=&gt;&#123;</span><br><span class="line">         console.log(msg);  //我是子组件传递的消息</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$emit(&#x27;func&#x27;, &#x27;我是子组件传递的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法四-消息发布与订阅"><a href="#方法四-消息发布与订阅" class="headerlink" title="方法四 消息发布与订阅"></a>方法四 消息发布与订阅</h2><p>安装pubsub-js插件:  npm install pubsub-js -s //可实现全局参数传递</p><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        pubsub.publishSync(&#x27;sendMsg&#x27;, &#x27;这是A组件发布的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是B组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;B&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      pubsub.subscribe(&#x27;sendMsg&#x27;, (e, msg) =&gt; &#123;</span><br><span class="line">        console.log(e, msg) //sendMsg 这是A组件发布的消息！</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>publishSync 同步发送消息</li><li>publish  同步发送消息</li><li>subscribe 订阅消息</li><li>unsubscribe 卸载特定订阅消息</li><li>clearAllSubscriptions 清除所有订阅消息</li></ul><h2 id="方法五-非父子组件传值-（EventBus传参）"><a href="#方法五-非父子组件传值-（EventBus传参）" class="headerlink" title="方法五 非父子组件传值 （EventBus传参）"></a>方法五 非父子组件传值 （EventBus传参）</h2><p>在main.js中挂载全局EventBus</p><blockquote><p>1.Vue.prototype.$EventBus = new Vue()</p></blockquote><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$EventBus.$emit(&#x27;sendMsg&#x27;,&#x27;这是A组件发送的消息！&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件</strong>B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是组件B&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;B&quot;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            this.$EventBus.$on(&#x27;sendMsg&#x27;,(msg)=&gt;&#123;</span><br><span class="line">                console.log(msg);//这是组件A发送的消息！</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过挂载全局Vue对象传递参数</p><h2 id="方法六-路由间传值"><a href="#方法六-路由间传值" class="headerlink" title="方法六 路由间传值"></a>方法六 路由间传值</h2><h3 id="i-使用问号传值"><a href="#i-使用问号传值" class="headerlink" title="i.使用问号传值"></a>i.使用问号传值</h3><p>A页面跳转B页面时使用 this.$router.push(’/B?name=danseek’)</p><p>B页面可以使用 this.$route.query.name 来获取A页面传过来的值</p><p>上面要注意router和route的区别</p><h3 id="ii-使用冒号传值"><a href="#ii-使用冒号传值" class="headerlink" title="ii.使用冒号传值"></a>ii.使用冒号传值</h3><p>配置如下路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/b/:name&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;../views/B.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>在B页面可以通过 this.$route.params.name 来获取路由传入的name的值</p><h3 id="iii-使用父子组件传值"><a href="#iii-使用父子组件传值" class="headerlink" title="iii.使用父子组件传值"></a>iii.使用父子组件传值</h3><p>由于router-view本身也是一个组件，所以我们也可以使用父子组件传值方式传值，然后在对应的子页面里加上props，因为type更新后没有刷新路由，所以不能直接在子页面的mounted钩子里直接获取最新type的值，而要使用watch。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :type=&quot;type&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 子页面</span><br><span class="line">......</span><br><span class="line">props: [&#x27;type&#x27;]</span><br><span class="line">......</span><br><span class="line">watch: &#123;</span><br><span class="line">    type()&#123;</span><br><span class="line">    // console.log(&quot;在这个方法可以时刻获取最新的数据:type=&quot;,this.type)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法七-Vuex"><a href="#方法七-Vuex" class="headerlink" title="方法七 Vuex"></a>方法七 Vuex</h2><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://blog.csdn.net/dan_seek/article/details/102641761">vue组件传值的11种方式</a></p>]]></content>
    
    
    <summary type="html">Vue组件传值的多种传值方式</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>文本换行省略</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/</id>
    <published>2021-08-19T15:28:19.000Z</published>
    <updated>2021-08-19T15:30:57.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-将一大串文字分两行显示，超出用省略号表示"><a href="#vue-将一大串文字分两行显示，超出用省略号表示" class="headerlink" title="vue 将一大串文字分两行显示，超出用省略号表示"></a>vue 将一大串文字分两行显示，超出用省略号表示</h1><hr><p>众所周知，通过css设置文字强制不换行超出用省略号表示很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: nowrap; 文本强制不换行；</span><br><span class="line"><span class="attribute">text-overflow</span>:ellipsis; 文本溢出显示省略号；</span><br><span class="line"><span class="attribute">overflow</span>:hidden; 溢出的部分隐藏；</span><br></pre></td></tr></table></figure><p>但是如果要想显示两行，超出用省略号表示要怎么写呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure><p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。<br>常见结合属性：<br>1，display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。<br>2，-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。<br>3，text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;a href=&quot;#vue-将一大串文字分两行显示，超出用省略号表示&quot; class=&quot;headerlink&quot; title=&quot;vue 将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;/a&gt;vue 将一大串文字分两行显</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>flex布局设置单个元素靠右</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/flex%E5%B8%83%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9D%A0%E5%8F%B3/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/flex%E5%B8%83%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9D%A0%E5%8F%B3/</id>
    <published>2021-08-19T12:45:02.000Z</published>
    <updated>2021-08-19T15:26:40.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flex布局设置单个元素靠右"><a href="#flex布局设置单个元素靠右" class="headerlink" title="flex布局设置单个元素靠右"></a>flex布局设置单个元素靠右</h1><h2 id="父元素布局"><a href="#父元素布局" class="headerlink" title="父元素布局"></a>父元素布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br></pre></td></tr></table></figure><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: auto;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flex布局设置单个元素靠右&quot;&gt;&lt;a href=&quot;#flex布局设置单个元素靠右&quot; class=&quot;headerlink&quot; title=&quot;flex布局设置单个元素靠右&quot;&gt;&lt;/a&gt;flex布局设置单个元素靠右&lt;/h1&gt;&lt;h2 id=&quot;父元素布局&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>下拉刷新 触底刷新</title>
    <link href="https://andylinwenqin.github.io/2021/08/10/Vue%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%20%E8%A7%A6%E5%BA%95%E5%88%B7%E6%96%B0/"/>
    <id>https://andylinwenqin.github.io/2021/08/10/Vue%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%20%E8%A7%A6%E5%BA%95%E5%88%B7%E6%96%B0/</id>
    <published>2021-08-10T13:34:26.000Z</published>
    <updated>2021-09-04T05:23:04.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下拉刷新-触底刷新"><a href="#下拉刷新-触底刷新" class="headerlink" title="下拉刷新 触底刷新"></a>下拉刷新 触底刷新</h1><hr><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>下拉刷新和上拉加载这两种交互方式通常出现在移动端中</p><p>本质上等同于PC网页中的分页，只是交互形式不同</p><p>开源社区也有很多优秀的解决方案，如<code>iscroll</code>、<code>better-scroll</code>、<code>pulltorefresh.js</code>库等等</p><p>这些第三方库使用起来非常便捷</p><p>我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>上拉加载及下拉刷新都依赖于用户交互</p><p>最重要的是要理解在什么场景，什么时机下触发交互动作</p><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>首先可以看一张图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210819203252.png"></p><p>上拉加载的本质是页面触底，或者快要触底时的动作</p><p>判断页面触底我们需要先了解一下下面几个属性</p><ul><li><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</li><li><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</li><li><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</li></ul><p>综上我们得出一个触底公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollTop + clientHeight &gt;= scrollHeight</span><br></pre></td></tr></table></figure><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clientHeight  = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">//浏览器高度</span></span><br><span class="line"><span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line"><span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">50</span>;  <span class="comment">//距离视窗还用50的时候，开始触发；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始加载数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p><p>关于下拉刷新的原生实现，主要分成三步：</p><ul><li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li><li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li><li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li></ul><p>举个例子：</p><p><code>Html</code>结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refreshText&quot;</span>&gt;</span>&lt;/p &gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;refreshContainer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>555<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ...</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>监听<code>touchstart</code>事件，记录初始的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refreshContainer&#x27;</span>),</span><br><span class="line">    _refreshText = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.refreshText&#x27;</span>),</span><br><span class="line">    _startPos = <span class="number">0</span>,  <span class="comment">// 初始的值</span></span><br><span class="line">    _transitionHeight = <span class="number">0</span>; <span class="comment">// 移动的距离</span></span><br><span class="line"></span><br><span class="line">_element.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    _startPos = e.touches[<span class="number">0</span>].pageY; <span class="comment">// 记录初始位置</span></span><br><span class="line">    _element.style.position = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">    _element.style.transition = <span class="string">&#x27;transform 0s&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>监听<code>touchmove</code>移动事件，记录滑动差值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_element.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// e.touches[0].pageY 当前位置</span></span><br><span class="line">    _transitionHeight = e.touches[<span class="number">0</span>].pageY - _startPos; <span class="comment">// 记录差值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">0</span> &amp;&amp; _transitionHeight &lt; <span class="number">60</span>) &#123; </span><br><span class="line">        _refreshText.innerText = <span class="string">&#x27;下拉刷新&#x27;</span>; </span><br><span class="line">        _element.style.transform = <span class="string">&#x27;translateY(&#x27;</span>+_transitionHeight+<span class="string">&#x27;px)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">55</span>) &#123;</span><br><span class="line">            _refreshText.innerText = <span class="string">&#x27;释放更新&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>最后，就是监听<code>touchend</code>离开的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_element.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    _element.style.transition = <span class="string">&#x27;transform 0.5s ease 1s&#x27;</span>;</span><br><span class="line">    _element.style.transform = <span class="string">&#x27;translateY(0px)&#x27;</span>;</span><br><span class="line">    _refreshText.innerText = <span class="string">&#x27;更新中...&#x27;</span>;</span><br><span class="line">    <span class="comment">// todo...</span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p><ul><li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</li><li>下拉到一定值时，显示松手释放后的操作提示</li><li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</li></ul><h3 id="触底刷新"><a href="#触底刷新" class="headerlink" title="触底刷新"></a>触底刷新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">containerHeight</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">innerHeight</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">scrollBottom</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.innerHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">        <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">        <span class="comment">// console.log(&quot;触发&quot;,scrollTop,this.containerHeight,this.innerHeight)</span></span><br><span class="line">        <span class="keyword">if</span> (scrollTop + <span class="built_in">this</span>.containerHeight &gt;= <span class="built_in">this</span>.innerHeight - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;触底了&#x27;);</span></span><br><span class="line">            <span class="built_in">this</span>.heightListInit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.containerHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="built_in">this</span>.innerHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="built_in">this</span>.scrollBottom);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下拉刷新-触底刷新&quot;&gt;&lt;a href=&quot;#下拉刷新-触底刷新&quot; class=&quot;headerlink&quot; title=&quot;下拉刷新 触底刷新&quot;&gt;&lt;/a&gt;下拉刷新 触底刷新&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>声网视频和音频的学习</title>
    <link href="https://andylinwenqin.github.io/2021/08/09/%E5%A3%B0%E7%BD%91%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://andylinwenqin.github.io/2021/08/09/%E5%A3%B0%E7%BD%91%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-09T15:20:23.000Z</published>
    <updated>2021-08-09T16:23:08.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="声网"><a href="#声网" class="headerlink" title="声网"></a><a href="https://www.agora.io/cn">声网</a></h1><hr><h2 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h2><p>Agora 互动直播（Interactive Live Streaming Premium）可以实现一对多，多对多的音视频互动直播。</p><p>Agora 互动直播不同于视频通话。视频通话不区分主播和观众，所有用户都可以发言并看见彼此；互动直播的用户分为主播和观众，只有主播可以自由发言，且被其他用户看见。详见<a href="https://docs.agora.io/cn/faq/profile_difference">通信和直播场景有什么区别</a>。</p><h2 id="加入和离开频道"><a href="#加入和离开频道" class="headerlink" title="加入和离开频道"></a>加入和离开频道</h2><p>Agora Web SDK 使用 [AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象来管理一个本地用户在目标频道内的行为。在加入目标频道之前，你需要先创建一个 <code>AgoraRTCClient</code> 对象。</p><h3 id="创建-AgoraRTCClient-对象"><a href="#创建-AgoraRTCClient-对象" class="headerlink" title="创建 AgoraRTCClient 对象"></a>创建 AgoraRTCClient 对象</h3><p>调用 [AgoraRTC.createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 即可创建 <code>AgoraRTCClient</code> 对象。在创建 <code>AgoraRTCClient</code> 时，你需要指定使用的编码格式（<code>codec</code>）以及频道场景（<code>mode</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = AgoraRTC.createClient(&#123;</span><br><span class="line">  <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="选择视频编码格式"><a href="#选择视频编码格式" class="headerlink" title="选择视频编码格式"></a>选择视频编码格式</h3><p><code>codec</code> 设置支持 <code>&quot;vp8&quot;</code>（VP8）和 <code>&quot;h264&quot;</code>（H.264）两种视频编码格式。该设置只会影响发布端的视频编码格式，对于订阅端来说只要其支持该格式的解码，都能正常完成订阅。</p><p>举例来说，桌面端 Chrome 58 及以上版本既支持 VP8 也支持 H.264，而 Safari 12.1 以下版本不支持 VP8 编解码；如果频道中有两个主播分别发布了 VP8 和 H.264 的视频流，使用桌面端 Chrome 58 的观众可以解码这两个主播的视频，使用 Safari 12.1 以下版本浏览器的观众只能解码 H.264 的视频流。</p><p>不同浏览器和不同设备对这两种编解码格式支持都不同。下表列出不同浏览器所支持的编解码格式作为参考：</p><table><thead><tr><th align="left">浏览器</th><th align="left">VP8</th><th align="left">H.264</th></tr></thead><tbody><tr><td align="left">桌面端 Chrome 58+</td><td align="left">✔</td><td align="left">✔</td></tr><tr><td align="left">Firefox 56+</td><td align="left">✔</td><td align="left">✔*</td></tr><tr><td align="left">Safari 12.1+</td><td align="left">✔</td><td align="left">✔</td></tr><tr><td align="left">Safari &lt; 12.1</td><td align="left">✘</td><td align="left">✔</td></tr><tr><td align="left">Android Chrome 58+</td><td align="left">✔</td><td align="left">?*</td></tr></tbody></table><h3 id="选择频道场景"><a href="#选择频道场景" class="headerlink" title="选择频道场景"></a>选择频道场景</h3><p>频道场景（<code>mode</code>）是 Agora 为了对不同的实时音视频场景进行针对性算法优化而提供的一种设置选项。SDK 支持两种频道场景：<code>&quot;rtc&quot;</code>（通信场景） 和 <code>&quot;live&quot;</code>（直播场景）。</p><p><strong>通信场景</strong></p><p><code>&quot;rtc&quot;</code>（通信场景）适用于频道内所有用户需要相互交流且用户总数不太多的场景，如多人会议和在线聊天。</p><p><strong>直播场景</strong></p><p><code>&quot;live&quot;</code>（直播场景）适用于发布端很少但是订阅端很多的场景，这种场景下 SDK 定义了两种用户角色：观众（默认）和主播。主播能够发送和接收音视频，观众不能发送、只能接收音视频。你可以通过设置 <code>createClient</code> 的 [role](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/clientconfig.html#role) 参数来指定用户角色，也可以调用 [setClientRole](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#setclientrole) 来动态修改用户角色。</p><h3 id="加入频道"><a href="#加入频道" class="headerlink" title="加入频道"></a>加入频道</h3><p>创建 <code>AgoraRTCClient</code> 对象后，就可以调用 [AgoraRTCClient.join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 加入频道。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>注意 <code>join</code> 方法的第四个参数 <code>uid</code> 的设置。不传入任何值时，Agora 会为这个加入的本地用户自动分配一个 Number 型的用户 ID 作为其唯一的身份标识。你也可以通过该参数自行指定一个 Number 型的用户 ID。</p><p>请确保频道内用户 ID 的唯一性。Agora 建议你在业务层面避免用户使用相同的 ID 加入一个频道。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动分配数字 UID</span></span><br><span class="line"><span class="keyword">const</span> uid = <span class="keyword">await</span> client.join(<span class="string">&quot;APPID&quot;</span>, <span class="string">&quot;CHANNEL&quot;</span>, <span class="string">&quot;TOKEN&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数字 UID</span></span><br><span class="line"><span class="keyword">await</span> client.join(<span class="string">&quot;APPID&quot;</span>, <span class="string">&quot;CHANNEL&quot;</span>, <span class="string">&quot;TOKEN&quot;</span>, <span class="number">393939</span>);</span><br></pre></td></tr></table></figure><h3 id="离开频道"><a href="#离开频道" class="headerlink" title="离开频道"></a>离开频道</h3><p>调用 [AgoraRTCClient.leave](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave) 可以离开当前频道。该方法可以在任何时候调用，包括正在加入频道时或者正在重连时。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>调用 <code>leave</code> 后，SDK 会立刻销毁与当前频道相关的对象，包括订阅的远端用户对象、远端轨道对象、记录连接状态的对象等。如果需要再次加入频道，在调用 <code>leave</code> 后再调用 <code>join</code> 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> client.leave();</span><br></pre></td></tr></table></figure><h3 id="频道内的连接状态"><a href="#频道内的连接状态" class="headerlink" title="频道内的连接状态"></a>频道内的连接状态</h3><p>详见[频道连接状态管理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/channel_connection_web_ng?platform=Web)。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在加入频道的过程中，因为 SDK 使用不当或者网络异常等原因，可能会抛出以下错误：</p><ul><li><code>INVALID_PARAMS</code>: 提供的参数错误，比如提供了格式非法的 Token。</li><li><code>INVALID_OPERATION</code>: 非法操作。该错误通常是重复加入频道引起的，请确保重复加入时先调用 <code>leave</code>。</li><li><code>OPERATION_ABORTED</code>: 加入被中止，表示在 <code>join</code> 方法成功之前就调用了 <code>leave</code> 方法。</li><li><code>UNEXPECTED_RESPONSE</code>: Agora 服务器返回了非预期的响应，通常是因为 App ID 或 Token 鉴权失败，例如开启了 App 证书却未传入 Token。</li><li><code>UID_CONFLICT</code>: 创建了多个 <code>AgoraRTCClient</code> 对象，且重复使用了同一个用户 ID。</li></ul><h2 id="创建本地轨道对象"><a href="#创建本地轨道对象" class="headerlink" title="创建本地轨道对象"></a>创建本地轨道对象</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。</p><p>本文详细介绍如何使用 Agora Web SDK 创建本地的音视频轨道对象。</p><p>在介绍具体的 API 之前，你需要了解本地轨道对象的一些设计细节。Agora Web SDK 使用了面向对象的设计模式，使用 [LocalTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html) 这一个基础的抽象类来描述所有的本地轨道对象，它定义了本地轨道对象的公共方法和行为，所有的本地轨道对象都继承于 <code>LocalTrack</code>。</p><p><code>publish</code> 方法只要求发布的对象是 <code>LocalTrack</code> ，所以无论通过什么方式创建的本地轨道对象，都满足 <code>publish</code> 方法的参数要求。</p><p>基于 <code>LocalTrack</code>，SDK 定义了 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 和 [LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html)，分别代表本地音频轨道对象和本地视频轨道对象。这两个类分别针对音视频不同的特性增加了不同的方法，比如 <code>LocalAudioTrack</code> 增加了获取和控制音量的方法、<code>LocalVideoTrack</code> 增加了设置美颜功能的方法。</p><p>最后，根据不同的应用场景和创建方式， SDK 基于 <code>LocalAudioTrack</code> 和 <code>LocalVideoTrack</code> 提供了更上层的本地轨道类。比如继承自 <code>LocalVideoTrack</code> 的 <code>CameraVideoTrack</code>，这个类表明这个本地视频轨道是来自于摄像头采集的视频，所以这个类增加了控制摄像头、调整分辨率等方法。</p><p>下图展示了这几个类之间的关系：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210809235859.png"></p><h3 id="创建轨道"><a href="#创建轨道" class="headerlink" title="创建轨道"></a>创建轨道</h3><p>SDK 支持通过以下方式创建本地轨道对象。</p><h3 id="使用麦克风和摄像头"><a href="#使用麦克风和摄像头" class="headerlink" title="使用麦克风和摄像头"></a>使用麦克风和摄像头</h3><p>最常用的方法是直接通过麦克风或者摄像头采集的音视频来创建本地轨道对象，SDK 提供了三种方法：</p><ul><li>[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)：使用摄像头采集的视频来创建本地视频轨道，返回一个 [CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 对象。</li><li>[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)：使用麦克风采集的音频来创建本地音频轨道，返回一个 [MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 对象。</li><li>[createMicrophoneAndCameraTracks](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks)：同时使用麦克风和摄像头采集的音视频创建本地轨道，返回一个包含 [CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 和 [MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 的列表。</li></ul><p>如果使用 <code>createMicrophoneAndCameraTracks</code> 创建本地轨道，因为音频和视频采集是一次完成的，所以只要摄像头和麦克风其中一个无法完成采集就会导致整个采集的失败，SDK 会抛出错误，详见[错误处理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/create_local_track_web_ng?platform=Web#error)。如果分别调用 <code>createCameraVideoTrack</code> 和 <code>createMicrophoneAudioTrack</code> ，其中一个采集失败不会影响另外一个。请根据你的实际需求选用合适的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采集摄像头</span></span><br><span class="line"><span class="keyword">const</span> cameraTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采集麦克风</span></span><br><span class="line"><span class="keyword">const</span> microphoneTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时采集摄像头和麦克风</span></span><br><span class="line"><span class="keyword">const</span> [microphoneTrack, cameraTrack] = <span class="keyword">await</span> AgoraRTC.createMicrophoneAndCameraTracks();</span><br></pre></td></tr></table></figure><p>调用以上方法时你可以传入一个配置参数来控制采集的行为，详细的参数定义可以参考 [CameraVideoTrackInitConfig](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/cameravideotrackinitconfig.html) 或者 [MicrophoneAudioTrackInitConfig](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/microphoneaudiotrackinitconfig.html)。</p><p>以上方法均为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><h3 id="使用屏幕画面"><a href="#使用屏幕画面" class="headerlink" title="使用屏幕画面"></a>使用屏幕画面</h3><p>SDK 提供 [createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 方法来创建屏幕共享轨道，这个方法会返回 <code>LocalVideoTrack</code> 对象。由于 <code>LocalVideoTrack</code> 只实现了视频轨道对象的基础方法，因此通过屏幕创建的轨道无法像摄像头轨道那样控制分辨率或切换设备。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> screenTrack = <span class="keyword">await</span> AgoraRTC.createScreenVideoTrack();</span><br></pre></td></tr></table></figure><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>如果你需要在 Electron 或较老版本的 Chrome 上使用屏幕共享，或者希望在共享屏幕的同时分享音频，可以参考[屏幕共享](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/screensharing_web_ng)。</p><h3 id="使用本地或在线的音频文件"><a href="#使用本地或在线的音频文件" class="headerlink" title="使用本地或在线的音频文件"></a>使用本地或在线的音频文件</h3><p>SDK 提供 [createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 方法来通过本地或者在线的音频文件创建本地音频轨道对象。通过该方法创建的对象类型为 <code>BufferSourceAudioTrack</code>，该对象继承自 <code>LocalAudioTrack</code>，在其基础上增加了控制音频文件播放行为的方法，比如暂停播放、跳转播放、循环播放等。</p><p>你可以使用这个方法实现混音或者播放音效的功能，详见[播放音效/混音](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/audio_effect_mixing_web_ng)。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioFileTrack = <span class="keyword">await</span> AgoraRTC.createBufferSourceAudioTrack(&#123;</span><br><span class="line">  <span class="attr">source</span>: <span class="string">&quot;https://web-demos-static.agora.io/agora/smlt.flac&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在播放之前先调用该方法读取音频文件</span></span><br><span class="line">audioFileTrack.startProcessAudioBuffer();</span><br><span class="line"></span><br><span class="line">audioFileTrack.play();</span><br></pre></td></tr></table></figure><h3 id="使用自定义方式"><a href="#使用自定义方式" class="headerlink" title="使用自定义方式"></a>使用自定义方式</h3><p>如果你熟悉 WebRTC 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack">MediaStreamTrack</a> 相关的 API，你可以通过自己实现采集来完成 <code>MediaStreamTrack</code> 的创建，然后通过 [createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 或者 [createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 方法将 <code>MediaStreamTrack</code> 对象转换成 SDK 内部的 <code>LocalAudioTrack</code> 或者 <code>LocalVideoTrack</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过自己实现采集获取 `MediaStreamTrack` 对象</span></span><br><span class="line"><span class="keyword">const</span> customMediaStreamTrack = getMediaStreamTrackFromXXX(<span class="comment">/* .. */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义的视频轨道</span></span><br><span class="line"><span class="keyword">const</span> customTrack = AgoraRTC.createCustomVideoTrack(&#123;</span><br><span class="line">  <span class="attr">mediaStreamTrack</span>: customMediaStreamTrack,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="启用和禁用本地轨道"><a href="#启用和禁用本地轨道" class="headerlink" title="启用和禁用本地轨道"></a>启用和禁用本地轨道</h3><p>创建好本地的轨道对象后，如果想要暂时关闭麦克风或摄像头，你可以禁用该轨道。SDK 提供 [LocalTrack.setEnabled](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 方法来启用或者禁用本地轨道对象。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>调用 <code>setEnabled(true)</code> 禁用本地轨道后，该轨道会停止本地播放。如果该轨道已经发布，发布也会停止，此时远端会收到 <code>user-unpublished</code> 回调；调用 <code>setEnabled(true)</code> 后，SDK 会自动重新发布轨道。</p><p>根据本地轨道类型的不同，调用 <code>setEnabled</code> 后会有一些不同的行为：</p><ul><li>通过设备采集创建的本地轨道（<code>CameraVideoTrack</code>/<code>MicrophoneAudioTrack</code>）：当调用 <code>setEnabled(false)</code> 后，会停止采集并释放其占用的设备。如果摄像头或麦克风有指示灯，此时指示灯会熄灭。当调用 <code>setEnabled(true)</code> 后，会自动恢复采集。</li><li>通过其他方式创建的本地轨道：当调用 <code>setEnabled(false)</code> 后，会默认编码黑屏帧（视频轨道）或者静音包（音频轨道）。当调用 <code>setEnabled(true)</code> 后，会自动恢复正常编码。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> videoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时关闭摄像头采集</span></span><br><span class="line"><span class="keyword">await</span> videoTrack.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复摄像头采集</span></span><br><span class="line"><span class="keyword">await</span> videoTrack.setEnabled(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>在创建本地音视频对象的过程中，由于不同设备和浏览器之间的差异，SDK 可能在调用上述方法时抛出异常。以下是调用创建轨道的方法时可能会遇到的错误：</p><ul><li><code>NOT_SUPPORTED</code>: 使用的功能在当前浏览器上不支持。</li><li><code>MEDIA_OPTION_INVALID</code>: 指定的采集参数无法被满足，一般是因为设备不支持指定的分辨率或帧率。</li><li><code>DEVICE_NOT_FOUND</code>: 找不到指定的采集设备。</li><li><code>PERMISSION_DENIED</code>: 用户拒绝授予访问摄像头/麦克风的权限，或者屏幕共享选择共享源时，用户没有选择共享源，并关闭了选择窗口。</li><li><code>CONSTRAINT_NOT_SATISFIED</code>: 浏览器不支持指定的采集选项。</li><li><code>SHARE_AUDIO_NOT_ALLOWED</code>: 屏幕共享分享音频时用户没有勾选<strong>分享音频</strong>。</li></ul><h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。</p><p>本文详细介绍如何使用 Agora Web SDK 发布和取消发布本地音视频，以及订阅和取消订阅远端音视频。</p><h3 id="发布音视频"><a href="#发布音视频" class="headerlink" title="发布音视频"></a>发布音视频</h3><p>完成本地轨道的创建并且成功加入频道后，就可以调用 [AgoraRTCClient.publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish) 将本地的音视频数据发布到当前频道，以供频道中的其他用户订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localAudioTrack = ...;</span><br><span class="line"><span class="keyword">const</span> localVideoTrack = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以多次调用 publish 发布多个轨道</span></span><br><span class="line"><span class="keyword">await</span> client.publish(localAudioTrack);</span><br><span class="line"><span class="keyword">await</span> client.publish(localVideoTrack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次性将需要发布的轨道一起发布</span></span><br><span class="line"><span class="keyword">await</span> client.publish([localAudioTrack, localVideoTrack]);</span><br></pre></td></tr></table></figure><p>关于发布，注意事项如下：</p><ul><li><p>同一时间只能发布一个视频轨道。</p></li><li><p>可以同时发布多个音频轨道，SDK 会自动混音。</p><blockquote><p>Safari 12 之前的版本不支持混音，无法使用此特性。</p></blockquote></li><li><p>可以多次调用该方法来发布不同的轨道，但是不能重复发布同一个轨道对象。</p></li><li><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p></li></ul><h3 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h3><p>在发布过程中，可能因为网络环境或者 SDK 使用不当抛出以下错误：</p><ul><li><code>INVALID_OPERATION</code>: 非法操作，说明在加入频道成功之前就调用了 <code>publish</code> 方法。</li><li><code>OPERATION_ABORTED</code>: 发布被中止，可能是因为在发布成功之前就主动调用 <code>leave</code> 离开了频道。</li><li><code>INVALID_LOCAL_TRACK</code>: 参数错误，传入了非法的 <code>LocalTrack</code> 对象。</li><li><code>CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS</code>: 不允许同时发布多个视频轨道。</li><li><code>NOT_SUPPORTED</code>: 发布了多个音频轨道，但是浏览器不支持混音。</li><li><code>UNEXPECTED_RESPONSE</code>: 收到了 Agora 服务器异常的返回，发布轨道失败。建议保留日志，联系 Agora <a href="https://agora-ticket.agora.io/">技术支持</a>。</li><li><code>NO_ICE_CANDIDATE</code>: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 <a href="https://docs.agora.io/cn/faq/console_error_web#none-ice-candidate-not-alloweda-namecandidatea">FAQ</a>。</li></ul><h3 id="取消发布音视频"><a href="#取消发布音视频" class="headerlink" title="取消发布音视频"></a>取消发布音视频</h3><p>成功发布本地轨道后，如果想取消发布，可以调用 [AgoraRTCClient.unpublish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布音视频</span></span><br><span class="line"><span class="keyword">await</span> client.publish([localAudioTrack, localVideoTrack]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消发布视频，此时音频还在正常发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish(localVideoTrack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次将所有正在发布的轨道全部取消发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish();</span><br><span class="line"><span class="comment">// 或者批量取消发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish([localAudioTrack, localVideoTrack]);</span><br></pre></td></tr></table></figure><p>关于取消发布，注意事项如下：</p><ul><li>该方法可以多次调用。你可以使用 <code>publish</code> 和 <code>unpublish</code> 实现发布和取消发布某个本地轨道。</li><li>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</li></ul><h3 id="订阅音视频"><a href="#订阅音视频" class="headerlink" title="订阅音视频"></a>订阅音视频</h3><p>当远端用户成功发布音视频轨道之后，SDK 会触发 [user-published](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件。这个事件携带两个参数：远端用户对象（<code>user</code>）和远端发布的媒体类型（<code>mediaType</code>）。此时，你可以调用 [AgoraRTCClient.subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 发起订阅。</p><blockquote><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或者 <code>async/await</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 发起订阅</span></span><br><span class="line">  <span class="keyword">await</span> client.subscribe(user, mediaType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果订阅的是音频轨道</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> audioTrack = user.audioTrack;</span><br><span class="line">    <span class="comment">// 自动播放音频</span></span><br><span class="line">    audioTrack.play();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> videoTrack = user.videoTrack;</span><br><span class="line">    <span class="comment">// 自动播放视频</span></span><br><span class="line">    videoTrack.play(DOM_ELEMENT);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当订阅方法调用完成之后，你可以通过 <code>user.audioTrack</code> 和 <code>user.videoTrack</code> 获取相应的 [RemoteAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 和 [RemoteVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。</p><p>订阅和发布不同，每次订阅只能订阅一个音频或视频轨道。即使发布端同时发布了音频轨道和视频轨道，SDK 也会触发两次 <code>user-published</code> 事件：一次 <code>user-published(audio)</code>，一次 <code>user-published(video)</code>。按照上面的代码逻辑，会完成两次订阅。</p><h3 id="处理-Autoplay-问题"><a href="#处理-Autoplay-问题" class="headerlink" title="处理 Autoplay 问题"></a>处理 Autoplay 问题</h3><p>详见[处理浏览器的自动播放策略](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/autoplay_policy_web_ng)。</p><h3 id="错误处理-3"><a href="#错误处理-3" class="headerlink" title="错误处理"></a>错误处理</h3><p>在订阅过程中，因为网络环境等因素 SDK 可能抛出如下错误：</p><ul><li><code>INVALID_OPERATION</code>: 非法操作，可能在加入频道成功之前就调用了 <code>subscribe</code>。</li><li><code>INVALID_REMOTE_USER</code>: 传入了非法的远端用户对象，例如该用户不在频道内。</li><li><code>REMOTE_USER_IS_NOT_PUBLISHED</code>：传入的远端用户没有发布 <code>subscribe</code> 方法中传入的媒体类型。</li><li><code>UNEXPECTED_RESPONSE</code>: 收到了 Agora 服务器异常的返回，订阅失败。建议保留日志，联系 Agora <a href="https://agora-ticket.agora.io/">技术支持</a>。</li><li><code>OPERATION_ABORTED</code>: 操作中止，可能在订阅成功之前就调用 <code>leave</code> 离开了频道。</li><li><code>NO_ICE_CANDIDATE</code>: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 <a href="https://docs.agora.io/cn/faq/console_error_web#none-ice-candidate-not-alloweda-namecandidatea">FAQ</a>。</li></ul><h3 id="取消订阅音视频"><a href="#取消订阅音视频" class="headerlink" title="取消订阅音视频"></a>取消订阅音视频</h3><p>你可以通过 [AgoraRTCClient.unsubscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe) 取消订阅远端的音视频。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅目标用户的音视频</span></span><br><span class="line"><span class="keyword">await</span> client.subscribe(user, <span class="string">&quot;audio&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> client.subscribe(user, <span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅视频</span></span><br><span class="line"><span class="keyword">await</span> client.unsubscribe(user, <span class="string">&quot;video&quot;</span>);</span><br><span class="line"><span class="comment">// 也可以取消订阅当前用户的所有媒体类型</span></span><br><span class="line"><span class="keyword">await</span> client.unsubscribe(user);</span><br></pre></td></tr></table></figure><p>关于取消订阅，注意事项如下：</p><ul><li>取消订阅成功后，SDK 会释放相应的 <code>RemoteTrack</code> 对象。一旦远端轨道对象被释放，SDK 会自动移除视频的播放元素，音频播放也会停止。</li><li>如果远端用户主动取消发布，本地会收到 <code>user-unpublished</code> 回调，收到该回调时 SDK 会自动释放相应的 <code>RemoteTrack</code> 对象，你无需再调用 <code>unsubscribe</code>。</li><li>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</li></ul><h2 id="api文档参考"><a href="#api文档参考" class="headerlink" title="api文档参考"></a>api文档参考</h2><p>Agora Web SDK 是通过 HTML 网页加载的 JavaScript 和 Typescript 库。你可以使用 Agora Web SDK 在网页浏览器中调用 API 建立连接，控制音视频通话和直播服务。</p><blockquote><p>请务必使用 HTTPS 协议或者 localhost，否则 SDK 无法正常工作。</p></blockquote><p>[全局模块](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#全局模块)</p><p>[AgoraRTC](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html) 是 Agora Web SDK 中所有可调用方法的入口，主要包含以下方法。</p><p>[核心方法](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#核心方法)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient)</td><td align="left">创建本地客户端</td></tr></tbody></table><p>[本地音视频采集](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地音视频采集)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)</td><td align="left">通过麦克风创建一个音频轨道对象</td></tr><tr><td align="left">[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)</td><td align="left">通过摄像头创建一个视频轨道对象</td></tr><tr><td align="left">[createMicrophoneAndCameraTracks](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks)</td><td align="left">同时创建麦克风音频轨道和摄像头视频轨道</td></tr><tr><td align="left">[createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack)</td><td align="left">通过屏幕共享创建一个视频轨道对象</td></tr><tr><td align="left">[createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack)</td><td align="left">通过音频文件创建一个音频轨道对象</td></tr><tr><td align="left">[createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack)</td><td align="left">创建一个自定义的音频轨道对象</td></tr><tr><td align="left">[createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack)</td><td align="left">创建一个自定义的视频轨道对象</td></tr></tbody></table><p>[媒体设备查询](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#媒体设备查询)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[getDevices](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getdevices)</td><td align="left">获取媒体设备列表</td></tr><tr><td align="left">[getCameras](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getcameras)</td><td align="left">获取摄像头列表</td></tr><tr><td align="left">[getMicrophones](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getmicrophones)</td><td align="left">获取麦克风列表</td></tr><tr><td align="left">[getPlaybackDevices](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getplaybackdevices)</td><td align="left">获取音频播放设备列表</td></tr><tr><td align="left">[getElectronScreenSources](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getelectronscreensources)</td><td align="left">获取 Electron 屏幕共享源列表</td></tr></tbody></table><p>[日志管理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#日志管理)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[enableLogUpload](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#enablelogupload)</td><td align="left">打开日志上传功能</td></tr><tr><td align="left">[disableLogUpload](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#disablelogupload)</td><td align="left">关闭日志上传功能</td></tr><tr><td align="left">[setLogLevel](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#setloglevel)</td><td align="left">设置日志等级</td></tr></tbody></table><p>[全局事件回调](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#全局事件回调)</p><table><thead><tr><th align="left">回调</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[onCameraChanged](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#oncamerachanged)</td><td align="left">视频采集设备状态变化回调</td></tr><tr><td align="left">[onMicrophoneChanged](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onmicrophonechanged)</td><td align="left">音频采集设备状态变化回调</td></tr><tr><td align="left">[onAudioAutoplayFailed](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onaudioautoplayfailed)</td><td align="left">音频轨道自动播放失败回调</td></tr></tbody></table><p>[其他](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#其他)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[checkSystemRequirements](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#checksystemrequirements)</td><td align="left">检测浏览器兼容性</td></tr><tr><td align="left">[getSupportedCodec](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getsupportedcodec)</td><td align="left">获取支持的编码格式</td></tr><tr><td align="left">[createChannelMediaRelayConfiguration](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createchannelmediarelayconfiguration)</td><td align="left">创建跨频道媒体流转发的配置对象</td></tr></tbody></table><h3 id="AgoraRTCClient-类"><a href="#AgoraRTCClient-类" class="headerlink" title="AgoraRTCClient 类"></a>AgoraRTCClient 类</h3><p>调用 [createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 创建一个本地客户端对象 [AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html)，代表一个通话中的本地用户。<code>AgoraRTCClient</code> 类提供音视频通话的核心功能，主要包含以下方法。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join)</td><td align="left">加入频道</td></tr><tr><td align="left">[leave](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave)</td><td align="left">离开频道</td></tr><tr><td align="left">[publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish)</td><td align="left">发布本地音视频轨道</td></tr><tr><td align="left">[unpublish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish)</td><td align="left">取消发布本地音视频轨道</td></tr><tr><td align="left">[subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe)</td><td align="left">订阅远端用户的音视频轨道</td></tr><tr><td align="left">[unsubscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe)</td><td align="left">取消订阅远端用户的音视频轨道</td></tr></tbody></table><h3 id="LocalTrack-类"><a href="#LocalTrack-类" class="headerlink" title="LocalTrack 类"></a>LocalTrack 类</h3><p><code>LocalTrack</code> 是 Agora Web SDK 中定义本地音视频轨道的抽象类，可用于本地播放和发布。</p><p>SDK 通过不同的方式创建不同的 <code>LocalTrack</code>，返回不同的 <code>LocalTrack</code> 派生类对象。以下列举了所有的 <code>LocalTrack</code> 派生类以及所对应的创建方式。</p><p>[本地音频轨道](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地音频轨道)</p><p>根据创建方式的不同，本地音频轨道可分为以下三种。其中 <code>LocalAudioTrack</code> 派生自 <code>LocalTrack</code>，<code>MicrophoneAudioTrack</code> 和 <code>BufferSourceAudioTrack</code> 派生自 <code>LocalAudioTrack</code>。</p><table><thead><tr><th align="left">本地音频轨道</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html)</td><td align="left">最基础的本地音频轨道对象，包含了基础的本地音频控制，如播放、设置音量控制。 通过调用 [AgoraRTC.createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 创建。</td></tr><tr><td align="left">[MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html)</td><td align="left">本地麦克风音频轨道对象，比 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制麦克风的方法。 通过调用 [AgoraRTC.createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack) 创建。</td></tr><tr><td align="left">[BufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ibuffersourceaudiotrack.html)</td><td align="left">通过读取音频数据源创建的本地音频轨道，比基础的 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制音频数据源的方法。 通过调用 [AgoraRTC.createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 创建。</td></tr></tbody></table><p>[本地视频轨道](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地视频轨道)</p><p>根据创建方式的不同，本地视频可分为以下两种。其中 <code>LocalVideoTrack</code> 派生自 <code>LocalTrack</code>，<code>CameraVideoTrack</code> 派生自 <code>LocalVideoTrack</code>。</p><table><thead><tr><th align="left">本地视频轨道</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html)</td><td align="left">最基础的本地视频轨道对象，包含了基础的本地视频控制，如播放、美颜。 通过调用 [AgoraRTC.createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 或 [AgoraRTC.createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 创建。</td></tr><tr><td align="left">[CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html)</td><td align="left">本地摄像头视频轨道对象，比 [LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html) 多一些控制摄像头和编码参数的方法。 通过调用 [AgoraRTC.createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack) 创建。</td></tr></tbody></table><h3 id="RemoteTrack-类"><a href="#RemoteTrack-类" class="headerlink" title="RemoteTrack 类"></a>RemoteTrack 类</h3><p><code>RemoteTrack</code> 是 Agora Web SDK 中用于定义远端音视频轨道的抽象类。</p><p>在实际操作中，你需要先调用 [AgoraRTCClient.subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 订阅远端用户，然后从远端用户对象 [AgoraRTCRemoteUser](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcremoteuser.html) 中获取派生自 <code>RemoteTrack</code> 的 [RemoteAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 对象和 [RemoteVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。</p><p>[引入方式](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#引入方式)</p><p>如果你通过 <code>&lt;script&gt;</code> 的方式引入 Agora Web SDK，可以通过访问 [AgoraRTC.createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 来获取导出的模块。</p><p>如果你通过 <code>npm</code> 或者模块化的方式引入 Agora Web SDK，可以通过以下方式访问 <code>AgoraRTC</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(AgoraRTC.createClient);</span><br></pre></td></tr></table></figure><p>[类型模块（适用于 Typescript）](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#类型模块（适用于-typescript）)</p><p>对于 Typescript 开发者，我们提供了 <code>.d.ts</code> 文件导出详细的类型定义。你可以查看 API 文档的 [Global](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/globals.html) 页面，该页面列出了所有 SDK 导出的模块和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC, &#123; IAgoraRTCClient &#125; <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client: IAgoraRTCClient = AgoraRTC.createClient();</span><br></pre></td></tr></table></figure><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>SDK 可能以下列方式抛出错误码：</p><ul><li>对于异步方法，SDK 返回 Promise 来通知异步操作的结果，Promise 被 reject 时 SDK 会抛出相应的错误码。</li><li>同步方法调用失败时，SDK 直接抛出错误码。</li><li>SDK 内部运行过程中，也可能抛出一些网络相关的错误码。</li></ul><p>你可参考本文了解这些错误码的详细含义及处理方法。</p><p>[通用错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#通用错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>UNEXPECTED_ERROR</code></td><td align="left">无法处理的、非预期的错误，通常这个错误会有具体的错误提示。</td><td align="left">无</td></tr><tr><td align="left"><code>UNEXPECTED_RESPONSE</code></td><td align="left">服务端返回了非预期的响应。</td><td align="left">无</td></tr><tr><td align="left"><code>INVALID_PARAMS</code></td><td align="left">非法参数。</td><td align="left">根据具体提示确认操作，并根据文档传入正确的参数。</td></tr><tr><td align="left"><code>NOT_SUPPORTED</code></td><td align="left">浏览器不支持。</td><td align="left">参考<a href="https://agoraio-community.github.io/AgoraWebSDK-NG/docs/zh-CN/overview">浏览器支持情况</a>。</td></tr><tr><td align="left"><code>INVALID_OPERATION</code></td><td align="left">非法操作，通常是因为在当前状态不能进行该操作。</td><td align="left">确认操作的先后顺序，比如发布前请确认已经加入频道。</td></tr><tr><td align="left"><code>OPERATION_ABORTED</code></td><td align="left">操作中止，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。</td><td align="left">通过 [AgoraRTCClient.on(“user-joined”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。</td></tr><tr><td align="left"><code>WEB_SECURITY_RESTRICT</code></td><td align="left">浏览器安全策略限制。</td><td align="left">请确保 Web 页面运行在<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">安全环境</a>中。</td></tr><tr><td align="left"><code>NO_ACTIVE_STATUS</code></td><td align="left">Agora 项目未激活或被禁用。</td><td align="left">请前往 Agora 控制台确认项目状态是否为启用。</td></tr></tbody></table><p>[请求相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#请求相关错误码)</p><p><strong>网络连接</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>NETWORK_TIMEOUT</code></td><td align="left">请求超时，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。</td><td align="left">通过 [AgoraRTCClient.on(“user-joined”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。</td></tr><tr><td align="left"><code>NETWORK_RESPONSE_ERROR</code></td><td align="left">响应错误，一般是状态码非法。</td><td align="left">确认操作的参数是否正确，并根据文档传入正确的参数。</td></tr><tr><td align="left"><code>NETWORK_ERROR</code></td><td align="left">无法定位的网络错误。</td><td align="left">无</td></tr></tbody></table><p><strong>SDK 内部请求</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>WS_ABORT</code></td><td align="left">请求 Agora 服务器过程中 WebSocket 断开。</td><td align="left">监听 [AgoraRTCClient.on(“connection-state-change”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 <strong>CONNECTED</strong> 后重试。</td></tr><tr><td align="left"><code>WS_DISCONNECT</code></td><td align="left">请求 Agora 服务器前，WebSocket 就已经断开。</td><td align="left">监听 [AgoraRTCClient.on(“connection-state-change”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 <strong>CONNECTED</strong> 后重试。</td></tr><tr><td align="left"><code>WS_ERR</code></td><td align="left">WebSocket 连接发生错误。</td><td align="left">检查当前浏览器对 WebSocket 的支持情况。</td></tr></tbody></table><p>[设备管理相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#设备管理相关错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>ENUMERATE_DEVICES_FAILED</code></td><td align="left">枚举本地设备失败，一般是由于浏览器限制。</td><td align="left">无</td></tr><tr><td align="left"><code>DEVICE_NOT_FOUND</code></td><td align="left">无法找到指定设备。</td><td align="left">传入正确的设备 ID。</td></tr></tbody></table><p>[Track 相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#track-相关错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>TRACK_IS_DISABLED</code></td><td align="left">轨道被禁用，通常因为轨道设置了 [Track.setEnabled(false)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled)。</td><td align="left">对该轨道调用 [Track.setEnabled(true)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 后再进行操作。</td></tr><tr><td align="left"><code>SHARE_AUDIO_NOT_ALLOWED</code></td><td align="left">屏幕共享音频时终端用户没有点击<strong>分享音频</strong>。</td><td align="left">要求终端用户在弹出的屏幕共享窗口中勾选<strong>分享音频</strong>。</td></tr><tr><td align="left"><code>CHROME_PLUGIN_NO_RESPONSE</code></td><td align="left">Chrome 屏幕共享插件无响应。</td><td align="left">确认 [Chrome 屏幕共享插件](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/chrome_screensharing_plugin)的状态或重新安装屏幕共享插件。</td></tr><tr><td align="left"><code>CHROME_PLUGIN_NOT_INSTALL</code></td><td align="left">Chrome 屏幕共享插件没有安装。</td><td align="left">安装 [Chrome 屏幕共享插件](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/chrome_screensharing_plugin)。</td></tr><tr><td align="left"><code>MEDIA_OPTION_INVALID</code></td><td align="left">不支持的媒体采集的参数。</td><td align="left">修改媒体采集参数或使用 SDK 预设的配置。</td></tr><tr><td align="left"><code>CONSTRAINT_NOT_SATISFIED</code></td><td align="left">不支持的媒体采集的参数。</td><td align="left">修改媒体采集参数或使用 SDK 预设的配置。</td></tr><tr><td align="left"><code>PERMISSION_DENIED</code></td><td align="left">获取媒体设备权限被拒绝。</td><td align="left">在弹出的获取设备权限窗口中选择<strong>允许</strong>。</td></tr><tr><td align="left"><code>FETCH_AUDIO_FILE_FAILED</code></td><td align="left">下载在线音频文件失败。</td><td align="left">填入正确的在线音频地址，并确保可以正常访问。</td></tr><tr><td align="left"><code>READ_LOCAL_AUDIO_FILE_ERROR</code></td><td align="left">读取本地音频文件失败。</td><td align="left">填入正确的本地音频文件路径。</td></tr><tr><td align="left"><code>DECODE_AUDIO_FILE_FAILED</code></td><td align="left">音频文件解码失败，可能是因为音频文件的编码格式是浏览器 WebAudio 不支持的编码格式。</td><td align="left">检查浏览器 WebAudio 是否支持音频文件的编码格式。</td></tr></tbody></table><p>[Client 相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#client-相关错误码)</p><p><strong>加入频道</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>UID_CONFLICT</code></td><td align="left">同一个频道内 UID 重复。</td><td align="left">使用不同的 UID 进入频道。</td></tr><tr><td align="left"><code>INVALID_UINT_UID_FROM_STRING_UID</code></td><td align="left">String UID 分配服务返回了非法的 int UID。</td><td align="left">使用不同的 UID 进入频道。</td></tr><tr><td align="left"><code>CAN_NOT_GET_PROXY_SERVER</code></td><td align="left">无法获取云代理服务地址。</td><td align="left">无</td></tr><tr><td align="left"><code>CAN_NOT_GET_GATEWAY_SERVER</code></td><td align="left">无法获取 Agora 服务器地址。</td><td align="left">无</td></tr></tbody></table><p><strong>发布/取消发布</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>INVALID_LOCAL_TRACK</code></td><td align="left">传入了非法的 LocalTrack。</td><td align="left">检查传入的 Track，并传入正确的 LocalTrack。</td></tr><tr><td align="left"><code>CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS</code></td><td align="left">一个 Client 发布多个视频轨道。</td><td align="left">一个 Client 同一时间只能发布一个视频轨道，如果想发布多个视频轨道请创建多个 Client。</td></tr></tbody></table><p><strong>订阅/取消订阅</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>INVALID_REMOTE_USER</code></td><td align="left">非法的远端用户，可能是远端用户不在频道内或还未发布任何媒体轨道。</td><td align="left">收到 [AgoraRTCClient.on(“user-published”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件后再进行订阅操作。</td></tr><tr><td align="left"><code>REMOTE_USER_IS_NOT_PUBLISHED</code></td><td align="left">远端用户已发布了音频或视频轨道，但不是与你的订阅操作所指定的类型不符。</td><td align="left">请确保订阅操作传入的轨道类型需要与 [AgoraRTCClient.on(“user-published”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published)) 事件给出的类型一致，或者在订阅前通过 [AgoraRTCRemoteUser.hasVideo]{@link AgoraRTCRemoteUser.hasVideo} 和 [AgoraRTCRemoteUser.hasAudio]{@link AgoraRTCRemoteUser.hasAudio} 确认远端用户是否发布了该类型的轨道。</td></tr></tbody></table><p>[推流到 CDN](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#推流到-cdn)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>LIVE_STREAMING_TASK_CONFLICT</code></td><td align="left">推流任务已经存在。</td><td align="left">先调用 [Client.stopLiveStreaming](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#stoplivestreaming) 停止该推流任务再重新进行推流操作。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INVALID_ARGUMENT</code></td><td align="left">推流参数错误。</td><td align="left">参考 [Client.startLiveStreaming](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#startlivestreaming) 的 API 文档检查推流操作的参数。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INTERNAL_SERVER_ERROR</code></td><td align="left">推流服务器内部错误。</td><td align="left">重新进行推流操作，如果仍然失败，刷新页面重试。</td></tr><tr><td align="left"><code>LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED</code></td><td align="left">推流 URL 被占用。</td><td align="left">检查填入的 URL 是否被占用。</td></tr><tr><td align="left"><code>LIVE_STREAMING_CDN_ERROR</code></td><td align="left">推流的目标 CDN 出现错误导致推流失败。</td><td align="left">确认目标 CDN 的健康状况。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INVALID_RAW_STREAM</code></td><td align="left">推流超时。</td><td align="left">确认目标流是否存在。</td></tr></tbody></table><p>[跨频道连麦](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#跨频道连麦)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>CROSS_CHANNEL_WAIT_STATUS_ERROR</code></td><td align="left">等待 [AgoraRTCClient.on(“channel-media-relay-state”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_channel_media_relay_state) 回调出错。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_JOIN_SRC</code></td><td align="left">发起跨频道转发媒体流请求失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_JOIN_DEST</code></td><td align="left">接受跨频道转发媒体流请求失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST</code></td><td align="left">服务器接收跨频道转发媒体流失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_SERVER_ERROR_RESPONSE</code></td><td align="left">服务器响应出错。</td></tr></tbody></table><h2 id="官方实例"><a href="#官方实例" class="headerlink" title="官方实例"></a>官方实例</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。如果你使用的是 3.x 或之前版本，请查看以下文档：</p><p>[跑通视频直播示例项目](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_live_web?platform=Web)</p><p>[实现音频直播](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/start_live_audio_web?platform=Web)</p><p>[实现视频直播](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/start_live_web?platform=Web)</p><p>根据本文指导快速集成 Agora Web SDK 并在你自己的 app 里实现实时音视频直播。</p><blockquote><p>由于浏览器的安全策略对除 127.0.0.1 以外的 HTTP 地址作了限制，Agora Web SDK 仅支持 HTTPS 协议或者 <code>http://localhost</code>（<code>http://127.0.0.1</code>）。请勿使用 HTTP 协议在 <code>http://localhost</code>（<code>http://127.0.0.1</code>） 之外访问你的项目。</p></blockquote><h3 id="开源示例项目"><a href="#开源示例项目" class="headerlink" title="开源示例项目"></a>开源示例项目</h3><p>我们在 GitHub 上提供一个开源的<a href="https://github.com/AgoraIO/API-Examples-Web">示例项目</a>供你参考。</p><p>同时，你可以通过我们的<a href="https://webdemo.agora.io/agora-websdk-api-example-4.x/">在线 Web 应用</a>快速体验 Agora 实现的音视频相关功能。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>可以连接到互联网的 Windows 或 macOS 计算机。如果你的网络环境部署了防火墙，请参考[应用企业防火墙限制](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/firewall?platform=Web)以正常使用 Agora 服务。</li><li>计算机搭载 2.2 GHz Intel 第二代 i3/i5/i7 处理器或同等性能的其他处理器。</li><li>物理音视频采集设备，如内置摄像头和麦克风。</li><li>安装最新稳定版 <a href="https://www.google.cn/chrome/">Chrome 浏览器</a>。</li><li>有效的 Agora [开发者账号](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/sign_in_and_sign_up?platform=Web)。</li></ul><h3 id="获取-SDK"><a href="#获取-SDK" class="headerlink" title="获取 SDK"></a>获取 SDK</h3><p>选择如下任意一种方法获取 Agora Web SDK：</p><h4 id="方法-1-使用-npm-获取-SDK"><a href="#方法-1-使用-npm-获取-SDK" class="headerlink" title="方法 1. 使用 npm 获取 SDK"></a>方法 1. 使用 npm 获取 SDK</h4><p>使用该方法需要先安装 npm，详见 <a href="https://www.npmjs.com.cn/getting-started/installing-node/">npm 快速入门</a>。</p><ol><li><p>运行安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install agora-rtc-sdk-ng --save</span><br></pre></td></tr></table></figure></li><li><p>在你的项目的 JavaScript 代码中加入以下代码，引入这个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"><span class="keyword">const</span> client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>如果你使用 TypeScript, 还可以引入 SDK 中的类型对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC, &#123; IAgoraRTCClient &#125; <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"><span class="keyword">const</span> client: IAgoraRTCClient = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="方法-2-使用-CDN-方法获取-SDK"><a href="#方法-2-使用-CDN-方法获取-SDK" class="headerlink" title="方法 2. 使用 CDN 方法获取 SDK"></a>方法 2. 使用 CDN 方法获取 SDK</h4><p>该方法无需下载安装包。在项目 HTML 文件中，添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://download.agora.io/sdk/release/AgoraRTC_N-4.6.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方法-3-手动下载-SDK"><a href="#方法-3-手动下载-SDK" class="headerlink" title="方法 3. 手动下载 SDK"></a>方法 3. 手动下载 SDK</h4><ol><li><p>[下载](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/downloads?platform=Web) Agora Web SDK 4.x 版本 SDK 包。</p></li><li><p>将下载下来的 <code>.js</code> 文件保存到项目文件所在的目录下。</p></li><li><p>在项目文件中，将如下代码添加到 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./AgoraRTC_N-4.6.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>在方法 2 和方法 3 中，SDK 都会在全局导出一个 <code>AgoraRTC</code> 对象，直接访问这个对象即可操作 SDK。</li><li>在我们的示例项目中，为方便起见，我们选择第二种方法，直接使用 CDN 链接。</li></ul></blockquote><p>现在，我们已经将 Agora Web SDK 集成到项目中了。下一步我们要调用 Agora Web SDK 提供的核心 API。</p><h3 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h3><p>在使用 Agora Web SDK 时，你会经常用到以下三种对象：</p><ul><li>[AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象，代表一个本地客户端。<code>AgoraRTCClient</code> 类的方法提供了音视频通话的主要功能，例如加入频道、发布音视频轨道等。</li><li>[LocalTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 对象和 [RemoteTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotetrack.html) 对象，代表本地和远端的音视频轨道对象，用于播放等音视频相关的控制。</li></ul><blockquote><p>音视频流由音视频轨道构成。在 Agora Web SDK 中，我们通过操作音视频轨道对象来控制音视频流的行为。</p></blockquote><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>一次简单的音视频直播的步骤一般如下：</p><ol><li>根据项目的 App ID 创建一个本地客户端 <code>AgoraRTCClient</code> 对象，</li><li>调用 <code>AgoraRTCClient.setClientRole</code> 设置用户角色。</li><li>通过 <code>AgoraRTCClient.join</code> 加入到一个指定的频道中。</li><li>通过麦克风采集的音频创建一个 <code>MicrophoneAudioTrack</code> 对象（本地音频轨道对象）；通过摄像头采集的视频创建一个 <code>CameraVideoTrack</code> 对象（本地视频轨道对象）。</li><li>通过 <code>AgoraRTCClient.publish</code> 将创建的本地音视频轨道对象发布到频道中。</li></ol><p>当有其他用户加入频道并且也发布音视频轨道时：</p><ol><li>SDK 会触发 <code>client.on(&quot;user-published&quot;)</code> 事件，在这个事件回调函数的参数中你可以拿到远端用户对象 <code>AgoraRTCRemoteUser</code>，表示这个用户刚刚发布了音视频轨道。</li><li>通过 <code>AgoraRTCClient.subscribe</code> 订阅获取到的 <code>AgoraRTCRemoteUser</code>。</li><li>订阅完成后，访问 <code>AgoraRTCRemoteUser.audioTrack</code> 和 <code>AgoraRTCRemoteUser.videoTrack</code> 即可获取到 <code>RemoteAudioTrack</code>（远端音频轨道对象）和 <code>RemoteVideoTrack</code>（远端视频轨道对象）。</li></ol><p>下图展示了基础的音视频直播的 API 调用。注意图中的方法是对不同的对象调用的。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210810000548.png"></p><p>为方便起见，我们预定义了两个变量和一个函数，下面的所有示例代码都包裹在这个函数中。此步骤不是必须的，你可以根据你的项目有其他的实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rtc = &#123;</span><br><span class="line">  <span class="comment">// 用来放置本地客户端。</span></span><br><span class="line">  <span class="attr">client</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 用来放置本地音视频频轨道对象。</span></span><br><span class="line">  <span class="attr">localAudioTrack</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">localVideoTrack</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="comment">// 替换成你自己项目的 App ID。</span></span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&quot;&lt;YOUR APP ID&gt;&quot;</span>,</span><br><span class="line">  <span class="comment">// 传入目标频道名。</span></span><br><span class="line">  <span class="attr">channel</span>: <span class="string">&quot;demo_channel_name&quot;</span>,</span><br><span class="line">  <span class="comment">// 如果你的项目开启了 App 证书进行 Token 鉴权，这里填写生成的 Token 值。</span></span><br><span class="line">  <span class="attr">token</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 设置频道内的用户角色，可设为 &quot;audience&quot; 或 &quot;host&quot;</span></span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;audience&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBasicLive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接下来的代码写在这里。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startBasicLive();</span><br></pre></td></tr></table></figure><h4 id="1-创建本地客户端"><a href="#1-创建本地客户端" class="headerlink" title="1. 创建本地客户端"></a>1. 创建本地客户端</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtc.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;live&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>调用 <code>createClient</code> 方法创建本地客户端对象。需注意 <code>mode</code> 和 <code>codec</code> 这两个参数的设置：</p><ul><li><p><code>mode</code> 用于设置[频道场景](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/terms?platform=All Platforms#channel-profile)。Agora Web SDK 会根据使用场景的不同实行不同的优化策略。</p><ul><li>一对一或多人通话中，建议设为 <code>&quot;rtc&quot;</code>，使用通信场景。</li><li>互动直播中，建议设为 <code>&quot;live&quot;</code>，使用直播场景。</li></ul></li><li><p><code>codec</code> 用于设置浏览器使用的编解码格式。如果你需要使用 Safari 12.1 及之前版本，将该参数设为 <code>&quot;h264&quot;</code>；其他情况我们推荐使用 <code>&quot;vp8&quot;</code>。</p></li></ul><h4 id="2-设置用户角色"><a href="#2-设置用户角色" class="headerlink" title="2. 设置用户角色"></a>2. 设置用户角色</h4><p>直播频道有两种用户角色：主播和观众，默认的角色为观众。直播频道内的用户，只能看到主播的画面、听到主播的声音。</p><p>设置频道场景为直播后，你可以调用 <code>setClientRole</code> 方法设置用户角色。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role 的值可以是 &quot;host&quot; 或者 &quot;audience&quot;。</span></span><br><span class="line">client.setClientRole(options.role);</span><br></pre></td></tr></table></figure><p>加入频道后，如果你想切换用户角色，也可以调用 <code>setClientRole</code> 方法。</p><h4 id="3-加入目标频道"><a href="#3-加入目标频道" class="headerlink" title="3. 加入目标频道"></a>3. 加入目标频道</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uid = <span class="keyword">await</span> rtc.client.join(options.appId, options.channel, options.token, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>调用 <code>join</code> 加入目标频道。该方法返回一个 <code>Promise</code>，当返回 <code>resolve</code> 时表示加入频道成功，返回 <code>reject</code> 时表示加入频道出现错误。我们可以利用 <code>async/await</code> 极大地简化我们的代码。</p><p>调用 <code>join</code> 方法时你需要注意以下参数：</p><ul><li><p><code>appid</code>: 你的 App ID。详见[创建 Agora 项目](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_video_call_web?platform=Web##1-创建-agora-项目)和[获取 App ID](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_video_call_web?platform=Web#appid)。</p></li><li><p><code>channel</code>: 频道名，长度在 64 字节以内的字符串。在我们的示例项目中，<code>channel</code> 的值设为 <code>demo_channel_name</code>。</p></li><li><p><code>token</code>: （可选）如果你的 Agora 项目开启了 App 证书，你需要在该参数中传入一个 Token，详见[使用 Token](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/token?platform=All Platforms#使用-token)。</p><ul><li><p>在测试环境，我们推荐使用控制台生成临时 Token，详见[获取临时 Token](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/token?platform=All Platforms%23get-a-temporary-token#获取临时-token)。</p></li><li><p>在生产环境，我们推荐你在自己的服务端生成 Token，详见</p><p>生成 Token</p><blockquote><p>在我们的示例项目中，为了叙述方便，没有开启 App 证书，所以不需要校验 Token，<code>token</code> 的值为 <code>null</code>。如果你启用了 App 证书，请确保上面传入的 <code>channel</code> 值和生成 Token 时传入的 <code>channel</code> 值保持一致。</p></blockquote></li></ul></li><li><p><code>uid</code>：用户 ID，频道内每个用户的 UID 必须是唯一的。你可以填 <code>null</code>，Agora 会自动分配一个 UID 并在 <code>join</code> 的结果中返回。</p></li></ul><p>更多的 API 介绍和注意事项请参考 [AgoraRTCClient.join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 接口中的参数描述。</p><h4 id="4-创建并发布本地音视频轨道"><a href="#4-创建并发布本地音视频轨道" class="headerlink" title="4. 创建并发布本地音视频轨道"></a>4. 创建并发布本地音视频轨道</h4><p>当用户角色设为主播时，成功加入频道后，就可以创建并发布本地音视频轨道了。</p><p>如果用户角色设为观众，跳过该步骤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过麦克风采集的音频创建本地音频轨道对象。</span></span><br><span class="line">rtc.localAudioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line"><span class="comment">// 通过摄像头采集的视频创建本地视频轨道对象。</span></span><br><span class="line">rtc.localVideoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"><span class="comment">// 将这些音视频轨道对象发布到频道中。</span></span><br><span class="line"><span class="keyword">await</span> rtc.client.publish([rtc.localAudioTrack, rtc.localVideoTrack]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;publish success!&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们先调用 <code>createMicrophoneAudioTrack</code> 通过麦克风采集的音频创建本地音频轨道对象，调用 <code>createCameraVideoTrack</code> 通过摄像头采集的视频创建本地视频轨道对象；然后调用 <code>publish</code> 方法，将这些本地音视频轨道对象当作参数即可将音视频发布到频道中。</p><blockquote><ul><li>以上方法都会返回 <code>Promise</code>，<code>resolve</code> 时代表成功，<code>reject</code> 时代表失败。我们使用 <code>async/await</code> 来让代码逻辑更清晰。</li><li>由于加入频道和创建本地音视频轨道没有依赖关系，你可以利用 <code>Promise.all</code> 同时执行这些异步操作。</li></ul></blockquote><p>详细的参数设置（如采集设备和编码参数）请参考相关 API 文档：</p><ul><li>[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)</li><li>[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)</li><li>[publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish)</li></ul><h4 id="5-订阅远端用户"><a href="#5-订阅远端用户" class="headerlink" title="5. 订阅远端用户"></a>5. 订阅远端用户</h4><p>当远端用户发布音视频轨道时，SDK 会触发 <code>client.on(&quot;user-published&quot;)</code> 事件。我们需要通过 <code>client.on</code> 监听该事件并在回调中订阅新加入的远端用户。</p><blockquote><p>我们建议<strong>在创建客户端对象之后立即监听事件</strong>，以避免错过任何事件。放在这里介绍是因为叙述顺序。</p></blockquote><p>在 <code>createClient</code> 后下一行插入以下代码，监听 <code>client.on(&quot;user-published&quot;)</code> 事件，当有远端用户发布时开始订阅，并在订阅后自动播放远端音视频轨道对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">rtc.client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 开始订阅远端用户。</span></span><br><span class="line">  <span class="keyword">await</span> rtc.client.subscribe(user, mediaType);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;subscribe success&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示本次订阅的是视频。</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅完成后，从 `user` 中获取远端视频轨道对象。</span></span><br><span class="line">    <span class="keyword">const</span> remoteVideoTrack = user.videoTrack;</span><br><span class="line">    <span class="comment">// 动态插入一个 DIV 节点作为播放远端视频轨道的容器。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="comment">// 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">    playerContainer.id = user.uid.toString();</span><br><span class="line">    playerContainer.style.width = <span class="string">&quot;640px&quot;</span>;</span><br><span class="line">    playerContainer.style.height = <span class="string">&quot;480px&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.append(playerContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅完成，播放远端音视频。</span></span><br><span class="line">    <span class="comment">// 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。</span></span><br><span class="line">    remoteVideoTrack.play(playerContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以只传入该 DIV 节点的 ID。</span></span><br><span class="line">    <span class="comment">// remoteVideoTrack.play(playerContainer.id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示本次订阅的是音频。</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅完成后，从 `user` 中获取远端音频轨道对象。</span></span><br><span class="line">    <span class="keyword">const</span> remoteAudioTrack = user.audioTrack;</span><br><span class="line">    <span class="comment">// 播放音频因为不会有画面，不需要提供 DOM 元素的信息。</span></span><br><span class="line">    remoteAudioTrack.play();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你需要注意 <code>user-published</code> 事件的第二个参数 <code>mediaType</code>, 代表远端用户当前发布的媒体类型：</p><ul><li><code>audio</code>: 远端用户发布了音频轨道。</li><li><code>video</code>: 远端用户发布了视频轨道。</li></ul><p>当远端用户取消发布或离开频道时，SDK 会触发 <code>client.on(&quot;user-unpublished&quot;)</code> 事件。此时我们需要销毁刚刚动态创建的 DIV 节点。</p><p>在刚刚监听 <code>client.on(&quot;user-published&quot;)</code> 事件的代码下一行插入以下代码，监听 <code>client.on(&quot;user-unpublished&quot;)</code> 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rtc.client.on(<span class="string">&quot;user-unpublished&quot;</span>, <span class="function">(<span class="params">user, mediaType</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取刚刚动态创建的 DIV 节点。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.getElementById(user.uid.toString());</span><br><span class="line">    <span class="comment">// 销毁这个节点。</span></span><br><span class="line">    playerContainer.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-离开频道"><a href="#6-离开频道" class="headerlink" title="6. 离开频道"></a>6. 离开频道</h4><p>通过以下步骤离开频道：</p><ol><li>销毁创建的本地音视频轨道，解除网页对摄像头和麦克风的访问。</li><li>手动销毁之前动态创建的 DIV 节点。</li><li>调用 <code>leave</code> 离开频道。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">leaveCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 销毁本地音视频轨道。</span></span><br><span class="line">  rtc.localAudioTrack.close();</span><br><span class="line">  rtc.localVideoTrack.close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历远端用户。</span></span><br><span class="line">  rtc.client.remoteUsers.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 销毁动态创建的 DIV 节点。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.getElementById(user.uid);</span><br><span class="line">    playerContainer &amp;&amp; playerContainer.remove();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开频道。</span></span><br><span class="line">  <span class="keyword">await</span> rtc.client.leave();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在不同的产品设计中，离开频道可以既不销毁本地流，也不销毁动态创建的 DIV 节点。这些操作不是必须的，根据您自己的情况调整代码。</p></blockquote><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><p>AgoraRTC_Audio.vue       js核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;AgoraRTC_Audio&#x27;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="attr">uid</span>: &#123;</span><br><span class="line">                <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">Number</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">status</span>: &#123;</span><br><span class="line">                <span class="attr">default</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">Boolean</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">channel</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">token</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">appId</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">                <span class="attr">default</span>: <span class="string">&#x27;f4e2f949feaf400583aa1872ffeed2eb&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">videoContainerId</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">classroomRole</span>: <span class="built_in">Number</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">client</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">localAudioTrack</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">localVideoTrack</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">remoteUsers</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">localStream</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">publishStatus</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">checkDeviceTime</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">fun</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;audioinput&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;videoinput&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">deviceCheck</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;deviceCheck&#x27;</span>)</span><br><span class="line">                AgoraRTC.onMicrophoneChanged = <span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;microphone changed!&quot;</span>, info.state, info.device);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">let</span> res = &#123;</span><br><span class="line">                    <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">let</span> devices = <span class="keyword">await</span> <span class="built_in">this</span>.getDevices()</span><br><span class="line">                <span class="built_in">console</span>.log(devices)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">Object</span>.keys(devices).length)&#123;</span><br><span class="line">                    res.code = <span class="number">1</span></span><br><span class="line">                    res.msg = <span class="built_in">this</span>.GLOBAL.errorMsg.main[<span class="string">&#x27;mic device is not fount&#x27;</span>]</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> &#123;audioinput, videoinput&#125; = devices</span><br><span class="line">                    <span class="keyword">let</span> audioId = audioinput.deviceId;</span><br><span class="line">                    <span class="keyword">let</span> videoId = videoinput.deviceId;</span><br><span class="line">                    <span class="keyword">let</span> audioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack(&#123; <span class="attr">microphoneId</span>: audioId &#125;)</span><br><span class="line">                    <span class="keyword">let</span> videoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack(&#123;<span class="attr">cameraId</span>: videoId&#125;);</span><br><span class="line">                    <span class="keyword">let</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.deviceCheckAction(audioTrack, videoTrack)</span><br><span class="line">                    <span class="keyword">if</span>(!status)&#123;</span><br><span class="line">                        res.code = <span class="number">0</span></span><br><span class="line">                        res.msg = <span class="built_in">this</span>.GLOBAL.errorMsg.main[<span class="string">&#x27;have mic no volume&#x27;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">getDevices</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> devices = <span class="keyword">await</span> AgoraRTC.getDevices()</span><br><span class="line">                <span class="built_in">console</span>.log(devices)</span><br><span class="line">                devices = devices || []</span><br><span class="line">                <span class="keyword">let</span> &#123;fun&#125; = <span class="built_in">this</span></span><br><span class="line">                <span class="keyword">let</span> funDe = &#123;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> devices)&#123;</span><br><span class="line">                    <span class="keyword">let</span> &#123;kind&#125; = devices[i]</span><br><span class="line">                    <span class="keyword">if</span>(!fun[kind] || funDe[kind]) <span class="keyword">continue</span></span><br><span class="line">                    funDe[kind] = devices[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> funDe</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">deviceCheckAction</span>(<span class="params">audioTrack</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> t = <span class="built_in">this</span>.checkDeviceTime * <span class="number">1000</span></span><br><span class="line">                    <span class="keyword">let</span> num = t, status = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        num = num - <span class="number">1000</span></span><br><span class="line">                        <span class="keyword">const</span> level = audioTrack.getVolumeLevel();</span><br><span class="line">                        <span class="keyword">if</span>(level &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            status = <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;local stream audio level&quot;</span>, level);</span><br><span class="line">                        <span class="keyword">if</span>(t &lt;= <span class="number">0</span> || status)&#123;</span><br><span class="line">                            <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">                            success(<span class="literal">true</span>)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">1000</span>);</span><br><span class="line">                    <span class="built_in">this</span>.GLOBAL.timeoutGet(t).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!status) success(<span class="literal">false</span>)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> promise</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">pageInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.localAudioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line">                <span class="built_in">this</span>.localVideoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line">                <span class="built_in">this</span>.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;)</span><br><span class="line">                <span class="built_in">this</span>.eventInit()</span><br><span class="line">                <span class="comment">// 订阅自己的视频</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.localVideoTrack) <span class="built_in">this</span>.localVideoTrack.play(<span class="built_in">this</span>.getVideoContainerId(&#123;<span class="attr">uid</span>: <span class="built_in">this</span>.uid&#125;))</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.join()</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.publishCon();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">pageInitS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;)</span><br><span class="line">                <span class="built_in">this</span>.eventInit()</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.join()</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.publishCon();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">join</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.client.join(<span class="built_in">this</span>.appId, <span class="built_in">this</span>.channel, <span class="built_in">this</span>.token, <span class="built_in">this</span>.uid);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;join status&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">renewToken</span>(<span class="params">token</span>)</span>&#123;</span><br><span class="line">                token = token || <span class="built_in">this</span>.token</span><br><span class="line">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.client.renewToken(token)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">getVideoContainerId</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// let &#123;videoContainerId&#125; = this</span></span><br><span class="line">                <span class="comment">// if(videoContainerId) return videoContainerId</span></span><br><span class="line">                <span class="comment">// const playerContainer = document.createElement(&quot;div&quot;);</span></span><br><span class="line">                <span class="comment">// // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">                <span class="comment">// playerContainer.id = user.uid.toString();</span></span><br><span class="line">                <span class="comment">// playerContainer.style.width = &quot;640px&quot;;</span></span><br><span class="line">                <span class="comment">// playerContainer.style.height = &quot;480px&quot;;</span></span><br><span class="line">                <span class="comment">// document.body.append(playerContainer);</span></span><br><span class="line">                <span class="comment">// return playerContainer.id</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;user.uid&#125;</span>_user_video`</span></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">eventInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;user-published&#x27;</span>)</span><br><span class="line">                    <span class="comment">// 开始订阅远端用户。</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="built_in">this</span>.client.subscribe(user, mediaType);</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;subscribe success&quot;</span>);</span><br><span class="line">                    <span class="built_in">console</span>.log(mediaType)</span><br><span class="line">                    <span class="comment">// 表示本次订阅的是音频。</span></span><br><span class="line">                    <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 订阅完成后，从 `user` 中获取远端音频轨道对象。</span></span><br><span class="line">                        <span class="keyword">const</span> remoteAudioTrack = user.audioTrack;</span><br><span class="line">                        <span class="comment">// 播放音频因为不会有画面，不需要提供 DOM 元素的信息。</span></span><br><span class="line">                        remoteAudioTrack.play();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 表示本次订阅的是视频。</span></span><br><span class="line">                    <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 订阅完成后，从 `user` 中获取远端视频轨道对象。</span></span><br><span class="line">                        <span class="keyword">const</span> remoteVideoTrack = user.videoTrack;</span><br><span class="line">                        <span class="comment">// // 动态插入一个 DIV 节点作为播放远端视频轨道的容器。</span></span><br><span class="line">                        <span class="comment">// const playerContainer = document.createElement(&quot;div&quot;);</span></span><br><span class="line">                        <span class="comment">// // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">                        <span class="comment">// playerContainer.id = user.uid.toString();</span></span><br><span class="line">                        <span class="comment">// playerContainer.style.width = &quot;640px&quot;;</span></span><br><span class="line">                        <span class="comment">// playerContainer.style.height = &quot;480px&quot;;</span></span><br><span class="line">                        <span class="comment">// document.body.append(playerContainer);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// // 订阅完成，播放远端音视频。</span></span><br><span class="line">                        <span class="comment">// // 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。</span></span><br><span class="line">                        <span class="comment">// remoteVideoTrack.play(playerContainer);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// // 也可以只传入该 DIV 节点的 ID。</span></span><br><span class="line">                        <span class="keyword">let</span> id = <span class="built_in">this</span>.getVideoContainerId(user)</span><br><span class="line">                        remoteVideoTrack.play(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//远端用户或主播加入频道回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;user-joined&#x27;</span>, <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;用户加入频道&#x27;</span>)</span><br><span class="line">                    <span class="built_in">console</span>.log(user)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//远端用户离线回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;user-left&#x27;</span>, <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;用户离开频道&#x27;</span>)</span><br><span class="line">                    <span class="built_in">console</span>.log(user)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//报告频道内正在说话的远端用户及其音量的回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;volume-indicator&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(data)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//token过期回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;token-privilege-did-expire&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;token 失效&#x27;</span>)</span><br><span class="line">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;tokenInvalid&#x27;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//token 即将过期(30s)</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&quot;token-privilege-will-expire&quot;</span>, <span class="keyword">async</span> () =&gt;&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;token 即将 失效&#x27;</span>)</span><br><span class="line">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;tokenWillInvalid&#x27;</span>)</span><br><span class="line">                    <span class="comment">// await client.renewToken(token);</span></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//异常回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;exception&#x27;</span>, <span class="built_in">this</span>.handlError)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">handlError</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;agroa error&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(e)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">publishCon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.status)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.status) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">this</span>.publish()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">unpublish</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// if(!this.client || !this.publishStatus) return</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;unpublish&#x27;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.unpublish(<span class="built_in">this</span>.localAudioTrack);</span><br><span class="line">                <span class="built_in">this</span>.publishStatus = <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">publish</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// if(!this.client || this.publishStatus) return</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;publish&#x27;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.publish([<span class="built_in">this</span>.localAudioTrack, <span class="built_in">this</span>.localVideoTrack]);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;publish success!&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.publishStatus = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">leave</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client || !<span class="built_in">this</span>.client.leave || !<span class="built_in">this</span>.localAudioTrack || !<span class="built_in">this</span>.localAudioTrack.close) <span class="keyword">return</span></span><br><span class="line">                <span class="comment">// 销毁本地音频轨道。</span></span><br><span class="line">                <span class="built_in">this</span>.localAudioTrack.close();</span><br><span class="line">                <span class="built_in">this</span>.localVideoTrack.close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 离开频道。</span></span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.leave();</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">bannedVoiceSet</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">                status = status || <span class="built_in">this</span>.status</span><br><span class="line">                status ? <span class="built_in">this</span>.publish() : <span class="built_in">this</span>.unpublish()</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">watch</span>: &#123;</span><br><span class="line">            <span class="attr">status</span>: &#123;</span><br><span class="line">                <span class="function"><span class="title">handler</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.bannedVoiceSet(val)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>应用文件代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTCAudioVue <span class="keyword">from</span> <span class="string">&#x27;../../components/AgoraRTC_Audio4.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">agoraInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.agoraDisabled)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;不开启语音&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&#x27;开启语音&#x27;)</span></span><br><span class="line">    <span class="keyword">let</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.deviceCheckOpen()</span><br><span class="line">    <span class="comment">// this.agoraStatus = status</span></span><br><span class="line">    <span class="comment">// if(!status) return</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.agoraToekInit()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.agoraChannelName &amp;&amp; <span class="built_in">this</span>.agoraToken)&#123;</span><br><span class="line">        <span class="comment">// 开启视频</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.classroomRole == <span class="number">0</span>)&#123;   </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.$refs[<span class="string">&#x27;AgoraRTCAudioVue&#x27;</span>].pageInit()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.$refs[<span class="string">&#x27;AgoraRTCAudioVue&#x27;</span>].pageInitS()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.micStatusSet(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在各个文件中进行带调用完成加入，发布，订阅，销毁等主要功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;声网&quot;&gt;&lt;a href=&quot;#声网&quot; class=&quot;headerlink&quot; title=&quot;声网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.agora.io/cn&quot;&gt;声网&lt;/a&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;产品概述&quot;&gt;&lt;a href=&quot;#产品概述&quot; </summary>
      
    
    
    
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>小程序问题与解决</title>
    <link href="https://andylinwenqin.github.io/2021/07/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <id>https://andylinwenqin.github.io/2021/07/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/</id>
    <published>2021-07-25T08:54:42.000Z</published>
    <updated>2021-08-02T02:47:02.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序问题"><a href="#小程序问题" class="headerlink" title="小程序问题"></a>小程序问题</h1><hr><h2 id="小程序app-js和首页的index-js的调用顺序"><a href="#小程序app-js和首页的index-js的调用顺序" class="headerlink" title="小程序app.js和首页的index.js的调用顺序"></a>小程序app.js和首页的index.js的调用顺序</h2><p>首先一个小程序打开一定是先执行app.js中的onlaunch函数，之后才会去执行index.js中的onload函数，但是为什么我们使用wx.login时候将一些获取到的token之类的放到APP.globalData中出现，index.js获取不到信息的问题呢？</p><p>因为但凡是个请求获取，就需要时间，在onlaunch中发起了请求但是回调函数还未返回，index.js页面就开始请求，此时就有可能会出现(看那个执行快)找不到APP.globalData中的数据的问题。</p><p>这种情况最好的解决办法就是封装到app.js中，第二个函数放在第一个函数的回调中，确保数据成功拿到了在执行第二个函数。保证函数的顺序性。当然也可以用 setTimeout()强制延缓第二个函数执行时间，很不推荐这种方法。</p>]]></content>
    
    
    <summary type="html">一些在编写小程序中遇到的小问题</summary>
    
    
    
    
    <category term="小程序" scheme="https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序基础API的使用</title>
    <link href="https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80API%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80API%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-17T14:14:41.000Z</published>
    <updated>2021-07-18T11:13:36.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础API的使用"><a href="#基础API的使用" class="headerlink" title="基础API的使用"></a>基础API的使用</h1><hr><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="wx-switchTab-Object-object"><a href="#wx-switchTab-Object-object" class="headerlink" title="wx.switchTab(Object object)"></a>wx.switchTab(Object object)</h2><p>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的 tabBar 页面的路径 (代码包路径)（需在 app.json 的 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabbar">tabBar</a> 字段定义的页面），路径后不能带参数。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;tabBar&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;list&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;index&quot;</span>,</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;首页&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;other&quot;</span>,</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;其他&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.switchTab(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/index&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-reLaunch-Object-object"><a href="#wx-reLaunch-Object-object" class="headerlink" title="wx.reLaunch(Object object)"></a>wx.reLaunch(Object object)</h2><p>关闭所有页面，打开到应用内的某个页面</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的应用内页面路径 (代码包路径)，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.reLaunch(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;test?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad (option) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(option.query)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-redirectTo-Object-object"><a href="#wx-redirectTo-Object-object" class="headerlink" title="wx.redirectTo(Object object)"></a>wx.redirectTo(Object object)</h2><p>关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。</p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 <code>?</code> 分隔，参数键与参数值用 <code>=</code> 相连，不同参数用 <code>&amp;</code> 分隔；如 ‘path?key=value&amp;key2=value2’</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.redirectTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;test?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-navigateTo-Object-object"><a href="#wx-navigateTo-Object-object" class="headerlink" title="wx.navigateTo(Object object)"></a>wx.navigateTo(Object object)</h2><p>保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a> 可以返回到原页面。小程序中页面栈最多十层。</p><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 <code>?</code> 分隔，参数键与参数值用 <code>=</code> 相连，不同参数用 <code>&amp;</code> 分隔；如 ‘path?key=value&amp;key2=value2’</td></tr><tr><td align="left">events</td><td align="left">Object</td><td align="left"></td><td align="left">否</td><td align="left">页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="object-success-回调函数"><a href="#object-success-回调函数" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">eventChannel</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/EventChannel.html">EventChannel</a></td><td align="left">和被打开页面进行通信</td></tr></tbody></table><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;test?id=1&#x27;</span>,</span><br><span class="line">  <span class="attr">events</span>: &#123;</span><br><span class="line">    <span class="comment">// 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据</span></span><br><span class="line">    <span class="attr">acceptDataFromOpenedPage</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">someEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过eventChannel向被打开页面传送数据</span></span><br><span class="line">    res.eventChannel.emit(<span class="string">&#x27;acceptDataFromOpenerPage&#x27;</span>, &#123; <span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(option.query)</span><br><span class="line">    <span class="keyword">const</span> eventChannel = <span class="built_in">this</span>.getOpenerEventChannel()</span><br><span class="line">    eventChannel.emit(<span class="string">&#x27;acceptDataFromOpenedPage&#x27;</span>, &#123;<span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span>&#125;);</span><br><span class="line">    eventChannel.emit(<span class="string">&#x27;someEvent&#x27;</span>, &#123;<span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据</span></span><br><span class="line">    eventChannel.on(<span class="string">&#x27;acceptDataFromOpenerPage&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-navigateBack-Object-object"><a href="#wx-navigateBack-Object-object" class="headerlink" title="wx.navigateBack(Object object)"></a>wx.navigateBack(Object object)</h2><blockquote><p><strong>以 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#%E5%BC%82%E6%AD%A5-API-%E8%BF%94%E5%9B%9E-Promise">Promise 风格</a> 调用</strong>：支持</p><p><strong>需要页面权限</strong>：小程序不能在插件页面中调用该接口，插件也不能在小程序页面中调用该接口</p><p><strong>小程序插件</strong>：支持，需要小程序基础库版本不低于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.1.0</a></p><p>在小程序插件中使用时，只能在当前插件的页面中调用</p><p><strong>微信 Windows 版</strong>：支持</p><p><strong>微信 Mac 版</strong>：支持</p></blockquote><p>关闭当前页面，返回上一页面或多级页面。可通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html">getCurrentPages</a> 获取当前的页面栈，决定需要返回几层。</p><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">delta</td><td align="left">number</td><td align="left">1</td><td align="left">否</td><td align="left">返回的页面数，如果 delta 大于现有页面数，则返回到首页。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是A页面</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;B?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是B页面</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;C?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在C页面内 navigateBack，将返回A页面</span></span><br><span class="line">wx.navigateBack(&#123;</span><br><span class="line">  <span class="attr">delta</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><h2 id="wx-navigateToMiniProgram-Object-object"><a href="#wx-navigateToMiniProgram-Object-object" class="headerlink" title="wx.navigateToMiniProgram(Object object)"></a>wx.navigateToMiniProgram(Object object)</h2><p>打开另一个小程序</p><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">appId</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">要打开的小程序 appId</td></tr><tr><td align="left">path</td><td align="left">string</td><td align="left"></td><td align="left">否</td><td align="left">打开的页面路径，如果为空则打开首页。path 中 ? 后面的部分会成为 query，在小程序的 <code>App.onLaunch</code>、<code>App.onShow</code> 和 <code>Page.onLoad</code> 的回调函数或小游戏的 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/(wx.onShow)">wx.onShow</a> 回调函数、<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 中可以获取到 query 数据。对于小游戏，可以只传入 query 部分，来实现传参效果，如：传入 “?foo=bar”。</td></tr><tr><td align="left">extraData</td><td align="left">object</td><td align="left"></td><td align="left">否</td><td align="left">需要传递给目标小程序的数据，目标小程序可在 <code>App.onLaunch</code>，<code>App.onShow</code> 中获取到这份数据。如果跳转的是小游戏，可以在 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/(wx.onShow)">wx.onShow</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 中可以获取到这份数据数据。</td></tr><tr><td align="left">envVersion</td><td align="left">string</td><td align="left">release</td><td align="left">否</td><td align="left">要打开的小程序版本。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p><strong>object.envVersion 的合法值</strong></p><table><thead><tr><th align="left">值</th><th align="left">说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">develop</td><td align="left">开发版</td><td align="left"></td></tr><tr><td align="left">trial</td><td align="left">体验版</td><td align="left"></td></tr><tr><td align="left">release</td><td align="left">正式版</td><td align="left"></td></tr></tbody></table><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><h5 id="需要用户触发跳转"><a href="#需要用户触发跳转" class="headerlink" title="需要用户触发跳转"></a>需要用户触发跳转</h5><p>从 2.3.0 版本开始，若用户未点击小程序页面任意位置，则开发者将无法调用此接口自动跳转至其他小程序。</p><h5 id="需要用户确认跳转"><a href="#需要用户确认跳转" class="headerlink" title="需要用户确认跳转"></a>需要用户确认跳转</h5><p>从 2.3.0 版本开始，在跳转至其他小程序前，将统一增加弹窗，询问是否跳转，用户确认后才可以跳转其他小程序。如果用户点击取消，则回调 <code>fail cancel</code>。</p><h5 id="无需声明跳转名单，不限跳转数量（众测中）"><a href="#无需声明跳转名单，不限跳转数量（众测中）" class="headerlink" title="无需声明跳转名单，不限跳转数量（众测中）"></a>无需声明跳转名单，不限跳转数量（众测中）</h5><ol><li>从2020年4月24日起，使用跳转其他小程序功能将无需在全局配置中声明跳转名单，调用此接口时将不再校验所跳转的 AppID 是否在 navigateToMiniProgramAppIdList 中。</li><li>从2020年4月24日起，跳转其他小程序将不再受数量限制，使用此功能时请注意遵守运营规范。</li></ol><h3 id="运营规范"><a href="#运营规范" class="headerlink" title="运营规范"></a>运营规范</h3><p>平台将坚决打击小程序盒子等互推行为，使用此功能时请严格遵守<a href="https://developers.weixin.qq.com/miniprogram/product/#_5-10-%E4%BA%92%E6%8E%A8%E8%A1%8C%E4%B8%BA">《微信小程序平台运营规范》</a>，若发现小程序违反运营规范将被下架处理。</p><h3 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h3><ul><li>在开发者工具上调用此 API 并不会真实的跳转到另外的小程序，但是开发者工具会校验本次调用跳转是否成功。<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%94%AF%E6%8C%81">详情</a></li><li>开发者工具上支持被跳转的小程序处理接收参数的调试。<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%94%AF%E6%8C%81">详情</a></li></ul><h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateToMiniProgram(&#123;</span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;page/index/index?id=123&#x27;</span>,</span><br><span class="line">  <span class="attr">extraData</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">envVersion</span>: <span class="string">&#x27;develop&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 打开成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-navigateBackMiniProgram-Object-object"><a href="#wx-navigateBackMiniProgram-Object-object" class="headerlink" title="wx.navigateBackMiniProgram(Object object)"></a>wx.navigateBackMiniProgram(Object object)</h2><p>返回到上一个小程序。只有在当前小程序是被其他小程序打开时可以调用成功</p><p>注意：<strong>微信客户端 iOS 6.5.9，Android 6.5.10 及以上版本支持</strong></p><h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">extraData</td><td align="left">Object</td><td align="left">{}</td><td align="left">否</td><td align="left">需要返回给上一个小程序的数据，上一个小程序可在 <code>App.onShow</code> 中获取到这份数据。 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html">详情</a>。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateBackMiniProgram(&#123;</span><br><span class="line">  <span class="attr">extraData</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-exitMiniProgram-Object-object"><a href="#wx-exitMiniProgram-Object-object" class="headerlink" title="wx.exitMiniProgram(Object object)"></a>wx.exitMiniProgram(Object object)</h2><p>退出当前小程序。必须有点击行为才能调用成功。</p><h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h1 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h1><h2 id="wx-setStorageSync-string-key-any-data"><a href="#wx-setStorageSync-string-key-any-data" class="headerlink" title="wx.setStorageSync(string key, any data)"></a>wx.setStorageSync(string key, any data)</h2><blockquote><p><strong>以 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#%E5%BC%82%E6%AD%A5-API-%E8%BF%94%E5%9B%9E-Promise">Promise 风格</a> 调用</strong>：支持</p><p><strong>小程序插件</strong>：支持，需要小程序基础库版本不低于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.6</a></p></blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html">wx.setStorage</a> 的同步版本</p><h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><h4 id="string-key"><a href="#string-key" class="headerlink" title="string key"></a>string key</h4><p>本地缓存中指定的 key</p><h4 id="any-data"><a href="#any-data" class="headerlink" title="any data"></a>any data</h4><p>需要存储的内容。只支持原生类型、Date、及能够通过<code>JSON.stringify</code>序列化的对象。</p><h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.setStorage(&#123;</span><br><span class="line">  <span class="attr">key</span>:<span class="string">&quot;key&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>:<span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.setStorageSync(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="wx-setStorage-Object-object"><a href="#wx-setStorage-Object-object" class="headerlink" title="wx.setStorage(Object object)"></a>wx.setStorage(Object object)</h2><blockquote><p><strong>以 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#%E5%BC%82%E6%AD%A5-API-%E8%BF%94%E5%9B%9E-Promise">Promise 风格</a> 调用</strong>：支持</p><p><strong>小程序插件</strong>：支持，需要小程序基础库版本不低于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.6</a></p></blockquote><p>将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。</p><h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">本地缓存中指定的 key</td></tr><tr><td align="left">data</td><td align="left">any</td><td align="left"></td><td align="left">是</td><td align="left">需要存储的内容。只支持原生类型、Date、及能够通过<code>JSON.stringify</code>序列化的对象。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.setStorage(&#123;</span><br><span class="line">  <span class="attr">key</span>:<span class="string">&quot;key&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>:<span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.setStorageSync(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="wx-getStorage-Object-object"><a href="#wx-getStorage-Object-object" class="headerlink" title="wx.getStorage(Object object)"></a>wx.getStorage(Object object)</h2><p>从本地缓存中异步获取指定 key 的内容。缓存相关策略请查看 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html">存储</a>。</p><h2 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h2><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">本地缓存中指定的 key</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="object-success-回调函数-1"><a href="#object-success-回调函数-1" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">data</td><td align="left">any</td><td align="left">key对应的内容</td></tr></tbody></table><h3 id="示例代码-9"><a href="#示例代码-9" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.getStorage(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;key&#x27;</span>,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> value = wx.getStorageSync(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="comment">// Do something with return value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Do something when catch error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wx-getStorageInfo-Object-object"><a href="#wx-getStorageInfo-Object-object" class="headerlink" title="wx.getStorageInfo(Object object)"></a>wx.getStorageInfo(Object object)</h2><p>异步获取当前storage的相关信息。缓存相关策略请查看 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html">存储</a>。</p><h3 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="object-success-回调函数-2"><a href="#object-success-回调函数-2" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">keys</td><td align="left">Array.<string></td><td align="left">当前 storage 中所有的 key</td></tr><tr><td align="left">currentSize</td><td align="left">number</td><td align="left">当前占用的空间大小, 单位 KB</td></tr><tr><td align="left">limitSize</td><td align="left">number</td><td align="left">限制的空间大小，单位 KB</td></tr></tbody></table><h3 id="示例代码-10"><a href="#示例代码-10" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.getStorageInfo(&#123;</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.keys)</span><br><span class="line">    <span class="built_in">console</span>.log(res.currentSize)</span><br><span class="line">    <span class="built_in">console</span>.log(res.limitSize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = wx.getStorageInfoSync()</span><br><span class="line">  <span class="built_in">console</span>.log(res.keys)</span><br><span class="line">  <span class="built_in">console</span>.log(res.currentSize)</span><br><span class="line">  <span class="built_in">console</span>.log(res.limitSize)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Do something when catch error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wx-clearStorage-Object-object"><a href="#wx-clearStorage-Object-object" class="headerlink" title="wx.clearStorage(Object object)"></a>wx.clearStorage(Object object)</h2><p>清理本地数据缓存。缓存相关策略请查看 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html">存储</a>。</p><h3 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-11"><a href="#示例代码-11" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.clearStorage()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.clearStorageSync()</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// Do something when catch error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础API的使用&quot;&gt;&lt;a href=&quot;#基础API的使用&quot; class=&quot;headerlink&quot; title=&quot;基础API的使用&quot;&gt;&lt;/a&gt;基础API的使用&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="小程序" scheme="https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序登录接口的更新</title>
    <link href="https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
    <id>https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/</id>
    <published>2021-07-17T04:19:31.000Z</published>
    <updated>2021-07-17T14:16:19.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取用户信息（2021-4-28微信更新）"><a href="#获取用户信息（2021-4-28微信更新）" class="headerlink" title="获取用户信息（2021.4.28微信更新）"></a>获取用户信息（2021.4.28微信更新）</h1><hr><h2 id="wx-login"><a href="#wx-login" class="headerlink" title="wx.login"></a>wx.login</h2><p>调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。</p><h3 id="object-success-回调函数"><a href="#object-success-回调函数" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">string</td><td align="left">用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">auth.code2Session</a>，使用 code 换取 openid、unionid、session_key 等信息</td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.code) &#123;</span><br><span class="line">      <span class="comment">//发起网络请求</span></span><br><span class="line">      wx.request(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;https://example.com/onLogin&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">          <span class="attr">code</span>: res.code</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;登录失败！&#x27;</span> + res.errMsg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实际使用代码"><a href="#实际使用代码" class="headerlink" title="实际使用代码"></a>实际使用代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    that.globalData.code = res.code</span><br><span class="line">    <span class="built_in">console</span>.log(glo.copy(res))</span><br><span class="line">    <span class="keyword">let</span> u = <span class="string">&#x27;https://golaxy.weiqiai.com:8080/user/authorize&#x27;</span></span><br><span class="line">    that.getData(u, &#123; <span class="attr">js_code</span>: res.code &#125;)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(glo.copy(r))</span><br><span class="line">        that.globalData.openId = r.openid</span><br><span class="line">        <span class="keyword">let</span> session_key = r.session_key;</span><br><span class="line">        <span class="keyword">let</span> u = <span class="string">&#x27;https://golaxy.weiqiai.com:8080/user/getUserInfo&#x27;</span></span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        success(<span class="literal">false</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 发送 res.code 到后台换取 openId, sessionKey, unionId</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>拿到了openId等信息</p><h2 id="wx-getUserProfile"><a href="#wx-getUserProfile" class="headerlink" title="wx.getUserProfile"></a>wx.getUserProfile</h2><p>获取用户信息。页面产生点击事件（例如 <code>button</code> 上 <code>bindtap</code> 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 <code>userInfo</code>。该接口用于替换 <code>wx.getUserInfo</code>，</p><p><strong>这个函数只能通过点击事件触发</strong></p><h3 id="object-success-回调函数-1"><a href="#object-success-回调函数-1" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">userInfo</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/UserInfo.html">UserInfo</a></td><td align="left">用户信息对象</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">rawData</td><td align="left">string</td><td align="left">不包括敏感信息的原始数据字符串，用于计算签名</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">signature</td><td align="left">string</td><td align="left">使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">用户数据的签名验证和加解密</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">encryptedData</td><td align="left">string</td><td align="left">包括敏感数据在内的完整用户信息的加密数据，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">iv</td><td align="left">string</td><td align="left">加密算法的初始向量，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">cloudID</td><td align="left">string</td><td align="left">敏感数据对应的云 ID，开通<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">云开发</a>的小程序才会返回，可通过云调用直接获取开放数据，详细见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#method-cloud">云调用直接获取开放数据</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr></tbody></table><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p><a href="https://developers.weixin.qq.com/s/tsJaq2mP7Mp4">在开发者工具中预览效果</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;canIUseGetUserProfile&#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;getUserProfile&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:else</span> <span class="attr">open-type</span>=<span class="string">&quot;getUserInfo&quot;</span> <span class="attr">bindgetuserinfo</span>=<span class="string">&quot;getUserInfo&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">bindtap</span>=<span class="string">&quot;bindViewTap&quot;</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-avatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">userInfo</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">hasUserInfo</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">canIUseGetUserProfile</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">onLoad</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (wx.getUserProfile) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">        <span class="attr">canIUseGetUserProfile</span>: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getUserProfile</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认</span></span><br><span class="line">    <span class="comment">// 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗</span></span><br><span class="line">    wx.getUserProfile(&#123;</span><br><span class="line">      <span class="attr">desc</span>: <span class="string">&#x27;用于完善会员资料&#x27;</span>, <span class="comment">// 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span></span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">          <span class="attr">userInfo</span>: res.userInfo,</span><br><span class="line">          <span class="attr">hasUserInfo</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getUserInfo</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 不推荐使用getUserInfo获取用户信息，预计自2021年4月13日起，getUserInfo将不再弹出弹窗，并直接返回匿名的用户个人信息</span></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">userInfo</span>: e.detail.userInfo,</span><br><span class="line">      <span class="attr">hasUserInfo</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实际使用代码-1"><a href="#实际使用代码-1" class="headerlink" title="实际使用代码"></a>实际使用代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wx.getUserProfile(&#123;</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = res.userInfo || &#123;&#125;</span><br><span class="line">    wx.setStorageSync(<span class="string">&#x27;userInfo&#x27;</span>, userInfo)</span><br><span class="line">    <span class="comment">// that.globalData.userInfo = userInfo</span></span><br><span class="line">    <span class="built_in">this</span>.userInfoSet()</span><br><span class="line">    success(userInfo)</span><br><span class="line">    <span class="comment">// that.globalData.loged = true</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>虽然微信这个变动让很多小程序开发者苦不堪言，但是还是很方便的，之前的方式是wx.login获取code给wx.getUserInfo去拿取session_key和openid，然后传给后端，后端去请求用户个人信息，对此很多程序员都封装了组件，类似套娃的方法去实现。</p><p>在这次更新后，wx.getUserProfile取缔wx.getUserInfo，wx.getUserProfile必须用点击事件触发例如bindtap(),之前的’套娃组件‘也都要废弃，改成了更加简单的方式，封装一个函数，在app.js页面一开始调用wx.login获取openid。然后在写一个button点击事件bindtap()调用wx.getUserProfile获取以下信息</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210717131151.png"></p><p>然后前端在调用接口传个后端存进数据库</p>]]></content>
    
    
    <summary type="html">解决一个大家都头疼的问题(可能只有我头大吧哈哈哈)</summary>
    
    
    
    
    <category term="小程序" scheme="https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单工,半双工,全双工三者区别</title>
    <link href="https://andylinwenqin.github.io/2021/07/11/%E5%8D%95%E5%B7%A5-%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%85%A8%E5%8F%8C%E5%B7%A5%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/"/>
    <id>https://andylinwenqin.github.io/2021/07/11/%E5%8D%95%E5%B7%A5-%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%85%A8%E5%8F%8C%E5%B7%A5%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-11T07:10:38.000Z</published>
    <updated>2021-07-11T07:15:35.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单工-半双工-全双工三者区别"><a href="#单工-半双工-全双工三者区别" class="headerlink" title="单工 半双工 全双工三者区别"></a>单工 半双工 全双工三者区别</h1><hr><h2 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h2><p>单工就是指A只能发信号，而B只能接收信号，通信是单向的，就象灯塔之于航船-灯塔发出光信号而航船只能接收信号以确保自己行驶在正确的航线上。 </p><h2 id="半双工（Half-Duplex）"><a href="#半双工（Half-Duplex）" class="headerlink" title="半双工（Half Duplex）"></a>半双工（Half Duplex）</h2><p>半双工就是指A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。最典型的例子就象我们在影视作品中看到的对讲机一样： </p><p>007：呼叫总部，请求支援，OVER  </p><p>总部：收到，增援人员将在5分钟内赶到，OVER  </p><p>007：要5分钟这么久？！要快呀！OVER  </p><p>总部：„„  </p><p>在这里，每方说完一句话后都要说个OVER，然后切换到接收状态，同时也告之对方-你可以发言了。如果双方同时处于收状态，或同时处于发状态，便不能正常通信了。 </p><h2 id="全双工-（Full-Duplex）"><a href="#全双工-（Full-Duplex）" class="headerlink" title="全双工 （Full Duplex）"></a>全双工 （Full Duplex）</h2><p>全双工比半双工又进了一步。在A给B发信号的同时，B也可以给A发信号。典型的例子就是打电话。<br>A：我跟你说呀„„<br>B：你先听我说，情况是这样的„„<br>A和B在说的同时也能听到对方说的内容，这就是全双工。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://blog.csdn.net/erwangshi/article/details/44940069">原文链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单工-半双工-全双工三者区别&quot;&gt;&lt;a href=&quot;#单工-半双工-全双工三者区别&quot; class=&quot;headerlink&quot; title=&quot;单工 半双工 全双工三者区别&quot;&gt;&lt;/a&gt;单工 半双工 全双工三者区别&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;单工&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="通信机制" scheme="https://andylinwenqin.github.io/tags/%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Stomp</title>
    <link href="https://andylinwenqin.github.io/2021/07/06/STOMP/"/>
    <id>https://andylinwenqin.github.io/2021/07/06/STOMP/</id>
    <published>2021-07-06T11:12:57.000Z</published>
    <updated>2021-07-17T03:15:40.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习血汗史"><a href="#学习血汗史" class="headerlink" title="学习血汗史"></a>学习血汗史</h2><p>查了各类资料花了整整三天才学通，又被跨域卡了一天，直到第五天才完完全全跑通，下一步学习emoji的表情包用法</p><hr><h2 id="stomp-over-websocket协议原理"><a href="#stomp-over-websocket协议原理" class="headerlink" title="stomp over websocket协议原理"></a>stomp over websocket协议原理</h2><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>http协议是单工的, 只能由client发请求再由server返回请求结果, 在http协议中server是不能主动发请求到client的.</p><p>大多数情况下http协议都是适用的, 但当遇到在线聊天, 股票行情这样需要实时获取取服务端信息的应用时, client需要频繁轮询server<br>过程如下:</p><blockquote><p>client 建立连接<br>client 问server有没有新的消息, 并根据返回结果进行处理<br>client 关闭连接<br>client 建立连接<br>client 问server有没有新的消息, 并根据返回结果进行处理<br>client 关闭连接<br>…</p></blockquote><p>为了拿到最新信息, client一直这样循环下去<br>server如果一直没有新的消息, client的大多请求都是无效的, 效率低下.</p><p>为了提高效率需要有一种协议可以让server主动发消息给client.<br>这样就不需要client频繁轮询, 只要server有新消息就会主动推送给client.</p><p>这种协议就是websocket协议(效果：服务端主动向客户端发送信息).</p><h3 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h3><p>webSocket协议是基于TCP的一种网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。<br>在webscoket协议中, client利用http来建立tcp连接, 建立tcp连接之后, client与server就可以基于tcp连接来愉快的进行通信了.</p><p>那么webscoket如何利用http建立连接的呢?</p><p>先看一个经典图示</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154116.png"></p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><h5 id="client与server是利用http的一次request-response来建立连接的"><a href="#client与server是利用http的一次request-response来建立连接的" class="headerlink" title="client与server是利用http的一次request, response来建立连接的."></a>client与server是利用http的一次request, response来建立连接的.</h5><p>其中http request消息体如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/echo</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host:jingxu.test.com:8100</span><br><span class="line">Origin:http://jingxu.test.com:8099</span><br><span class="line">Sec-WebSocket-Extensions:permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Key:rVX0XFeQzA9QVXXEfjm0yw==</span><br><span class="line">Sec-WebSocket-Version:13</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure><p>其中前三个header:Get, Host, Origin都是http协议之前就有, 不多做解释, 主要解释一下后面这几个header<br>Sec-WebSocket-Extensions: 用于对websocket协议进行扩展. 比如websocket协议本身不支持压缩, 但可以通过Sec-WebSocket-Extensions中的permessage-deflate来协商压缩.<br>Sec-WebSocket-Key:client随机生成的一段key. 详情之后response中Sec-WebSocket-Accept的解释.<br>Sec-WebSocket-Version:协议的版本号<br>Upgrade:通过http的Upgrade对协议进行切换. 告诉server, 建立连接后用websocket协议.</p><p>http response消息体如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connection:upgrade</span><br><span class="line">Date:Mon, 04 Dec 2017 10:05:18 GMT</span><br><span class="line">Sec-WebSocket-Accept:q3dUKg4lRGCqqRhGIvmE7sH8Yuc=</span><br><span class="line">Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits=15</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure><p>Connection与Date都是http协议之前就有的header, 主要解释一下后面的.<br>Sec-WebSocket-Accept:对应于request中的Sec-WebSocket-Key.<br>server会根据request中的Sec-WebSocket-Key的值来生成response中的Sec-WebSocket-Accept的值.<br>具体的算法是根据Sec-WebSocket-Key与协议中已定义的一个guid “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”进行拼接<br>再对结果进行sha1, 再对sha1的结果进行base64, 最后得到Sec-WebSocket-Accept的值.</p><h5 id="client通过验证server返回的Sec-WebSocket-Accept的值-来确定两件事情"><a href="#client通过验证server返回的Sec-WebSocket-Accept的值-来确定两件事情" class="headerlink" title="client通过验证server返回的Sec-WebSocket-Accept的值, 来确定两件事情:"></a>client通过验证server返回的Sec-WebSocket-Accept的值, 来确定两件事情:</h5><p>server理解websocket协议.<br>如果server不理解, 那么server不会返回正确的Sec-WebSocket-Accept.<br>如果server没有返回正确的Sec-WebSocket-Accept, 那么建立websocket连接失败.</p><p>server返回的response是对于client的此次reuqest的响应而不是之前的缓存.<br>主要是防止有些缓存服务器返回缓存的response.</p><p>发送数据<br>现在websocket连接已经建立, 由于websocket没有规范payload的格式, 所以应用需要自己去定义payload的格式.</p><p>websocket的payload可以是文本也可以是二进制.<br>应用一般会选择用文本.<br>这个文本是什么格式websocket协议本身并没有规定, 由应用自己来定.</p><p>比如我要请求发送消息这个接口, 那么我的payload可以写成:</p><p><code>/send | params=我是消息</code></p><p>这里我自己定义了一个格式, 中坚线之前的是要调用的地址, 中竖线之后是参数.<br>由于格式是自己定义的, 所以在服务端我也需要自己写代码来解析这个格式.<br>把/send路由到相应的处理方法.</p><p>那有没有一种统一的协议呢? 统一的标准呢?<br>因为这样就会有相应的已经实现的库来解析路由, 而不用自己去写, 自己去定义格式.</p><p>这个统一的协议就是stomp协议(一个基于webSocket的通信协议或者说一种标准).</p><h3 id="stomp协议"><a href="#stomp协议" class="headerlink" title="stomp协议"></a>stomp协议</h3><p><strong>stomp是一个用于client之间进行异步消息传输的简单文本协议, 全称是Simple Text Oriented Messaging Protocol.</strong></p><blockquote><p>对于stomp协议来说, client分为消费者client与生产者client两种. server是指broker, 也就是消息队列的管理者.</p></blockquote><p>stomp协议并不是为websocket设计的, 它是属于消息队列的一种协议, 和amqp, jms平级.<br>只不过由于它的简单性恰巧可以用于定义websocket的消息体格式.<br>stomp协议很多mq都已支持, 比如rabbitmq, activemq. 很多语言也都有stomp协议的解析client库.</p><p>可以这么理解, websocket结合stomp相当于一个面向公网对用户比较友好的一种消息队列.</p><p>stomp协议中的client分为两角色:</p><blockquote><p>生产者: 通过<code>SEND</code>命令给某个目的地址(destination)发送消息.</p><p>消费者: 通过<code>SUBSCRIBE</code>命令订阅某个目的地址(destination), 当生产者发送消息到目的地址后, 订阅此目的地址的消费者会即时收到消息.</p></blockquote><p>stomp协议的结构与http结构相似, 结构如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1 </span><br><span class="line">header2:value2 </span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure><p><strong>其中^@代表null结尾.</strong></p><p>与http相似有三部分组成: 命令, header, 消息体.<br>命令与header使用utf-8格式, body可以是二进制也可以是文本.</p><p>命令有SEND, SUBSCRIBE, MESSAGE, CONNECT, CONNECTED等.</p><p>header类似http有content-length, content-type等.<br>消息体类似http可以是二进制也可以是文本.</p><p>下面例举一些主要命令<br>和http, websocket类似, 首先要确认双方都懂stomp这个协议, 通过建立连接来确认.<br>由于我们已经建立了webscoket连接, 接下来我只需要在webscoket连接的基础上建立stomp连接.</p><p>将以下内容写到websocket的payload中, 来发送建立stomp连接请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECT</span><br><span class="line">accept-version:1.2</span><br><span class="line">host:stomp.github.org</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>stomp协议并不与websocket协议耦合, 比如双方建立了tcp连接, 那么完成可以在tcp连接上建立stomp连接, 也就是将上述内容写到tcp的payload中.</p><p>server收到后回复, 同样以下内容是在server回复的websocket的消息体中</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONNECTED</span><br><span class="line">version:1.2 </span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>这样一个stomp连接就建立了, 协议版本为1.2.</p><p>由于stomp连接是一个长连接, stomp协议定义了发送心跳来监测stomp连接是否存活.</p><p>在CONNECT命令消息中加入heart-beat心跳header来建立连接就开启了心跳:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONNECT </span><br><span class="line">accept-version:1.2 </span><br><span class="line">heart-beat:&lt;cx&gt;,&lt;cy&gt; </span><br><span class="line">host:stomp.github.org </span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECTED </span><br><span class="line">version:1.2</span><br><span class="line">heart-beat:&lt;sx&gt;,&lt;sy&gt;</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>其中<code>&lt;cx&gt;, &lt;cy&gt;, &lt;sx&gt;, &lt;sy&gt;</code>分别代表一个以毫秒为单位的数字.</p><p>client发送的CONNECT命令消息中的<code>&lt;cx&gt;,&lt;cy&gt;</code>分别代表:</p><p><code>&lt;cx&gt;</code>:client能保证的发送心跳的最小间隔, 如果是0代表client不发送心跳.<br><code>&lt;cy&gt;</code>:client希望收到server心跳的间隔, 如果是0代表client不希望收到server的心跳.<br>与client类似, server发送的CONNECTED命令消息中的<sx>,<sy>分别代表:</p><p><code>&lt;sx&gt;</code>:server能保证的发送心跳的最小间隔, 如果是0代表server不发送心跳.</p><p><code>&lt;sy&gt;</code>:server希望收到client心跳的间隔, 如果是0代表server不希望收到client的心跳</p><p>如果在建立连接时没有心跳header, 默认当作heart-beat:0,0. 也就是不发心跳, 也不希望对方发心跳.</p><p>加入心跳header进行连接后, 最终协商得出发送心跳的频率的逻辑如下:<br>对于client来说, 取<cx>与<sy>的最大值, 也就是说client会取client最小能发送的间隔与server希望client发送间隔的最大值来发送心跳.<br>如果<cx>或<sy>中任何一个为0, client都不发送心跳.</p><p>类似, 对于server来说, 取<sx>与<cy>的最大值, 也就是说server取server最小能发送的间隔与client希望server发送间隔的最大值来发送心跳.<br>如果<sx>或<cy>中任何一个为0, server都不发送心跳.</p><p>举个例子, 如下建立连接</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONNECT</span><br><span class="line">accept-version:1.2</span><br><span class="line">heart-beat:1000,2000</span><br><span class="line">host:stomp.github.org</span><br><span class="line"></span><br><span class="line">^@123456</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECTED</span><br><span class="line">version:1.2</span><br><span class="line">heart-beat:3000,4000</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>上述, client发送CONNECT命令消息中heart-beat为1000, 2000.<br>解释为client最小能保证发送心跳间隔为1000毫秒, 希望server发送心跳间隔为2000毫秒</p><p>server回复的CONNECTED命令消息中heart-beat为3000,4000<br>解释为server最小能保证发送心跳间隔为3000毫秒, 希望client发送心跳间隔为4000毫秒</p><p>最终的协商结果, client取自己能保证的最小心跳间隔1000毫秒与server希望client发送心跳间隔4000毫秒的最大值<br>得出client会每4000毫秒发一次心跳,</p><p>同理, server取自己能保证的最小心跳间隔3000毫秒与client希望server发送心跳间隔2000毫秒的最大值<br>得出server会每3000毫秒发一次心跳.</p><p>client和server根据心跳来判定对方已经挂掉了的逻辑如下:</p><p>以server为例, 假设经过协商, client每10秒发送一个心跳.</p><p>client必须在10秒以内给server至少发送一次数据, 不管是心跳还是正常数据.<br>如果在10秒内client未发送数据, 那么server认为与client的stomp连接已经挂掉.<br>现在连接已经建立, 接下来准备发送stomp消息.</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>发送消息使用SEND这个COMMAND, 如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/topic/a </span><br><span class="line">content-type:text/plain </span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>其中destination这个header的值为发送消息的目的地址.<br>上述SEND命令消息的意思为, 给/topic/a这个目的地址发送一条类型为text/plain, 内容是hello world的消息.<br>所有订阅/topic/a这个目的地址的消费者client都会收到hello world这条消息.</p><blockquote><p>stomp协议并没有规定destination的格式, 这个是由使用stomp协议的应用自己来定义.<br>比如, /topic/a, /queue/a, queue.a, topic.a, topic-a, queue-a对于stomp协议来说都是正确的.<br>应用可以自己规定不同的格式以及此格式代表的含义.<br>比如, 应用自己可以定义以/topic打头的为发布订阅模式, 消息会被所有消费者client收到,<br>以/queue打头的为负载平衡模式, 只会被一个消费都client收到.</p></blockquote><p>client发送SEND命令消息如何确保server收到了这条消息呢?</p><p>协议规定, 可以在SEND命令消息中加入receipt header. receipt header的值唯一确定一次send.<br>server收到有receipt header的SEND命令消息后, 需要回复一个RECEIPT命令消息,<br>里面会包含receipt-id header, receipt-id的值就是SEND命令消息中receipt header的值.<br>这样当client收到了这条RECEIPT命令消息后, 就能确定server已收到SEND命令消息. 例如:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/queue/a</span><br><span class="line">receipt:message-12345</span><br><span class="line"></span><br><span class="line">hello queue a^@12345</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RECEIPT</span><br><span class="line">receipt-id:message-12345</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>接下来看一下消费者client如何订阅消息.</p><h4 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h4><p>订阅消息用SUBSCRIBE命令, 如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE </span><br><span class="line">id:0  </span><br><span class="line">destination:/topic/foo  </span><br><span class="line">ack:client </span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>上述代表client订阅/topic/foo这个目的地址.<br>其中多了两个新的header: id与ack.</p><p><strong>订阅中的id header</strong><br>此id能唯一确定一个订阅.<br>一个client对于一个server可以订阅多次, 甚至对于同一个目的地址都可以订阅多次.<br>为了唯一确定一次订阅, 协议规定必须包含id header, 此id要求在同一连接中唯一.</p><p><strong>订阅中的ack header</strong><br>ack header告诉server, server如何确认client已经收到消息.<br>有三个值: <code>auto</code>, <code>client</code>, <code>client-individual</code></p><p><code>auto</code>表示当server发出消息后就立即确认client收到了消息. 也就是说当<code>client</code>收到消息后不会对server进行确认.<br><code>client</code>表示只有当server收到client的ack后才确认client收到了消息, 也就是说client需要对server发ack进行确认.<br>这个确认是累积的, 意思是说收到某条消息的ack, 那么这条消息之前的所有的消息, server都认为client已收到.<br><code>client-individual</code>与client类似. 只不过不是累积的. 每收到一条消息都需要给server回复ack来确认.</p><p>有订阅消息, 那肯定有取消订阅消息.</p><h4 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h4><p>取消订阅用UNSUBSCRIBE这个命令</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UNSUBSCRIBE</span><br><span class="line">id:0</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>取消订阅相对来说比较简单只需要传一个id header.<br>这个id header的值来自订阅时id header值. 这样server才能唯一确定到底要取消哪个订阅.</p><p>当有生产者client给目的地址发消息后, 首先server会收到消息, server收到消息后会把消息发送给所有订阅这个目的地址的client, 那么server是如何发送这个消息到消费都client的呢?</p><h4 id="server发送消息"><a href="#server发送消息" class="headerlink" title="server发送消息"></a>server发送消息</h4><p>server发送消息用MESSAGE这个命令来给client发送消息, 如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">subscription:0</span><br><span class="line">message-id:007</span><br><span class="line">destination:/queue/a</span><br><span class="line">content-type:text/plain</span><br><span class="line"></span><br><span class="line">hello queue a^@</span><br></pre></td></tr></table></figure><p>message-id这个header的值能唯一确定一条消息<br>subscription的值就是订阅时SUBSCRIBE命令中id header的值, 表示这条消息属于哪个订阅.</p><p>到此, 介绍了一些stomp常用的命令, 还有一些其他命令, 有兴趣可以查看<a href="https://stomp.github.io/stomp-specification-1.2.html">stomp协议文档</a>:</p><h3 id="协议总结"><a href="#协议总结" class="headerlink" title="协议总结"></a>协议总结</h3><p>由于http是一个单工的协议, server不能主动发送消息给client, 导致http在处理实时性要求高的应用时效率不高.</p><p>为了提高效率, 我们使用了全双工的websocket协议, 可以让server主动推送消息.</p><p>又由于websocket协议是个底层协议, 不是应用层协议, 未对payload的格式进行规范, 导致我们需要自己定义消息体格式, 自己解析消息体, 成本高, 扩展性也不好, 所以我们引入了已被很多库和消息队列厂商实现的stomp协议, 将websocket协议与stomp协议结合.</p><p>我们再总结一下websocket与stomp的优点</p><h4 id="websocket相对于http的优点"><a href="#websocket相对于http的优点" class="headerlink" title="websocket相对于http的优点:"></a>websocket相对于http的优点:</h4><p>全双工. 相对于http协议只能由client发送消息. 全双工的websocket协议, server与client都可以发送消息.<br>消息体更轻量. http的一个请求比websocket的请求大不少. 主要因为http的每次请求都要加很多的header.</p><h4 id="stomp-over-websocket相对于websocket的优点"><a href="#stomp-over-websocket相对于websocket的优点" class="headerlink" title="stomp over websocket相对于websocket的优点:"></a>stomp over websocket相对于websocket的优点:</h4><p>不需要自己去规定消息的格式, 以及对消息的格式做解析.<br>由于stomp是一个统一的标准, 有很多库与厂商都对stomp协议进行了支持. 拿来用就可以. 成本低, 扩展好.<br>理论到此为止, 接下来我们一起了解下spring websocket是如何实现stomp over websocket协议的.</p><h2 id="Stomp使用文档-官方文档翻译版"><a href="#Stomp使用文档-官方文档翻译版" class="headerlink" title="Stomp使用文档(官方文档翻译版)"></a>Stomp使用文档(官方文档翻译版)</h2><p>STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议，它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。</p><h3 id="创建STOMP客户端"><a href="#创建STOMP客户端" class="headerlink" title="创建STOMP客户端"></a>创建<code>STOMP</code>客户端</h3><h4 id="在web浏览器中使用普通的Web-Socket"><a href="#在web浏览器中使用普通的Web-Socket" class="headerlink" title="在web浏览器中使用普通的Web Socket"></a>在web浏览器中使用普通的Web Socket</h4><p>　　STOMP javascript 客户端会使用<code>ws://</code>的URL与STOMP 服务端进行交互。</p><p>　　为了创建一个STOMP客户端js对象，你需要使用<code>Stomp.client(url)</code>，而这个URL连接着服务端的WebSocket的代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;ws://localhost:61614/stomp&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> client = Stomp.client(url);</span><br></pre></td></tr></table></figure><p><code>　　Stomp.client(url, protocols)</code>也可以用来覆盖默认的<code>subprotocols</code>。第二个参数可以是一个字符串或一个字符串数组去指定多个<code>subprotocols</code>。</p><h4 id="在web浏览器中使用定制的WebSocket"><a href="#在web浏览器中使用定制的WebSocket" class="headerlink" title="在web浏览器中使用定制的WebSocket"></a>在web浏览器中使用定制的WebSocket</h4><p>　　浏览器提供了不同的WebSocket的协议，一些老的浏览器不支持WebSocket的脚本或者使用别的名字。默认下，<code>stomp.js</code>会使用浏览器原生的<code>WebSocket class</code>去创建WebSocket。</p><p>　　但是利用<code>Stomp.over(ws)</code>这个方法可以使用其他类型的WebSockets。这个方法得到一个满足WebSocket定义的对象。</p><p>　　例如，可以使用由<code>SockJS</code>实现的Websocket。</p><p>　　如果使用原生的Websockets就使用<code>Stomp.client(url)</code>，如果需要使用其他类型的Websocket（例如由SockJS包装的Websocket）就使用<code>Stomp.over(ws)</code>。除了初始化有差别，Stomp API在这两种方式下是相同的。</p><h4 id="在node-js程序中"><a href="#在node-js程序中" class="headerlink" title="在node.js程序中"></a>在<code>node.js</code>程序中</h4><p>　　通过<code>stompjs npm package</code>同样也可以在<code>node.js</code>程序中使用这个库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install stompjs</span><br></pre></td></tr></table></figure><p>　　在node.js <code>app</code>中，<code>require</code>这个模块：<code>var Stomp = require(&#39;stompjs&#39;);</code></p><p>　　为了与建立在TCP socket的STOMP-broker连接，使用<code>Stomp.overTCP(host, port)</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = Stomp.overTCP(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">61613</span>);</span><br></pre></td></tr></table></figure><p>　　为了与建立在Web Socket的STOMP broker连接，使用<code>Stomp.overWS(url)</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = Stomp.overWS(<span class="string">&#x27;ws://localhost:61614/stomp&#x27;</span>);</span><br></pre></td></tr></table></figure><p>　　除了初始化不同，无论是浏览器还是node.js环境下，Stomp API都是相同的。</p><h3 id="连接服务端"><a href="#连接服务端" class="headerlink" title="连接服务端"></a>连接服务端</h3><p>　　一旦Stomp 客户端建立了，必须调用它的<code>connect()</code>方法去连接Stomp服务端进行验证。这个方法需要两个参数，用户的登录和密码凭证。这种情况下，客户端会使用Websocket打开连接，并发送一个<code>CONNECT frame</code>。</p><p>　　这个连接是异步进行的：你不能保证当这个方法返回时是有效连接的。为了知道连接的结果，你需要一个回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect_callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// called back after the client is connected and authenticated to the STOMP server</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　但是如果连接失败会发生什么呢？</p><p>　　<code>connect()</code>方法接受一个可选的参数(<code>error_callback</code>)，当客户端不能连接上服务端时，这个回调函数<code>error_callback</code>会被调用，该函数的参数为对应的错误对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var error_callback = function(error) &#123;</span><br><span class="line">    // display the error&#x27;s message header:</span><br><span class="line">    alert(error.headers.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　在大多数情况下，<code>connect()</code>方法可接受不同数量的参数来提供简单的API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.connect(login, passcode, connectCallback);</span><br><span class="line">client.connect(login, passcode, connectCallback, errorCallback);</span><br><span class="line">client.connect(login, passcode, connectCallback, errorCallback, host);</span><br></pre></td></tr></table></figure><p><code>　　login</code>和<code>passcode</code>是strings，<code>connectCallback</code>和<code>errorCallback</code>则是functions。（有些brokers（代理）还需要传递一个<code>host</code>（String类型）参数。）</p><p>　　如果你需要附加一个<code>headers</code>头部，<code>connect</code>方法还接受其他两种形式的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.connect(headers, connectCallback);</span><br><span class="line">client.connect(headers, connectCallback, errorCallback);</span><br></pre></td></tr></table></figure><p><code>　　header</code>是<code>map</code>形式，<code>connectCallback</code>和<code>errorCallback</code>为functions。</p><p>　　需要注意：如果你使用上述这种方式，你需要自行在<code>headers</code>添加<code>login</code>、<code>passcode</code>（甚至<code>host</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = &#123;</span><br><span class="line">    <span class="attr">login</span>: <span class="string">&#x27;mylogin&#x27;</span>,</span><br><span class="line">    <span class="attr">passcode</span>: <span class="string">&#x27;mypasscode&#x27;</span>,</span><br><span class="line">    <span class="comment">// additional header</span></span><br><span class="line">    <span class="string">&#x27;client-id&#x27;</span>: <span class="string">&#x27;my-client-id&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">client.connect(headers, connectCallback);</span><br></pre></td></tr></table></figure><p>　　断开连接时，调用<code>disconnect</code>方法，这个方法也是异步的，当断开成功后会接收一个额外的回调函数的参数。如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.disconnect(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;See you next time!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　当客户端与服务端断开连接，就不会再发送或接收消息了。</p><h3 id="Heart-beating-心跳"><a href="#Heart-beating-心跳" class="headerlink" title="Heart-beating(心跳)"></a>Heart-beating(心跳)</h3><p>　　如果STOMP broker(代理)接收STOMP 1.1版本的帧，<code>heart-beating</code>是默认启用的。</p><p>　　<code>heart-beating</code>也就是频率，<code>incoming</code>是接收频率，<code>outgoing</code>是发送频率。通过改变<code>incoming</code>和<code>outgoing</code>可以更改客户端的<code>heart-beating</code>(默认为10000ms)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client.heartbeat.outgoing = <span class="number">20000</span>; </span><br><span class="line"><span class="comment">// client will send heartbeats every 20000ms</span></span><br><span class="line">client.heartbeat.incoming = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// client does not want to receive heartbeats</span></span><br><span class="line"><span class="comment">// from the server</span></span><br></pre></td></tr></table></figure><p><code>　　heart-beating</code>是利用<code>window.setInterval()</code>去规律地发送<code>heart-beats</code>或者检查服务端的<code>heart-beats</code>。</p><h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><p>　　当客户端与服务端连接成功后，可以调用<code>send()</code>来发送STOMP消息。这个方法必须有一个参数，用来描述对应的STOMP的目的地。另外可以有两个可选的参数：<code>headers</code>，<code>object</code>类型包含额外的信息头部；<code>body</code>，一个String类型的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.send(<span class="string">&quot;/queue/test&quot;</span>, &#123;<span class="attr">priority</span>: <span class="number">9</span>&#125;, <span class="string">&quot;Hello, STOMP&quot;</span>);</span><br><span class="line"><span class="comment">// client会发送一个STOMP发送帧给/queue/test，这个帧包含一个设置了priority为9的header和内容为“Hello, STOMP”的body。</span></span><br></pre></td></tr></table></figure><p>　　如果你想发送一个有<code>body</code>的信息，也必须传递<code>headers</code>参数。如果没有<code>headers</code>需要传递，那么就传<code>&#123;&#125;</code>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.send(destination, &#123;&#125;, body);</span><br></pre></td></tr></table></figure><h3 id="订阅（Subscribe）和接收（receive）消息"><a href="#订阅（Subscribe）和接收（receive）消息" class="headerlink" title="订阅（Subscribe）和接收（receive）消息"></a>订阅（Subscribe）和接收（receive）消息</h3><p>　　为了在浏览器中接收消息，STOMP客户端必须先订阅一个目的地<code>destination</code>。</p><p>　　你可以使用<code>subscribe()</code>去订阅。这个方法有2个必需的参数：目的地(<code>destination</code>)，回调函数(<code>callback</code>)；还有一个可选的参数<code>headers</code>。其中<code>destination</code>是String类型，对应目的地，回调函数是伴随着一个参数的<code>function</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscription = client.subscribe(<span class="string">&quot;/queue/test&quot;</span>, callback);</span><br></pre></td></tr></table></figure><p><code>　　subscribe()</code>方法返回一个<code>object</code>，这个<code>object</code>包含一个<code>id</code>属性，对应这个这个客户端的订阅ID。</p><p>　　而<code>unsubscribe()</code>可以用来取消客户端对这个目的地<code>destination</code>的订阅。</p><p>　　默认情况下，如果没有在<code>headers</code>额外添加，这个库会默认构建一个独一无二的<code>ID</code>。在传递<code>headers</code>这个参数时，可以使用你自己的<code>ID</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysubid = <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> subscription = client.subscribe(destination, callback, &#123; <span class="attr">id</span>: mysubid &#125;);</span><br></pre></td></tr></table></figure><p>　　这个客户端会向服务端发送一个STOMP订阅帧（<code>SUBSCRIBE frame</code>）并注册回调事件。每次服务端向客户端发送消息时，客户端都会轮流调用回调函数，参数为对应消息的STOMP帧对象（<code>Frame object</code>）。</p><p><code>　　subscribe()</code>方法，接受一个可选的<code>headers</code>参数用来标识附加的头部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = &#123;<span class="attr">ack</span>: <span class="string">&#x27;client&#x27;</span>, <span class="string">&#x27;selector&#x27;</span>: <span class="string">&quot;location = &#x27;Europe&#x27;&quot;</span>&#125;;</span><br><span class="line">client.subscribe(<span class="string">&quot;/queue/test&quot;</span>, message_callback, headers);</span><br></pre></td></tr></table></figure><p>　　这个客户端指定了它会确认接收的信息，只接收符合这个<code>selector : location = &#39;Europe&#39;</code>的消息。</p><p>　　如果想让客户端订阅多个目的地，你可以在接收所有信息的时候调用相同的回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// called every time the client receives a message</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sub1 = client.subscribe(<span class="string">&quot;queue/test&quot;</span>, onmessage);</span><br><span class="line"><span class="keyword">var</span> sub2 = client.subscribe(<span class="string">&quot;queue/another&quot;</span>, onmessage)</span><br></pre></td></tr></table></figure><p>　　如果要中止接收消息，客户端可以在<code>subscribe()</code>返回的<code>object</code>对象调用<code>unsubscribe()</code>来结束接收。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscription = client.subscribe(...);</span><br><span class="line">...</span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure><h3 id="支持JSON"><a href="#支持JSON" class="headerlink" title="支持JSON"></a>支持JSON</h3><p>　　STOMP消息的<code>body</code>必须为字符串。如果你需要发送/接收<code>JSON</code>对象，你可以使用<code>JSON.stringify()</code>和<code>JSON.parse()</code>去转换JSON对象。</p><h3 id="确认-Acknowledgment"><a href="#确认-Acknowledgment" class="headerlink" title="确认(Acknowledgment)"></a>确认(Acknowledgment)</h3><p>　　默认情况，在消息发送给客户端之前，服务端会自动确认（<code>acknowledged</code>）。</p><p>　　客户端可以选择通过订阅一个目的地时设置一个<code>ack header</code>为<code>client</code>或<code>client-individual</code>来处理消息确认。</p><p>　　在下面这个例子，客户端必须调用<code>message.ack()</code>来通知服务端它已经接收了消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscription = client.subscribe(<span class="string">&quot;/queue/test&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do something with the message</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// and acknowledge it</span></span><br><span class="line">        message.ack();</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="attr">ack</span>: <span class="string">&#x27;client&#x27;</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>　ack()</code>接受<code>headers</code>参数用来附加确认消息。例如，将消息作为事务(transaction)的一部分，当要求接收消息时其实代理（broker）已经将<code>ACK STOMP frame</code>处理了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tx = client.begin();</span><br><span class="line">message.ack(&#123; <span class="attr">transaction</span>: tx.id, <span class="attr">receipt</span>: <span class="string">&#x27;my-receipt&#x27;</span> &#125;);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h3 id="事务-Transactions"><a href="#事务-Transactions" class="headerlink" title="事务(Transactions)"></a>事务(Transactions)</h3><p>　　可以在将消息的发送和确认接收放在一个事务中。</p><p>　　客户端调用自身的<code>begin()</code>方法就可以开始启动事务了，<code>begin()</code>有一个可选的参数<code>transaction</code>，一个唯一的可标识事务的字符串。如果没有传递这个参数，那么库会自动构建一个。这个方法会返回一个object。这个对象有一个<code>id</code>属性对应这个事务的ID，还有两个方法：</p><p>　　<code>commit()</code>提交事务</p><p>　　<code>abort()</code>中止事务</p><p>　　在一个事务中，客户端可以在发送/接受消息时指定transaction id来设置transaction。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start the transaction</span></span><br><span class="line"><span class="keyword">var</span> tx = client.begin();</span><br><span class="line"><span class="comment">// send the message in a transaction</span></span><br><span class="line">client.send(<span class="string">&quot;/queue/test&quot;</span>, &#123;<span class="attr">transaction</span>: tx.id&#125;, <span class="string">&quot;message in a transaction&quot;</span>);</span><br><span class="line"><span class="comment">// commit the transaction to effectively send the message</span></span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><p>　　如果你在调用<code>send()</code>方法发送消息的时候忘记添加transction header，那么这不会称为事务的一部分，这个消息会直接发送，不会等到事务完成后才发送。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txid = <span class="string">&quot;unique_transaction_identifier&quot;</span>;</span><br><span class="line"><span class="comment">// start the transaction</span></span><br><span class="line"><span class="keyword">var</span> tx = client.begin();</span><br><span class="line"><span class="comment">// oops! send the message outside the transaction</span></span><br><span class="line">client.send(<span class="string">&quot;/queue/test&quot;</span>, &#123;&#125;, <span class="string">&quot;I thought I was in a transaction!&quot;</span>);</span><br><span class="line">tx.abort(); <span class="comment">// Too late! the message has been sent</span></span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>　　有一些测试代码能有助于你知道库发送或接收的是什么，从而来调试程序。</p><p>　　客户端可以将其<code>debug</code>属性设置为一个函数，传递一个字符串参数去观察库所有的debug语句。默认情况，debug消息会被记录在在浏览器的控制台。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.debug = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// append the debug log to a #debug div somewhere in the page using JQuery:</span></span><br><span class="line">    $(<span class="string">&quot;#debug&quot;</span>).append(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error_callback = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">　　第一次连接失败和连接后断开连接都会调用这个函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关闭控制台调试数据：设置<code>client.debug = null</code> 就可以，stompjs会去检测debug是否是函数，不是函数就不会调用输出</p><h2 id="个人实例"><a href="#个人实例" class="headerlink" title="个人实例"></a>个人实例</h2><h3 id="跨域问题（之后专门写一个跨域）"><a href="#跨域问题（之后专门写一个跨域）" class="headerlink" title="跨域问题（之后专门写一个跨域）"></a>跨域问题（之后专门写一个跨域）</h3><p>首先我没有后端，用的github现成的<a href="https://github.com/anlingyi/xechat">Java项目</a>，所以需要做跨域请求，在Java中进行了跨域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册STOMP的节点，并映射指定的url</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册STOMP的endpoint，并指定使用SockJS协议</span></span><br><span class="line">    registry.addEndpoint(StompConstant.STOMP_ENDPOINT).setAllowedOrigins(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了<code>.setAllowedOrigins(&quot;*&quot;)</code>对所有端口开放</p><p>vue项目中做了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="attr">proxy</span>: &#123;  <span class="comment">//配置跨域</span></span><br><span class="line"><span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line"><span class="attr">target</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,<span class="comment">// 实际访问地址和端口号</span></span><br><span class="line"><span class="attr">ws</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">changOrigin</span>: <span class="literal">true</span>,  <span class="comment">//允许跨域</span></span><br><span class="line"><span class="attr">pathRewrite</span>: &#123;</span><br><span class="line"><span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span><span class="comment">// 使用/api代替Target</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用/api替代实际访问地址</p><h3 id="连接服务器并配置心跳"><a href="#连接服务器并配置心跳" class="headerlink" title="连接服务器并配置心跳"></a>连接服务器并配置心跳</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">connect () &#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">&#x27;/api/xechat&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.stompClient = Stomp.over(socket);</span><br><span class="line">    <span class="comment">// 配置stomp</span></span><br><span class="line">    <span class="comment">// 心跳</span></span><br><span class="line">    <span class="built_in">this</span>.stompClient.heartbeat.outgoing = <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">// 客户端不接受服务器心跳检测</span></span><br><span class="line">    <span class="built_in">this</span>.stompClient.heartbeat.incoming = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 订阅地址</span></span><br><span class="line">    <span class="built_in">this</span>.sub();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>CONNECT发送连接服务器请求，CONNECTED服务器返回连接情况</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711212936.png"></p><h3 id="订阅服务器地址"><a href="#订阅服务器地址" class="headerlink" title="订阅服务器地址"></a>订阅服务器地址</h3><p>订阅了四个地址，并在连接成功后返回信息，进行广播</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sub () &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="built_in">this</span>.createUser();</span><br><span class="line">    <span class="built_in">this</span>.stompClient.connect(user, <span class="function"><span class="keyword">function</span> <span class="title">connectCallback</span> (<span class="params">frame</span>) </span>&#123;</span><br><span class="line">        _this.uid = frame.headers[<span class="string">&#x27;user-name&#x27;</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功&#x27;</span>)</span><br><span class="line">        <span class="comment">// 聊天室订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/topic/chatRoom&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;订阅成功&#x27;</span>)</span><br><span class="line">            _this.handleMessage(_this.getData(data.body));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/user/&#x27;</span> + _this.uid + <span class="string">&#x27;/chat&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            _this.handleMessage(_this.getData(data.body));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误信息订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/user/&#x27;</span> + _this.uid + <span class="string">&#x27;/error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            _this.getData(data.body);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 聊天室动态订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/topic/status&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = _this.getData(data.body);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;看这里&#x27;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(obj)</span><br><span class="line">            _this.handleMessage(obj);</span><br><span class="line">            _this.showOnlineNum(obj.onlineCount);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> <span class="title">errorCallBack</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;请重新连接！&#x27;</span>);</span><br><span class="line">        _this.refresh();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>成功订阅并接受到广播信息  SUBSCRIBE订阅地址</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711213722.png"></p><p>实现进入效果</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711213748.png"></p><h3 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sendMessage (pub, header, data) &#123;</span><br><span class="line">    <span class="built_in">this</span>.stompClient.send(pub, header, data);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//发送信息到聊天室</span></span><br><span class="line">sendToChatRoom () &#123;</span><br><span class="line">    <span class="comment">// 获取发送的内容</span></span><br><span class="line">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;sendTxt&#x27;</span>).value;</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: content</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> pub = <span class="string">&#x27;/chatRoom&#x27;</span>;</span><br><span class="line">    data = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    <span class="built_in">this</span>.sendMessage(pub, &#123;&#125;, data);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>SEND发送 MESSAGE接收到广播信息</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711214258.png"></p><p>实现效果</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711214306.png"></p><h3 id="等待补充"><a href="#等待补充" class="headerlink" title="等待补充"></a>等待补充</h3><p>1.断开自动刷新连接服务器</p><p>2.中断订阅地址</p><p>3.对事务的理解</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://stomp.github.io/">Stomp官方文档</a></p><p><a href="https://www.cnblogs.com/goloving/p/10746378.html">StompJS使用文档总结</a></p><p><a href="https://blog.csdn.net/a617137379/article/details/78765025">stomp over websocket协议原理与实现</a></p>]]></content>
    
    
    <summary type="html">Stomp协议的原理和基础实现</summary>
    
    
    
    
    <category term="html&amp;浏览器" scheme="https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="协议" scheme="https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://andylinwenqin.github.io/2021/07/02/Web-Socket/"/>
    <id>https://andylinwenqin.github.io/2021/07/02/Web-Socket/</id>
    <published>2021-07-02T04:11:54.000Z</published>
    <updated>2021-07-17T04:18:57.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket-教程"><a href="#WebSocket-教程" class="headerlink" title="WebSocket 教程"></a>WebSocket 教程</h1><hr><p><a href="https://websocket.org/">WebSocket</a> 是一种网络通信协议，很多高级功能都需要它。</p><p>本文介绍 WebSocket 协议的使用方法。</p><h2 id="为什么需要-WebSocket？"><a href="#为什么需要-WebSocket？" class="headerlink" title="为什么需要 WebSocket？"></a>为什么需要 WebSocket？</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702153804.jpg"></p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<a href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”</a>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154116.png"></p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154224.jpg"></p><h2 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h2><p>WebSocket 的用法相当简单。</p><p>下面是一个网页脚本的例子（点击<a href="http://jsbin.com/muqamiqimu/edit?js,console">这里</a>看运行结果），基本上一眼就能明白。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://echo.websocket.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure></blockquote><h2 id="客户端的-API"><a href="#客户端的-API" class="headerlink" title="客户端的 API"></a>客户端的 API</h2><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">这里</a>。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p><blockquote><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul></blockquote><p>下面是一个示例。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果要指定多个回调函数，可以使用<code>addEventListener</code>方法。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象）。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received data string&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received arraybuffer&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send()"></a>webSocket.send()</h3><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p><p>发送文本的例子。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">&#x27;your message&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><p>发送 Blob 对象的例子。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure></blockquote><p>发送 ArrayBuffer 对象的例子。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>WebSocket 服务器的实现，可以查看维基百科的<a href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表</a>。</p><p>常用的 Node 实现有以下三种。</p><ul><li><a href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li><li><a href="http://socket.io/">Socket.IO</a></li><li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li></ul><p>具体的用法请查看它们的文档，这里不详细介绍了。</p><h2 id="WebSocketd"><a href="#WebSocketd" class="headerlink" title="WebSocketd"></a>WebSocketd</h2><p>下面，我要推荐一款非常特别的 WebSocket 服务器：<a href="http://websocketd.com/">Websocketd</a>。</p><p>它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154529.png"></p><p>举例来说，下面是一个 Bash 脚本<code>counter.sh</code>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 2</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 3</span><br></pre></td></tr></table></figure></blockquote><p>命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash ./counter.sh</span><br></pre></td></tr></table></figure></blockquote><p>现在，启动<code>websocketd</code>，指定这个脚本作为服务。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 bash ./counter.sh</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令会启动一个 WebSocket 服务器，端口是<code>8080</code>。每当客户端连接这个服务器，就会执行<code>counter.sh</code>脚本，并将它的输出推送给客户端。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。</p><p>有了它，就可以很方便地将命令行的输出，发给浏览器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 ls</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令会执行<code>ls</code>命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（<a href="https://github.com/joewalnes/web-vmstats">代码</a>）。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154601.jpg"></p><p>更多的用法可以参考<a href="https://github.com/joewalnes/websocketd/tree/master/examples/bash">官方示例</a>。</p><blockquote><ul><li>Bash 脚本<a href="https://github.com/joewalnes/websocketd/blob/master/examples/bash/greeter.sh">读取客户端输入</a>的例子</li><li>五行代码实现一个最简单的<a href="https://github.com/joewalnes/websocketd/blob/master/examples/bash/chat.sh">聊天服务器</a></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154728.png"></p><p>websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务<a href="https://github.com/joewalnes/websocketd/blob/master/examples/nodejs/greeter.js"><code>greeter.js</code></a>。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">&#x27;data: &#x27;</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>启动这个脚本的命令如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 node ./greeter.js</span><br></pre></td></tr></table></figure></blockquote><p>官方仓库还有其他<a href="https://github.com/joewalnes/websocketd/tree/master/examples">各种语言</a>的例子。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="http://cjihrig.com/blog/how-to-use-websockets/">How to Use WebSockets</a></p></li><li><p><a href="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">WebSockets - Send &amp; Receive Messages</a></p></li><li><p><a href="https://www.html5rocks.com/en/tutorials/websockets/basics/">Introducing WebSockets: Bringing Sockets to the Web</a></p></li><li><p>本文来自<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰的 WebSocker</a>仅作为学习使用</p></li></ul>]]></content>
    
    
    <summary type="html">WebSocket网络协议的基础概念和协议用法</summary>
    
    
    
    
    <category term="html&amp;浏览器" scheme="https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="协议" scheme="https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>mini-vue</title>
    <link href="https://andylinwenqin.github.io/2021/06/27/mini-vue/"/>
    <id>https://andylinwenqin.github.io/2021/06/27/mini-vue/</id>
    <published>2021-06-27T09:14:43.000Z</published>
    <updated>2021-09-04T05:33:38.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mini-vue"><a href="#mini-vue" class="headerlink" title="mini-vue"></a>mini-vue</h1><hr><h2 id="实现一个-mini-vue-之-vdom"><a href="#实现一个-mini-vue-之-vdom" class="headerlink" title="实现一个 mini-vue 之 vdom"></a>实现一个 mini-vue 之 vdom</h2><p><a href="https://www.bilibili.com/video/BV1rC4y187Vw?p=1">B 站传送门 (opens new window)</a>vue 总共包含三大部分:</p><ul><li>模板编译</li><li>虚拟 dom</li><li>响应式 api</li></ul><p>这篇文章主要很简单的实现一下虚拟 dom 部分</p><h3 id="h-函数"><a href="#h-函数" class="headerlink" title="#h 函数"></a><a href="https://dafunk.gitee.io/views/vue/mini-vue-vdom.html#h-%E5%87%BD%E6%95%B0">#</a>h 函数</h3><p>h 函数很简单,就是返回一个 js 对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>mount 函数接受两个参数,第一个是虚拟节点也就是 h 函数生成的 vnode,第二个是要挂载到的真实 dom 节点. mount 的主要作用是将虚拟节点挂载到真实 dom 节点上,也不是很复杂.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; tag, props, children &#125; = vnode;</span><br><span class="line">  <span class="comment">//这里要将生成的真实dom节点保存到vnode上</span></span><br><span class="line">  <span class="keyword">const</span> el = (vnode.el = <span class="built_in">document</span>.createElement(tag));</span><br><span class="line">  <span class="comment">//添加dom属性</span></span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = props[key];</span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        el.addEventListener(key.slice(<span class="number">2</span>).toLowerCase(), value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.setAttribute(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加子节点</span></span><br><span class="line">  <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">          el.append(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">//child是一个对象时,说明child是一个元素节点</span></span><br><span class="line">          <span class="comment">//这时就要递归调用mount</span></span><br><span class="line">          mount(child, el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.append(children);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.append(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>虚拟 dom 部分里最复杂的就是 patch 函数,这个函数的作用是,比对两个虚拟节点, 进行 diff 算法,从而实现最小量更新,也就是尽可能的减少对真实 dom 的操作,因为操作真实 dom 的性能开销远大于操作 js 对象,这也是 vue 使用虚拟 dom 的原因之一.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n1.tag === n2.tag) &#123;</span><br><span class="line">    <span class="comment">//这个分支为新旧节点tag类型相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要将真实dom节点el,在每次patch时向后传递,保证每次更新的都是</span></span><br><span class="line">    <span class="comment">//这个节点.</span></span><br><span class="line">    <span class="keyword">const</span> el = (n2.el = n1.el);</span><br><span class="line">    <span class="comment">//diff props</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.props || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.props || &#123;&#125;;</span><br><span class="line">    <span class="comment">//添加新的属性或更改原来已有但变化了的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key];</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key];</span><br><span class="line">      <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">        el.setAttribute(key, newValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除新属性中没有的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.removeAttribute(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//diff children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.children;</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.children;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在diff children的时候,有四个主要分支</span></span><br><span class="line">    <span class="comment">// 1.新老都是string</span></span><br><span class="line">    <span class="comment">// 2.新: array 老: string</span></span><br><span class="line">    <span class="comment">// 3.新: string 老: array</span></span><br><span class="line">    <span class="comment">// 4.新老都是array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//情况1</span></span><br><span class="line">        <span class="keyword">if</span> (oldChildren !== newChildren) &#123;</span><br><span class="line">          el.innerHTML = newChildren;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//情况3</span></span><br><span class="line">        el.innerHTML = newChildren;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      <span class="comment">//情况2</span></span><br><span class="line">      el.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      newChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> mount(child, el));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(oldChildren) &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      <span class="comment">//情况4 是最复杂的情况</span></span><br><span class="line">      <span class="comment">//这里简单起见并没有真正实现vue中的diff算法,而是选取了一个低效但</span></span><br><span class="line">      <span class="comment">//容易理解的算法,但其实vue中如果不给元素提供key的话,也会使用这个</span></span><br><span class="line">      <span class="comment">//算法,这个算法在子元素的tag不会变的情况下非常高效,但如果tag会变</span></span><br><span class="line">      <span class="comment">//则会因为不必要的创造和删除节点,而变得不那么高效.</span></span><br><span class="line">      <span class="keyword">const</span> minLength = <span class="built_in">Math</span>.min(oldChildren.length, newChildren.length);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">        patch(oldChildren[i], newChildren[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//老的children长度较小,则说明要添加节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldChildren.length === minLength) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">          mount(newChildren[i], el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之,则说明要删除节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; oldChildren.length; i++) &#123;</span><br><span class="line">          el.removeChild(oldChildren[i].el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//标签类型不同时需要用新节点替换节点</span></span><br><span class="line">    <span class="comment">//这里并没有实现😂</span></span><br><span class="line">    <span class="comment">//回头再补</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="实现一个-mini-vue-之-reactive"><a href="#实现一个-mini-vue-之-reactive" class="headerlink" title="实现一个 mini-vue 之 reactive"></a>实现一个 mini-vue 之 reactive</h2><p>简单的实现一下 vue3 的响应式原理核心</p><h3 id="Dep-类"><a href="#Dep-类" class="headerlink" title="Dep 类"></a>Dep 类</h3><p>要理解 vue 响应式原理,首先要明白 Dep 类是干什么的.</p><p>Dep 故名思意,就是依赖的意思. 为什么叫依赖,因为视图的变化,实际上是数据的变化所导致的. 所以现在数据就是视图的依赖.</p><p>现在我们假设视图的变化是由一个神奇的函数 render 的调用的结果也就是 <code>view = render(data)</code>.</p><p>现在我们在 data 变化时想改变视图,就要手动调用这个函数,而响应式就是要避免这个操作.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dep类的实例就是依赖</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//在构造函数里传入了value,这时dep同时也是数据的载体</span></span><br><span class="line">    <span class="built_in">this</span>._value = value;</span><br><span class="line">    <span class="comment">//这里dep保存着它的订阅者,注意是set,意味着不能重复</span></span><br><span class="line">    <span class="built_in">this</span>.subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过js特性对象数据访问器getter和setter,</span></span><br><span class="line">  <span class="comment">//进行订阅者的注册和依赖改变后副作用的执行,也就是发布</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">//get时注册订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.depend();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = newValue;</span><br><span class="line">    <span class="comment">//set后通知订阅者,执行副作用</span></span><br><span class="line">    <span class="built_in">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//这里的activeEffect为全局变量,指向当前要被注册的订阅者</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.add(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//执行所有副作用,也就是订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这步赋值置空的操作,保证了只能在watchEffect中进行订阅者的注册</span></span><br><span class="line">  activeEffect = effect;</span><br><span class="line">  effect();</span><br><span class="line">  activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">        Copied!</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="keyword">new</span> Dep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count.value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">count.value++; <span class="comment">// log 2</span></span><br><span class="line">count.value++; <span class="comment">// log 3</span></span><br><span class="line">count.value++; <span class="comment">// log 4</span></span><br><span class="line">count.value = <span class="number">15</span>; <span class="comment">// log 15</span></span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>在 Dep 类中了解了 vue 中基本的响应式原理后,对 reactive-api 就好理解了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dep类和当前要注册的订阅者</span></span><br><span class="line"><span class="comment">//和上面的区别是,这里Dep不再是数据的载体</span></span><br><span class="line"><span class="comment">//而只负责整个发布订阅过程</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.add(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect;</span><br><span class="line">  effect();</span><br><span class="line">  activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们从上到下看</span></span><br><span class="line"><span class="comment">//reactive接收一个原始的对象</span></span><br><span class="line"><span class="comment">//返回一个原始对象的代理</span></span><br><span class="line"><span class="comment">// Proxy(target, handler)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reactiveHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//依旧是get时进行订阅者的注册</span></span><br><span class="line">    <span class="comment">//问题是我的dep从哪获取,这里暂时认为getDep帮我拿到了</span></span><br><span class="line">    <span class="comment">//这个target和这个key对应的dep</span></span><br><span class="line">    <span class="comment">//这里为了简单起见,没有处理深层嵌套对象的响应式转换</span></span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//set时触发所有副作用</span></span><br><span class="line">    <span class="comment">//同样需要获得对应的dep</span></span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    dep.notify();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后我们看是如何获取对应的dep的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  我们先搞明白一个对应关系</span></span><br><span class="line"><span class="comment">  target是个对象,对应着一组key, value,</span></span><br><span class="line"><span class="comment">  dep的depend和notify操作,就是在对target[key], </span></span><br><span class="line"><span class="comment">  get和set时进行的,dep储存着所有订阅者,所以一个key</span></span><br><span class="line"><span class="comment">  对应着一个dep,这个数据结构可以使用Map储存这一组key,value.</span></span><br><span class="line"><span class="comment">  而前面我们知道,一个target对应着一组key,value,所以这个</span></span><br><span class="line"><span class="comment">  数据结构也是一个Map(这里考虑到垃圾回收使用了WeakMap).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!targetMap.has(target)) &#123;</span><br><span class="line">    targetMap.set(target, <span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> depMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depMap.has(key)) &#123;</span><br><span class="line">    depMap.set(key, <span class="keyword">new</span> Dep());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depMap.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个-mini-vue"><a href="#实现一个-mini-vue" class="headerlink" title="实现一个 mini-vue"></a>实现一个 mini-vue</h2><p>我们来执行最后一步,将前面的函数进行组合,得到最终可以运行的 mini-vue.</p><p>先将之前所有的代码复制过来.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vdom部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; tag, props, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = (vnode.el = <span class="built_in">document</span>.createElement(tag));</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = props[key];</span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        el.addEventListener(key.slice(<span class="number">2</span>).toLowerCase(), value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.setAttribute(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">          el.append(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">          mount(child, el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.append(children);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.append(el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n1.tag === n2.tag) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = (n2.el = n1.el);</span><br><span class="line">    <span class="comment">//diff props</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.props || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.props || &#123;&#125;;</span><br><span class="line">    <span class="comment">//添加新的属性或更改原来已有但变化了的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key];</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key];</span><br><span class="line">      <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">        el.setAttribute(key, newValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除新属性中没有的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.removeAttribute(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//diff children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.children;</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldChildren !== newChildren) &#123;</span><br><span class="line">          el.innerHTML = newChildren;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      el.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      newChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> mount(child, el));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(oldChildren) &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      <span class="keyword">const</span> minLength = <span class="built_in">Math</span>.min(oldChildren.length, newChildren.length);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">        patch(oldChildren[i], newChildren[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (oldChildren.length === minLength) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">          mount(newChildren[i], el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; oldChildren.length; i++) &#123;</span><br><span class="line">          el.removeChild(oldChildren[i].el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//replace</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reactivity部分</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.add(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect;</span><br><span class="line">  effect();</span><br><span class="line">  activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!targetMap.has(target)) &#123;</span><br><span class="line">    targetMap.set(target, <span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> depMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depMap.has(key)) &#123;</span><br><span class="line">    depMap.set(key, <span class="keyword">new</span> Dep());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depMap.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reactiveHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// dep</span></span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    dep.notify();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="mountApp"><a href="#mountApp" class="headerlink" title="mountApp"></a>mountApp</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//component组件实例</span></span><br><span class="line"><span class="comment">//container要挂载的dom元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountApp</span>(<span class="params">component, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isMounted = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> oldVdom;</span><br><span class="line">  watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">      <span class="comment">//第一次挂载</span></span><br><span class="line">      oldVdom = component.render();</span><br><span class="line">      mount(oldVdom, container);</span><br><span class="line">      isMounted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//数据变化,要进行更新</span></span><br><span class="line">      <span class="keyword">const</span> newVdom = component.render();</span><br><span class="line">      patch(oldVdom, newVdom);</span><br><span class="line">      oldVdom = newVdom;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  <span class="attr">data</span>: reactive(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: <span class="function">() =&gt;</span> App.data.count++,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">String</span>(<span class="built_in">this</span>.data.count)</span><br><span class="line">      ),</span><br><span class="line">    ]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一个点击自增的计数器</span></span><br><span class="line">mountApp(App, <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>));</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">根据尤大的教学视频实现 mini-vue 包括diff算法，订阅者模式等等</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue的diff算法</title>
    <link href="https://andylinwenqin.github.io/2021/06/27/Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    <id>https://andylinwenqin.github.io/2021/06/27/Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/</id>
    <published>2021-06-27T08:49:57.000Z</published>
    <updated>2021-06-27T09:17:16.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue如何操作节点及diff算法"><a href="#Vue如何操作节点及diff算法" class="headerlink" title="Vue如何操作节点及diff算法"></a>Vue如何操作节点及diff算法</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="当数据发生变化时，vue是怎么更新节点的？"><a href="#当数据发生变化时，vue是怎么更新节点的？" class="headerlink" title="当数据发生变化时，vue是怎么更新节点的？"></a>当数据发生变化时，vue是怎么更新节点的？</h3><p>要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。</p><p>我们先根据真实DOM生成一颗<code>virtual DOM</code>，当<code>virtual DOM</code>某个节点的数据改变后会生成一个新的<code>Vnode</code>，然后<code>Vnode</code>和<code>oldVnode</code>作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使<code>oldVnode</code>的值为<code>Vnode</code>。</p><p>diff的过程就是调用名为<code>patch</code>的函数，比较新旧节点，一边比较一边给<strong>真实的DOM</strong>打补丁。</p><h3 id="virtual-DOM和真实DOM的区别？"><a href="#virtual-DOM和真实DOM的区别？" class="headerlink" title="virtual DOM和真实DOM的区别？"></a>virtual DOM和真实DOM的区别？</h3><p>virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的virtual DOM（伪代码）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vnode = &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;123&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（温馨提示：<code>VNode</code>和<code>oldVNode</code>都是对象，一定要记住）</p><h3 id="diff的比较方式？"><a href="#diff的比较方式？" class="headerlink" title="diff的比较方式？"></a>diff的比较方式？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>456<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170145.png"></p><h3 id="diff流程图"><a href="#diff流程图" class="headerlink" title="diff流程图"></a>diff流程图</h3><p>当数据发生改变时，set方法会让调用<code>Dep.notify</code>通知所有订阅者Watcher，订阅者就会调用<code>patch</code>给真实的DOM打补丁，更新相应的视图。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170223.png"></p><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>来看看<code>patch</code>是怎么打补丁的（代码只保留核心部分）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">    <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        patchVnode(oldVnode, vnode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> oEl = oldVnode.el <span class="comment">// 当前oldVnode对应的真实元素节点</span></span><br><span class="line">        <span class="keyword">let</span> parentEle = api.parentNode(oEl)  <span class="comment">// 父元素</span></span><br><span class="line">        createEle(vnode)  <span class="comment">// 根据Vnode生成新元素</span></span><br><span class="line">        <span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</span><br><span class="line">            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) <span class="comment">// 将新元素添加进父元素</span></span><br><span class="line">            api.removeChild(parentEle, oldVnode.el)  <span class="comment">// 移除以前的旧元素节点</span></span><br><span class="line">            oldVnode = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// some code </span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>patch函数接收两个参数<code>oldVnode</code>和<code>Vnode</code>分别代表新的节点和之前的旧节点</p><ul><li>判断两节点是否值得比较，值得比较则执行<code>patchVnode</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;  <span class="comment">// key值</span></span><br><span class="line">    a.tag === b.tag &amp;&amp;  <span class="comment">// 标签名</span></span><br><span class="line">    a.isComment === b.isComment &amp;&amp;  <span class="comment">// 是否为注释节点</span></span><br><span class="line">    <span class="comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span></span><br><span class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;  </span><br><span class="line">    sameInputType(a, b) <span class="comment">// 当标签是&lt;input&gt;的时候，type必须相同</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不值得比较则用<code>Vnode</code>替换<code>oldVnode</code></li></ul><p>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明<code>Vnode</code>完全被改变了，就可以直接替换<code>oldVnode</code>。</p><p>虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。</p><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>当我们确定两个节点值得比较之后我们会对两个节点指定<code>patchVnode</code>方法。那么这个方法做了什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">patchVnode (oldVnode, vnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = vnode.el = oldVnode.el</span><br><span class="line">    <span class="keyword">let</span> i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode.text !== <span class="literal">null</span> &amp;&amp; vnode.text !== <span class="literal">null</span> &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        api.setTextContent(el, vnode.text)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        updateEle(el, vnode, oldVnode)</span><br><span class="line">        <span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class="line">            updateChildren(el, oldCh, ch)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch)&#123;</span><br><span class="line">            createEle(vnode) <span class="comment">//create el&#x27;s children dom</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldCh)&#123;</span><br><span class="line">            api.removeChildren(el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数做了以下事情：</p><ul><li>找到对应的真实dom，称为<code>el</code></li><li>判断<code>Vnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li><li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>Vnode</code>的文本节点。</li><li>如果<code>oldVnode</code>有子节点而<code>Vnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>Vnode</code>有，则将<code>Vnode</code>的子节点真实化之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li></ul><p>其他几个点都很好理解，我们详细来讲一下updateChildren</p><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx</span><br><span class="line">    <span class="keyword">let</span> idxInOld</span><br><span class="line">    <span class="keyword">let</span> elmToMove</span><br><span class="line">    <span class="keyword">let</span> before</span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;   <span class="comment">// 对于vnode.key的比较，会把oldVnode = null</span></span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx] </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode)</span><br><span class="line">            api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode)</span><br><span class="line">            api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 使用key时的比较</span></span><br><span class="line">            <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) <span class="comment">// 有key生成index表</span></span><br><span class="line">            &#125;</span><br><span class="line">            idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">            <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">                api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                elmToMove = oldCh[idxInOld]</span><br><span class="line">                <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    patchVnode(elmToMove, newStartVnode)</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">null</span></span><br><span class="line">                    api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)</span><br><span class="line">                &#125;</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        before = newCh[newEndIdx + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].el</span><br><span class="line">        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说一下这个函数做了什么</p><ul><li>将<code>Vnode</code>的子节点<code>Vch</code>和<code>oldVnode</code>的子节点<code>oldCh</code>提取出来</li><li><code>oldCh</code>和<code>vCh</code>各有两个头尾的变量<code>StartIdx</code>和<code>EndIdx</code>，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了<code>key</code>，就会用<code>key</code>进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx&gt;EndIdx</code>表明<code>oldCh</code>和<code>vCh</code>至少有一个已经遍历完了，就会结束比较。</li></ul><h4 id="图解updateChildren"><a href="#图解updateChildren" class="headerlink" title="图解updateChildren"></a>图解updateChildren</h4><p>终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。</p><p>粉红色的部分为oldCh和vCh</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170936.png"></p><p>我们将它们取出来并分别用s和e指针指向它们的头child和尾child</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170958.png"></p><p>现在分别对<code>oldS、oldE、S、E</code>两两做<code>sameVnode</code>比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方</p><ul><li>如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后</li><li>如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动</li><li>如果四种匹配没有一对是成功的，那么遍历<code>oldChild</code>，<code>S</code>挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将<code>S对应的节点</code>插入到dom中对应的<code>oldS</code>位置，<code>oldS</code>和<code>S</code>指针向中间移动。</li></ul><p>再配个图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171028.png"></p><ul><li>第一步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldS = a, oldE = d；</span><br><span class="line">S = a, E = b;</span><br></pre></td></tr></table></figure><p><code>oldS</code>和<code>S</code>匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d</p><ul><li>第二步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldS = b, oldE = d；</span><br><span class="line">S = c, E = b;</span><br></pre></td></tr></table></figure><p><code>oldS</code>和<code>E</code>匹配，就将原本的b节点移动到最后，因为<code>E</code>是最后一个节点，他们位置要一致，这就是上面说的：<strong>当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置</strong>，此时dom的位置为：a d b</p><ul><li>第三步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldS = d, oldE = d；</span><br><span class="line">S = c, E = d;</span><br></pre></td></tr></table></figure><p><code>oldE</code>和<code>E</code>匹配，位置不变此时dom的位置为：a d b</p><ul><li>第四步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oldS++;</span><br><span class="line">oldE--;</span><br><span class="line">oldS &gt; oldE;</span><br></pre></td></tr></table></figure><p>遍历结束，说明<code>oldCh</code>先遍历完。就将剩余的<code>vCh</code>节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b</p><p>一次模拟完成。</p><p>这个匹配过程的结束有两个条件：</p><ul><li><code>oldS &gt; oldE</code>表示<code>oldCh</code>先遍历完，那么就将多余的<code>vCh</code>根据index添加到dom中去（如上图）</li><li><code>S &gt; E</code>表示vCh先遍历完，那么就在真实dom中将区间为<code>[oldS, oldE]</code>的多余节点删掉(本图第二第三步画错了应该对换位置)</li></ul><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171110.png"></p><p>下面再举一个例子，可以像上面那样自己试着模拟一下</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171120.png"></p><p>当这些节点<code>sameVnode</code>成功后就会紧接着执行<code>patchVnode</code>了，可以看一下上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。也将dom的所有补丁都打好啦。那么现在再回过去看updateChildren的代码会不会容易很多呢？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上为diff算法的全部过程，放上一张文章开始就发过的总结图，可以试试看着这张图回忆一下diff的过程。</p><p> <img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171154.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文摘抄自<a href="https://www.cnblogs.com/wind-lanyan/p/9061684.html">详解vue的diff算法</a></p><p><a href="">尤大的mini-vue</a></p>]]></content>
    
    
    <summary type="html">了解vue如何进行更新节点的</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SPA单页面应用和多页应用优缺点</title>
    <link href="https://andylinwenqin.github.io/2021/06/27/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    <id>https://andylinwenqin.github.io/2021/06/27/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/</id>
    <published>2021-06-27T08:42:42.000Z</published>
    <updated>2021-06-27T08:55:06.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPA单页应用"><a href="#SPA单页应用" class="headerlink" title="SPA单页应用"></a>SPA单页应用</h2><hr><p>其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。</p><p><strong>优 点</strong>: 减轻服务端的压力，可维护性高</p><p><strong>缺点</strong>: 首次加载速度慢，搜索引擎优化效果不好</p><h3 id="为什么首屏时间慢，SEO-差？"><a href="#为什么首屏时间慢，SEO-差？" class="headerlink" title="为什么首屏时间慢，SEO 差？"></a>为什么首屏时间慢，SEO 差？</h3><p>单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。</p><p>SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。</p><h2 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h2><p>多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SPA单页应用&quot;&gt;&lt;a href=&quot;#SPA单页应用&quot; class=&quot;headerlink&quot; title=&quot;SPA单页应用&quot;&gt;&lt;/a&gt;SPA单页应用&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaS</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
