<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andylin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/d2d617c7604cf8dda9f78dd0f6fa3899</icon>
  <subtitle>永无止境，奋斗不息</subtitle>
  <link href="https://andylinwenqin.github.io/atom.xml" rel="self"/>
  
  <link href="https://andylinwenqin.github.io/"/>
  <updated>2021-09-12T07:28:03.140Z</updated>
  <id>https://andylinwenqin.github.io/</id>
  
  <author>
    <name>林文钦</name>
    <email>andylin0119@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git拉去远端所有分支</title>
    <link href="https://andylinwenqin.github.io/2021/09/12/Git%E6%8B%89%E5%8E%BB%E8%BF%9C%E7%AB%AF%E6%89%80%E6%9C%89%E5%88%86%E6%94%AF/"/>
    <id>https://andylinwenqin.github.io/2021/09/12/Git%E6%8B%89%E5%8E%BB%E8%BF%9C%E7%AB%AF%E6%89%80%E6%9C%89%E5%88%86%E6%94%AF/</id>
    <published>2021-09-12T06:15:20.000Z</published>
    <updated>2021-09-12T07:28:03.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h1><p>git clone 默认只克隆github上面设置的默认分支，（如果没有修改，默认就是master分支），那如果需要把所有分支都克隆下来该怎么办呢？</p><p>分析<br>我们最常用的克隆命令应该是这个:<code>git clone &lt;url&gt;</code>；</p><p>按照上面的理解，这个命令其实是下面命令的简写形式：<code>git clone -b master &lt;url&gt;</code>。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>1.克隆仓库到本地，查看本地分支</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912145740.png"></p><p>2.查看远程分支</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912145759.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="对于比较少分支的仓库–方法1"><a href="#对于比较少分支的仓库–方法1" class="headerlink" title="对于比较少分支的仓库–方法1"></a>对于比较少分支的仓库–方法1</h3><p><strong>思路</strong>：先查看远程分支，然后在本地创建和远程仓库同名的分支。</p><p><strong>关键命令</strong>：git branch dev origin/dev，即新建一个本地分支来跟踪远程的某一分支，创建该分支后，远程分支内容已拉取到本地分支。（或者你可以直接用git checkout -b dev origin/dev，创建分支，并切换到该分支）<br><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912150627.png"></p><p><strong>该方法弊端</strong>：因为这方法每次只创建一个分支，如果远程有多个分支，需要多次执行命令，比较麻烦。<br><strong>该方法优点</strong>：（与下面方法进行对比）命令简单易懂。</p><p>如针对这个仓库你需要执行两次类似命令：<br>git branch readme origin/readme<br>git branch dev origin/dev</p><p><strong>流程简单演示</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span>  https://github.com/yansheng836/hello-world.git</span><br><span class="line"><span class="comment"># 要先进入仓库目录</span></span><br><span class="line">$ <span class="built_in">cd</span> hello-world</span><br><span class="line">$ git branch readme origin/readme</span><br></pre></td></tr></table></figure><h3 id="对于比较少分支的仓库–方法2"><a href="#对于比较少分支的仓库–方法2" class="headerlink" title="对于比较少分支的仓库–方法2"></a>对于比较少分支的仓库–方法2</h3><p><strong>思路</strong>：在前面的分析已经提到了git clone url是git clone -b master url的缩写（假设没有在远程仓库修改默认分支），那么我们同样可以使用该命令下载其他分支的内容。</p><p><strong>关键命令</strong>：git clone -b readme url：下载该仓库的readme分支的内容。</p><p><strong>优缺点</strong>：同方法1。<br><strong>流程简单演示</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span>  https://github.com/yansheng836/hello-world.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用先进入仓库目录</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> -b readme https://github.com/yansheng836/hello-world.</span><br></pre></td></tr></table></figure><h3 id="对于比较多分支的仓库"><a href="#对于比较多分支的仓库" class="headerlink" title="对于比较多分支的仓库"></a>对于比较多分支的仓库</h3><p><strong>思路</strong>：了解到了方法1、2的弊端，我们可能就会想到：循环可以执行重复的类似的操作，也许我们可以通过循环解决这个问题！该方法就是循环使用方法1.</p><p><strong>背景说明</strong>：使用类Unix系统的人很自然就想到了使用shell编程，使用Windows系统人都是使用git的客户端的命令行工具，虽然可能种类不一，但是都是基于Linux shell的；因为git就是Linux的创始人：林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds） 开发的（开发git的初衷是因为和之前的版本管理系统的合作伙伴SCM(源码管理工具)闹掰了，这是个有趣的故事，详情可了解：Linux为什么开发Git？）。以此可以说：Linux和Git本是一家，所以Linux 很多命令也可以在git bash中使用；git火起来也正是因为Linus把庞大的 Linux内核代码库 (目前仓库大小为：2.55GB)放到git中进行版本管理（另一个重要原因是因为分布式），以实际行动证明Git完全有能力去管理这种庞大的系统。</p><p><strong>关键命令</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for b in `git branch -r | grep -v -- &#x27;-&gt;&#x27;`; do git branch --track $&#123;b##origin/&#125; $b; done</span><br></pre></td></tr></table></figure><p><strong>该方法弊端</strong>：（相对而言）命令比较复杂。<br><strong>该方法优点</strong>：不管有多少分支都可以自动创建。</p><p>也可以这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r | grep -v &#x27;\-&gt;&#x27; | while read remote; do git branch --track &quot;$&#123;remote#origin/&#125;&quot; &quot;$remote&quot;; done</span><br></pre></td></tr></table></figure><p><strong>流程简单演示</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span>  https://github.com/yansheng836/hello-world.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要先进入仓库目录</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> hello-world</span><br><span class="line">$ <span class="keyword">for</span> b <span class="keyword">in</span> `git branch -r | grep -v -- <span class="string">&#x27;-&gt;&#x27;</span>`; <span class="keyword">do</span> git branch --track <span class="variable">$&#123;b##origin/&#125;</span> <span class="variable">$b</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景说明&quot;&gt;&lt;a href=&quot;#背景说明&quot; class=&quot;headerlink&quot; title=&quot;背景说明&quot;&gt;&lt;/a&gt;背景说明&lt;/h1&gt;&lt;p&gt;git clone 默认只克隆github上面设置的默认分支，（如果没有修改，默认就是master分支），那如果需要把所有分</summary>
      
    
    
    
    
    <category term="git" scheme="https://andylinwenqin.github.io/tags/git/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git复制已有的分支到新分支</title>
    <link href="https://andylinwenqin.github.io/2021/09/12/Git%E5%A4%8D%E5%88%B6%E5%B7%B2%E6%9C%89%E7%9A%84%E5%88%86%E6%94%AF%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF/"/>
    <id>https://andylinwenqin.github.io/2021/09/12/Git%E5%A4%8D%E5%88%B6%E5%B7%B2%E6%9C%89%E7%9A%84%E5%88%86%E6%94%AF%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF/</id>
    <published>2021-09-12T06:10:50.000Z</published>
    <updated>2021-09-12T07:29:36.361Z</updated>
    
    <content type="html"><![CDATA[<p>如果我们需要在现有分支的基础上，复制代码到新分支进行开发，并推送至远程仓库，可以进行如下操作：<br> <strong>注：old-branch为旧分支名，new-branch为新分支名</strong></p><p>1.使用git bash打开命令行界面，使用以下命令检出远程分支。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout -b old-branch origin/old-branch</span><br></pre></td></tr></table></figure><p>2.从当前分支复制出新的分支</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="keyword">new</span>-branch</span><br></pre></td></tr></table></figure><p>3.把新建的分支push到远程库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin <span class="keyword">new</span>-branch:<span class="keyword">new</span>-branch</span><br></pre></td></tr></table></figure><p>4.拉取远程分支</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull <span class="comment"># 经过验证，当前的分支并没有和本地分支关联，根据提示进行下一步</span></span><br></pre></td></tr></table></figure><p>5.关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/<span class="keyword">new</span>-branch <span class="keyword">new</span>-branch</span><br></pre></td></tr></table></figure><p>6.再次拉取，成功</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果我们需要在现有分支的基础上，复制代码到新分支进行开发，并推送至远程仓库，可以进行如下操作：&lt;br&gt; &lt;strong&gt;注：old-branch为旧分支名，new-branch为新分支名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.使用git bash打开命令行界面，使用以下命令检</summary>
      
    
    
    
    
    <category term="git" scheme="https://andylinwenqin.github.io/tags/git/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git删除分支</title>
    <link href="https://andylinwenqin.github.io/2021/09/12/Git%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF/"/>
    <id>https://andylinwenqin.github.io/2021/09/12/Git%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF/</id>
    <published>2021-09-12T06:05:58.000Z</published>
    <updated>2021-09-12T06:10:18.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-删除分支——如何删除本地或远程分支"><a href="#Git-删除分支——如何删除本地或远程分支" class="headerlink" title="Git 删除分支——如何删除本地或远程分支"></a>Git 删除分支——如何删除本地或远程分支</h1><hr><h2 id="为什么要删除-Git-中的分支？"><a href="#为什么要删除-Git-中的分支？" class="headerlink" title="为什么要删除 Git 中的分支？"></a>为什么要删除 Git 中的分支？</h2><p>因此，您已经创建了一个分支来保存要在项目中进行的更改的代码。</p><p>然后，您将该更改或新功能合并到项目的原始版本中。</p><p>这意味着您不再需要保留和使用该分支，因此删除它是一种常见的最佳做法，以免它弄乱您的代码。</p><h2 id="如何在-Git-中删除本地分支"><a href="#如何在-Git-中删除本地分支" class="headerlink" title="如何在 Git 中删除本地分支"></a>如何在 Git 中删除本地分支</h2><p>本地分支是您本地机器上的分支，不会影响任何远程分支。</p><p>在 Git 中删除本地分支的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d  local_branch_name</span><br></pre></td></tr></table></figure><ul><li>git branch 是在本地删除分支的命令。</li><li>-d是一个标志，是命令的一个选项，它是–delete. 顾名思义，它表示您要删除某些内容。-local_branch_name是要删除的分支的名称。</li><li>个别时候-d 需要大写 -D</li></ul><h2 id="如何在-Git-中删除远程分支"><a href="#如何在-Git-中删除远程分支" class="headerlink" title="如何在 Git 中删除远程分支"></a>如何在 Git 中删除远程分支</h2><p>远程分支与本地分支是分开的。</p><p>它们是托管在远程服务器上的存储库，可以在那里访问。这与本地分支相比，本地分支是本地系统上的存储库。</p><p>删除远程分支的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote_name -d remote_branch_name</span><br></pre></td></tr></table></figure><ul><li>git branch您可以使用该命令删除远程分支，而不是使用用于本地分支的git push命令。</li><li>然后您指定遥控器的名称，在大多数情况下是origin.</li><li>-d是删除标志，是–delete.</li><li>remote_branch_name 是要删除的远程分支。</li></ul><p>现在，让我们看一个如何删除远程分支的示例。</p><p>要查看任何远程分支，请使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>该-a标志（一个别名–all）显示所有分支机构-本地和远程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git-删除分支——如何删除本地或远程分支&quot;&gt;&lt;a href=&quot;#Git-删除分支——如何删除本地或远程分支&quot; class=&quot;headerlink&quot; title=&quot;Git 删除分支——如何删除本地或远程分支&quot;&gt;&lt;/a&gt;Git 删除分支——如何删除本地或远程分支&lt;/</summary>
      
    
    
    
    
    <category term="git" scheme="https://andylinwenqin.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="https://andylinwenqin.github.io/2021/09/07/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://andylinwenqin.github.io/2021/09/07/%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2021-09-07T13:15:29.000Z</published>
    <updated>2021-09-12T16:29:44.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端模块化详解-来源-浪里行舟"><a href="#前端模块化详解-来源-浪里行舟" class="headerlink" title="前端模块化详解(来源 浪里行舟)"></a><a href="https://segmentfault.com/a/1190000017466120">前端模块化详解</a>(来源 浪里行舟)</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。<br>本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的CommonJS, AMD, ES6、CMD规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！</p><p><strong>建议下载本文源代码，自己动手敲一遍，请猛戳<a href="https://link.segmentfault.com/?url=https://github.com/ljianshu/Blog">GitHub个人博客</a></strong></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912235124.webp"></p><h2 id="一、模块化的理解"><a href="#一、模块化的理解" class="headerlink" title="一、模块化的理解"></a>一、模块化的理解</h2><h3 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1.什么是模块?"></a>1.什么是模块?</h3><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul><h3 id="2-模块化的进化过程"><a href="#2-模块化的进化过程" class="headerlink" title="2.模块化的进化过程"></a>2.模块化的进化过程</h3><ul><li><strong>全局function模式 : 将不同的功能封装成不同的全局函数</strong><ul><li>编码: 将不同的功能封装成不同的全局函数</li><li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li></ul></li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>namespace模式 : 简单对象封装</strong><ul><li>作用: 减少了全局变量，解决命名冲突</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.data = <span class="string">&#x27;other data&#x27;</span> <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.foo() <span class="comment">// foo() other data</span></span><br></pre></td></tr></table></figure><p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p><ul><li><strong>IIFE模式：匿名函数自调用(闭包)</strong><ul><li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>问题: 如果当前这个模块依赖另一个模块怎么办?</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    myModule.foo()</span></span><br><span class="line"><span class="javascript">    myModule.bar()</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span></span><br><span class="line"><span class="javascript">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span><br><span class="line"><span class="javascript">    myModule.foo() <span class="comment">//没有改变</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>最后得到的结果：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912235435.webp"></p><ul><li><strong>IIFE模式增强 : 引入依赖</strong></li></ul><p>这就是现代模块实现的基石</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"> <span class="comment">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">   myModule.foo()</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p><h3 id="3-模块化的好处"><a href="#3-模块化的好处" class="headerlink" title="3. 模块化的好处"></a>3. 模块化的好处</h3><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h3 id="4-引入多个-lt-script-gt-后出现出现问题"><a href="#4-引入多个-lt-script-gt-后出现出现问题" class="headerlink" title="4. 引入多个&lt;script&gt;后出现出现问题"></a>4. 引入多个<code>&lt;script&gt;</code>后出现出现问题</h3><ul><li>请求过多</li></ul><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p><ul><li>依赖模糊</li></ul><p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p><ul><li>难以维护</li></ul><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。<br>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。</p><h2 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h2><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h4><ul><li>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li></ul><p>此处我们有个疑问：<strong>CommonJS暴露的模块到底是什么?</strong> CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = function (value) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span>.x = x;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span>.addX = addX;</span><br></pre></td></tr></table></figure><p>上面代码通过module.exports输出变量x和函数addX。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);<span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错</strong>。</p><h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h4><p><strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function">function <span class="title">incCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p><h4 id="5-服务器端实现"><a href="#5-服务器端实现" class="headerlink" title="(5)服务器端实现"></a>(5)服务器端实现</h4><h4 id="①下载安装node-js"><a href="#①下载安装node-js" class="headerlink" title="①下载安装node.js"></a>①下载安装node.js</h4><h4 id="②创建项目结构"><a href="#②创建项目结构" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><p><strong>注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-modules</span></span><br><span class="line">  <span class="string">|-module1.js</span></span><br><span class="line">  <span class="string">|-module2.js</span></span><br><span class="line">  <span class="string">|-module3.js</span></span><br><span class="line"><span class="string">|-app.js</span></span><br><span class="line"><span class="string">|-package.json</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;commonJS-node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="③下载第三方模块"><a href="#③下载第三方模块" class="headerlink" title="③下载第三方模块"></a>③下载第三方模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uniq --save // 用于数组去重</span><br></pre></td></tr></table></figure><h4 id="④定义模块代码"><a href="#④定义模块代码" class="headerlink" title="④定义模块代码"></a>④定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;module1&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;module2&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js</span></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo() module3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="comment">// 引入第三方库，应该放置在最前面</span></span><br><span class="line"><span class="keyword">let</span> uniq = <span class="built_in">require</span>(<span class="string">&#x27;uniq&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module2&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> module3 = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">module1.foo() <span class="comment">//module1</span></span><br><span class="line">module2() <span class="comment">//module2</span></span><br><span class="line">module3.foo() <span class="comment">//foo() module3</span></span><br><span class="line"><span class="built_in">console</span>.log(uniq(module3.arr)) <span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h4 id="⑤通过node运行app-js"><a href="#⑤通过node运行app-js" class="headerlink" title="⑤通过node运行app.js"></a>⑤通过node运行app.js</h4><p>命令行输入<code>node app.js</code>，运行JS文件</p><h4 id="6-浏览器端实现-借助Browserify"><a href="#6-浏览器端实现-借助Browserify" class="headerlink" title="(6)浏览器端实现(借助Browserify)"></a>(6)浏览器端实现(借助Browserify)</h4><h4 id="①创建项目结构"><a href="#①创建项目结构" class="headerlink" title="①创建项目结构"></a>①创建项目结构</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-js</span></span><br><span class="line">  <span class="string">|-dist //打包生成文件的目录</span></span><br><span class="line">  <span class="string">|-src //源码所在的目录</span></span><br><span class="line">    <span class="string">|-module1.js</span></span><br><span class="line">    <span class="string">|-module2.js</span></span><br><span class="line">    <span class="string">|-module3.js</span></span><br><span class="line">    <span class="string">|-app.js //应用主源文件</span></span><br><span class="line"><span class="string">|-index.html //运行于浏览器上</span></span><br><span class="line"><span class="string">|-package.json</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;browserify-test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="②下载browserify"><a href="#②下载browserify" class="headerlink" title="②下载browserify"></a>②下载browserify</h4><ul><li>全局: npm install browserify -g</li><li>局部: npm install browserify –save-dev</li></ul><h4 id="③定义模块代码-同服务器端"><a href="#③定义模块代码-同服务器端" class="headerlink" title="③定义模块代码(同服务器端)"></a>③定义模块代码(同服务器端)</h4><p>注意：<code>index.html</code>文件要运行在浏览器上，需要借助browserify将<code>app.js</code>文件打包编译，如果直接在<code>index.html</code>引入<code>app.js</code>就会报错！</p><h4 id="④打包处理js"><a href="#④打包处理js" class="headerlink" title="④打包处理js"></a>④打包处理js</h4><p>根目录下运行<code>browserify js/src/app.js -o js/dist/bundle.js</code></p><h4 id="⑤页面使用引入"><a href="#⑤页面使用引入" class="headerlink" title="⑤页面使用引入"></a>⑤页面使用引入</h4><p>在index.html文件中引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</strong>。此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p><h4 id="1-AMD规范基本语法"><a href="#1-AMD规范基本语法" class="headerlink" title="(1)AMD规范基本语法"></a>(1)AMD规范基本语法</h4><p><strong>定义暴露模块</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>引入使用模块</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>)</span>&#123;</span><br><span class="line">   使用m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-未使用AMD规范与使用require-js"><a href="#2-未使用AMD规范与使用require-js" class="headerlink" title="(2)未使用AMD规范与使用require.js"></a>(2)未使用AMD规范与使用require.js</h4><p>通过比较两者的实现方法，来说明使用AMD规范的好处。</p><ul><li>未使用AMD规范</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.dataService = &#123;getMsg&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&#x27;, &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.alerter = &#123;showMsg&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, dataService)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">  alerter.showMsg()</span><br><span class="line">&#125;)(alerter)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Modular Demo 1: 未使用AMD(require.js)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/dataService.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/alerter.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>最后得到如下结果：<br><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210913002029.webp"></p><p>这种方式缺点很明显：<strong>首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！</strong></p><ul><li>使用require.js</li></ul><p>RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<strong>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</strong>。<br>接下来介绍AMD规范在浏览器实现的步骤：</p><h4 id="①下载require-js-并引入"><a href="#①下载require-js-并引入" class="headerlink" title="①下载require.js, 并引入"></a>①下载require.js, 并引入</h4><ul><li>官网: <code>http://www.requirejs.cn/</code></li><li>github : <code>https://github.com/requirejs/requirejs</code></li></ul><p>然后将require.js导入项目: js/libs/require.js</p><h4 id="②创建项目结构-1"><a href="#②创建项目结构-1" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-js</span></span><br><span class="line">  <span class="string">|-libs</span></span><br><span class="line">    <span class="string">|-require.js</span></span><br><span class="line">  <span class="string">|-modules</span></span><br><span class="line">    <span class="string">|-alerter.js</span></span><br><span class="line">    <span class="string">|-dataService.js</span></span><br><span class="line">  <span class="string">|-main.js</span></span><br><span class="line"><span class="string">|-index.html</span></span><br></pre></td></tr></table></figure><h4 id="③定义require-js的模块代码"><a href="#③定义require-js的模块代码" class="headerlink" title="③定义require.js的模块代码"></a>③定义require.js的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件 </span></span><br><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125; <span class="comment">// 暴露模块</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alerter.js文件</span></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&#x27;dataService&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&#x27;, &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    <span class="attr">baseUrl</span>: <span class="string">&#x27;js/&#x27;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">      <span class="comment">//映射: 模块标识名: 路径</span></span><br><span class="line">      <span class="attr">alerter</span>: <span class="string">&#x27;./modules/alerter&#x27;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      <span class="attr">dataService</span>: <span class="string">&#x27;./modules/dataService&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;alerter&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Modular Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">&quot;js/main&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="④页面引入require-js模块"><a href="#④页面引入require-js模块" class="headerlink" title="④页面引入require.js模块:"></a>④页面引入require.js模块:</h4><p>在index.html引入 <code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</code></p><p><strong>此外在项目中如何引入第三方库？</strong>只需在上面代码的基础稍作修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">define([<span class="string">&#x27;dataService&#x27;</span>, <span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&#x27;, &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    <span class="attr">baseUrl</span>: <span class="string">&#x27;js/&#x27;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">      <span class="comment">//自定义模块</span></span><br><span class="line">      <span class="attr">alerter</span>: <span class="string">&#x27;./modules/alerter&#x27;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      <span class="attr">dataService</span>: <span class="string">&#x27;./modules/dataService&#x27;</span>,</span><br><span class="line">      <span class="comment">// 第三方库模块</span></span><br><span class="line">      <span class="attr">jquery</span>: <span class="string">&#x27;./libs/jquery-1.10.1&#x27;</span> <span class="comment">//注意：写成jQuery会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;alerter&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。<br><strong>小结</strong>：通过两者的比较，可以得出<strong>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p><h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h4 id="1-CMD规范基本语法"><a href="#1-CMD规范基本语法" class="headerlink" title="(1)CMD规范基本语法"></a>(1)CMD规范基本语法</h4><p><strong>定义暴露模块：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">  <span class="built_in">module</span>.exports = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">&#x27;./module3&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>引入使用模块：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-sea-js简单使用教程"><a href="#2-sea-js简单使用教程" class="headerlink" title="(2)sea.js简单使用教程"></a>(2)sea.js简单使用教程</h4><h4 id="①下载sea-js-并引入"><a href="#①下载sea-js-并引入" class="headerlink" title="①下载sea.js, 并引入"></a>①下载sea.js, 并引入</h4><ul><li>官网: <a href="https://link.segmentfault.com/?url=http://seajs.org/">http://seajs.org/</a></li><li>github : <a href="https://link.segmentfault.com/?url=https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li></ul><p>然后将sea.js导入项目: js/libs/sea.js</p><h4 id="②创建项目结构-2"><a href="#②创建项目结构-2" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-js</span></span><br><span class="line">  <span class="string">|-libs</span></span><br><span class="line">    <span class="string">|-sea.js</span></span><br><span class="line">  <span class="string">|-modules</span></span><br><span class="line">    <span class="string">|-module1.js</span></span><br><span class="line">    <span class="string">|-module2.js</span></span><br><span class="line">    <span class="string">|-module3.js</span></span><br><span class="line">    <span class="string">|-module4.js</span></span><br><span class="line">    <span class="string">|-main.js</span></span><br><span class="line"><span class="string">|-index.html</span></span><br></pre></td></tr></table></figure><h4 id="③定义sea-js的模块代码"><a href="#③定义sea-js的模块代码" class="headerlink" title="③定义sea.js的模块代码"></a>③定义sea.js的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//内部变量数据</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&#x27;atguigu.com&#x27;</span></span><br><span class="line">  <span class="comment">//内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;module1 show() &#x27;</span> + data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露</span></span><br><span class="line">  <span class="built_in">exports</span>.show = show</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module2.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;I Will Back&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module3.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">&#x27;abc123&#x27;</span></span><br><span class="line">  <span class="built_in">exports</span>.API_KEY = API_KEY</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module4.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;module4 show() &#x27;</span> + module2.msg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.show = show</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&#x27;./module3&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;异步引入依赖模块3  &#x27;</span> + m3.API_KEY)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="④在index-html中引入"><a href="#④在index-html中引入" class="headerlink" title="④在index.html中引入"></a>④在index.html中引入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&#x27;./js/modules/main&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后得到结果如下：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210913002422.webp"></p><h3 id="4-ES6模块化"><a href="#4-ES6模块化" class="headerlink" title="4.ES6模块化"></a>4.ES6模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><h4 id="1-ES6模块化语法"><a href="#1-ES6模块化语法" class="headerlink" title="(1)ES6模块化语法"></a>(1)ES6模块化语法</h4><p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">add</span> = function (a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, <span class="keyword">add</span> &#125;;</span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line">import &#123; basicNum, <span class="keyword">add</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function">function <span class="title">test</span>(<span class="params">ele</span>)</span> &#123;</span><br><span class="line">    ele.textContent = <span class="keyword">add</span>(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><p>模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p><h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(2)ES6 模块与 CommonJS 模块的差异"></a>(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：</p><p><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。</p><p><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。</p><p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p><h4 id="3-ES6-Babel-Browserify使用教程"><a href="#3-ES6-Babel-Browserify使用教程" class="headerlink" title="(3) ES6-Babel-Browserify使用教程"></a>(3) ES6-Babel-Browserify使用教程</h4><p>简单来说就一句话：<strong>使用Babel将ES6编译为ES5代码，使用Browserify编译打包js</strong>。</p><h4 id="①定义package-json文件"><a href="#①定义package-json文件" class="headerlink" title="①定义package.json文件"></a>①定义package.json文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;es6-babel-browserify&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②安装babel-cli-babel-preset-es2015和browserify"><a href="#②安装babel-cli-babel-preset-es2015和browserify" class="headerlink" title="②安装babel-cli, babel-preset-es2015和browserify"></a>②安装babel-cli, babel-preset-es2015和browserify</h4><ul><li><p>npm install babel-cli browserify -g</p></li><li><p>npm install babel-preset-es2015 –save-dev</p></li><li><p>preset 预设(将es6转换成es5的所有插件打包)</p></li></ul><h4 id="③定义-babelrc文件"><a href="#③定义-babelrc文件" class="headerlink" title="③定义.babelrc文件"></a>③定义.babelrc文件</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④定义模块代码-1"><a href="#④定义模块代码-1" class="headerlink" title="④定义模块代码"></a>④定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js文件</span></span><br><span class="line"><span class="comment">// 分别暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo() module1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar() module1&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js文件</span></span><br><span class="line"><span class="comment">// 统一暴露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fun1() module2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fun2() module2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; fun1, fun2 &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js文件</span></span><br><span class="line"><span class="comment">// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;默认暴露&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./module1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; fun1, fun2 &#125; <span class="keyword">from</span> <span class="string">&#x27;./module2&#x27;</span></span><br><span class="line"><span class="keyword">import</span> module3 <span class="keyword">from</span> <span class="string">&#x27;./module3&#x27;</span></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br><span class="line">module3()</span><br></pre></td></tr></table></figure><h4 id="⑤-编译并在index-html中引入"><a href="#⑤-编译并在index-html中引入" class="headerlink" title="⑤ 编译并在index.html中引入"></a>⑤ 编译并在index.html中引入</h4><ul><li>使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : <code>babel js/src -d js/lib</code></li><li>使用Browserify编译js : <code>browserify js/lib/app.js -o js/lib/bundle.js</code></li></ul><p>然后在index.html文件中引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/lib/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后得到如下结果：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210913002613.webp"></p><p><strong>此外第三方库(以jQuery为例)如何引入呢</strong>？<br>首先安装依赖<code>npm install jquery@1</code><br>然后在app.js文件中引入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js文件</span></span><br><span class="line">import &#123; foo, bar &#125; from <span class="string">&#x27;./module1&#x27;</span></span><br><span class="line">import &#123; fun1, fun2 &#125; from <span class="string">&#x27;./module2&#x27;</span></span><br><span class="line">import module3 from <span class="string">&#x27;./module3&#x27;</span></span><br><span class="line">import $ from <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">module3</span><span class="params">()</span></span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>)<span class="selector-class">.css</span>(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>花了很长时间(&gt;10h)终于把”JS模块化”讲清楚，自己对模块化的认识又加深了一步，事实上，理解一件事并不难，难的是如何将一件事通俗分享给别人，并让别人也有所收获，一直以来我也是这样要求自己！文章如有错误和不正之处，欢迎指正和批评，同时也希望大家多多支持，我会有更大的创作动力!</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>即使走在前人的肩膀上学习这些内容也是非常的有深度，需要多次学习巩固知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端模块化详解-来源-浪里行舟&quot;&gt;&lt;a href=&quot;#前端模块化详解-来源-浪里行舟&quot; class=&quot;headerlink&quot; title=&quot;前端模块化详解(来源 浪里行舟)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://segmentfault.com/a/1190</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="NodeJS" scheme="https://andylinwenqin.github.io/tags/NodeJS/"/>
    
    <category term="模块化" scheme="https://andylinwenqin.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://andylinwenqin.github.io/2021/09/07/webpack/"/>
    <id>https://andylinwenqin.github.io/2021/09/07/webpack/</id>
    <published>2021-09-07T13:15:02.000Z</published>
    <updated>2021-09-12T16:29:52.588Z</updated>
    
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工程化" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Vue点击触发事件和组件传值(实例)</title>
    <link href="https://andylinwenqin.github.io/2021/09/07/Vue%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC-%E5%AE%9E%E4%BE%8B/"/>
    <id>https://andylinwenqin.github.io/2021/09/07/Vue%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC-%E5%AE%9E%E4%BE%8B/</id>
    <published>2021-09-07T02:40:37.000Z</published>
    <updated>2021-09-12T12:23:33.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-组件间传值及事件触发"><a href="#Vue-组件间传值及事件触发" class="headerlink" title="Vue 组件间传值及事件触发"></a>Vue 组件间传值及事件触发</h1><hr><p><strong>父组件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Counter v-bind:numb=&quot;num&quot; v-on:incre=&quot;parIncrement&quot; v-on:decre=&quot;parDecrement&quot;&gt;&lt;/Counter&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Counter from &#x27;./Counter&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">      name: &#x27;&#x27;,</span><br><span class="line">      data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          num: 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components:&#123;</span><br><span class="line">        Counter</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        parIncrement(e)&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        parDecrement()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>1.声明子组件Counter并用v-bind绑定numb，numb是向子组件传值字段；<br>2.用v-on来绑定incre和decre自定义事件，为子组件做回调触发；<br>3.在子组件回调事件parIncrement（e）中，e是可以接收子组件回传值（如果接收对象，必须将json格式字符串转成对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="built_in">JSON</span>.parse(userfoString)；</span><br></pre></td></tr></table></figure><p>）；</p><p><strong>子组件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    props: [&quot;numb&quot;],</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      increment()&#123;</span><br><span class="line">        this.$emit(&quot;incre&quot;,&quot;1&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      decrement()&#123;</span><br><span class="line">        this.$emit(&quot;decre&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>1.通过props数组形式接收父组件传递numb值；<br>2.通过$emit方法触发父组件方法，做回调操作；<br>3.还是通过$emit方法可以向父组件传递“1”值（如果传递对象，需要先转化成json格式字符串：<br>var users = {name: “my”}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = &#123;<span class="attr">name</span>: <span class="string">&quot;my&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&quot;incre&quot;</span>,<span class="built_in">JSON</span>.stringify(users));</span><br></pre></td></tr></table></figure><p>）；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-组件间传值及事件触发&quot;&gt;&lt;a href=&quot;#Vue-组件间传值及事件触发&quot; class=&quot;headerlink&quot; title=&quot;Vue 组件间传值及事件触发&quot;&gt;&lt;/a&gt;Vue 组件间传值及事件触发&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;父组件&lt;/stro</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝</title>
    <link href="https://andylinwenqin.github.io/2021/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://andylinwenqin.github.io/2021/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-09-05T15:50:57.000Z</published>
    <updated>2021-09-05T16:18:23.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js深拷贝的三种实现方式"><a href="#js深拷贝的三种实现方式" class="headerlink" title="js深拷贝的三种实现方式"></a><strong>js深拷贝的三种实现方式</strong></h1><h2 id="1-使用递归的方式实现深拷贝"><a href="#1-使用递归的方式实现深拷贝" class="headerlink" title="1. 使用递归的方式实现深拷贝"></a><strong>1. 使用递归的方式实现深拷贝</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归的方式实现数组、对象的深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone1</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝</span></span><br><span class="line">  <span class="keyword">var</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">//进行深拷贝的不能为空，并且是对象或者是</span></span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">          objClone[key] = deepClone1(obj[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          objClone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-通过-JSON-对象实现深拷贝"><a href="#2-通过-JSON-对象实现深拷贝" class="headerlink" title="2. 通过 JSON 对象实现深拷贝"></a><strong>2. 通过 JSON 对象实现深拷贝</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过js的内置对象JSON来进行数组对象的深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone2</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">    objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON对象实现深拷贝的一些问题 </span></span><br><span class="line"><span class="comment">//无法实现对对象中方法的深拷贝</span></span><br></pre></td></tr></table></figure><h2 id="3-通过jQuery的extend方法实现深拷贝"><a href="#3-通过jQuery的extend方法实现深拷贝" class="headerlink" title="3. 通过jQuery的extend方法实现深拷贝"></a><strong>3. 通过jQuery的extend方法实现深拷贝</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> newArray = $.extend(<span class="literal">true</span>,[],array);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js深拷贝的三种实现方式&quot;&gt;&lt;a href=&quot;#js深拷贝的三种实现方式&quot; class=&quot;headerlink&quot; title=&quot;js深拷贝的三种实现方式&quot;&gt;&lt;/a&gt;&lt;strong&gt;js深拷贝的三种实现方式&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-使用递归的方</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://andylinwenqin.github.io/tags/JS/"/>
    
    <category term="基础算法" scheme="https://andylinwenqin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>安全知识总结</title>
    <link href="https://andylinwenqin.github.io/2021/09/05/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://andylinwenqin.github.io/2021/09/05/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-05T15:46:52.000Z</published>
    <updated>2021-09-05T16:18:23.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CIA三元组"><a href="#CIA三元组" class="headerlink" title="CIA三元组"></a>CIA三元组</h2><p>(1). 机密性;<br>(2). 完整性;<br>(3). 可用性;</p><h2 id="XSS攻击是如何产生的"><a href="#XSS攻击是如何产生的" class="headerlink" title="XSS攻击是如何产生的"></a>XSS攻击是如何产生的</h2><p>黑客在你的浏览器中插入一段恶意的JavaScript脚本，窃取你的隐私信息，冒充你的身份进行操作，这就是XSS(Cross-Site Scripting, 跨站攻击)</p><p>因为浏览器无法区分脚本是恶意注入的还是正常的内容，它都会执行</p><h2 id="XSS有哪几种类型"><a href="#XSS有哪几种类型" class="headerlink" title="XSS有哪几种类型"></a>XSS有哪几种类型</h2><h3 id="1-反射型XSS-非持久型"><a href="#1-反射型XSS-非持久型" class="headerlink" title="(1). 反射型XSS(非持久型);"></a>(1). 反射型XSS(非持久型);</h3><p>顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。</p><h3 id="2-基于DOM的XSS"><a href="#2-基于DOM的XSS" class="headerlink" title="(2). 基于DOM的XSS;"></a>(2). 基于DOM的XSS;</h3><p>目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。</p><h3 id="3-存储型XSS-持久型"><a href="#3-存储型XSS-持久型" class="headerlink" title="(3). 存储型XSS(持久型);"></a>(3). 存储型XSS(持久型);</h3><p>又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>反射型的 XSS 的恶意脚本存在 URL 里，存储型 XSS 的恶意代码存在数据库里。</p><p>而基于DOM型的XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，其他两种 XSS 都属于服务端的安全漏洞。</p><h3 id="如何防护"><a href="#如何防护" class="headerlink" title="如何防护"></a>如何防护</h3><p>(1). 一切用户输入皆不可信: 在输出时进行验证;<br>(2). 将HTML元素内容，属性以及URL请求参数，CSS值进行编码;<br>(3). 当编码影响业务时，使用白名单规则进行检测和过滤;<br>(4). 使用W3C提出的CSP(Content Security Policy, 内容安全策略),定义域名白名单;<br>(5). 设置Cookie的HTTpOnly属性;</p><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>CSRF 英文全称是 Cross-site request forgery，又称为“跨站请求伪造”。<br>顾名思义，CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求。<br>降维解释：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。<br>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证， 达到冒充用户对被攻击的网站执行某项操作的目的。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>(1). 最容易实现的是Get请求，一般进入黑客网站后，可以通过设置img的src属性来自动发起请求<br>(2). 在黑客网站中，构造隐藏表单来自动发起post请求<br>(3). 通过引诱链接诱惑用户点击触发请求，利用a标签的href</p><h3 id="与XSS区别"><a href="#与XSS区别" class="headerlink" title="与XSS区别"></a>与XSS区别</h3><p>CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击</p><p>CSRF 攻击成本也比 XSS 低，用户每天都要访问大量网页，无法确认每一个网页的合法性， 从用户角度来说，无法彻底防止 CSRF 攻击。</p><h3 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h3><p>针对实际情况，设置关键 Cookie 的 SameSite 属性为 Strict 或 Lax服务端验证请求来源站点(Referer、Origin)使用 CSRF Token，服务端随机生成返回给浏览器的 Token，每一次请求都会携带不同的 CSRF Token加入二次验证(独立的支付密码)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CIA三元组&quot;&gt;&lt;a href=&quot;#CIA三元组&quot; class=&quot;headerlink&quot; title=&quot;CIA三元组&quot;&gt;&lt;/a&gt;CIA三元组&lt;/h2&gt;&lt;p&gt;(1). 机密性;&lt;br&gt;(2). 完整性;&lt;br&gt;(3). 可用性;&lt;/p&gt;
&lt;h2 id=&quot;XSS攻击是</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="协议" scheme="https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="安全" scheme="https://andylinwenqin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络知识总结</title>
    <link href="https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-05T14:32:36.000Z</published>
    <updated>2021-09-05T16:18:23.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位</p><p>线程: 是进程的一部分，一个没有线程的进程可以被看作是单线程的，线程有时又被称为轻权进程或轻量级进程，也是CPU调度的一个基本单位</p><p>区别: </p><p>(1). 进程是资源分配的最小单位，线程是程序执行的最小单位(资源调度的最小单位);</p><p>(2). 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段，这种操作非常昂贵，而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多;</p><p>(3). 线程之间的通信更方便，同一进程下的线程恭喜全局变量，静态变量等数据，而进程之间的通信要以通信的方式(IPC)进行;</p><p>(4). 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间;</p><h2 id="session-cookie-sessionsotrage-localstorage"><a href="#session-cookie-sessionsotrage-localstorage" class="headerlink" title="session, cookie, sessionsotrage, localstorage"></a>session, cookie, sessionsotrage, localstorage</h2><p>cookie中domain属性<br>为了保证安全性，cookie无法设置除当前域名或者其父域名之外的其他domain。<br>在此，分为两种情况：<br>1.一种是前端范围内的是指cookie，如果网站的域名为，i.xiaohan.com,那么前端cookie的domain只能设置，i.xiaohan.com和其父域名xiaohan.com，如果设置成同级域名如api.xiaohan.com或者子域名api.i.xiaohan.com 那么cookie设置将无效。<br>2.同样在服务端上，如果制定你的server服务的域名为server.xiaohan.com那么在服务端生成的cookie的domain只能指定为server.xiaohan.com或者xiaohan.com 其他domain都无法成功设置cookie。</p><p>(1). cookie和session的区别</p><p>1.cookie数据存放在客户端，session数据存放在服务器端;</p><p>2.cookie安全性一般，他人可以通过分析存放在本地的cookie并进行cookie欺骗，在安全性第一的前提下，选择session更优，重要交互信息比如权限等就要放在session中，一般的信息记录放在cookie中;</p><p>3.单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie而session原则上没有限制;</p><p>4.session会在一定的时间内保存在服务器上，当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie</p><p>5.session运行以来Session ID,而Session ID是存在Cookie中，也就是说，如果浏览器禁用了Cookie，Session也会失效(但是可以通过其他方式实现，比如在url中传递Session ID，也就是地址重写)</p><p>(2). localStorage和sessionStorage的区别</p><p>localStorage和sessionStorage存储数据大小一般为5MB,并且仅在客户端(即浏览器)中保存，不参与和服务器的通信</p><p>其实，localStorage最大容量5M的意思是每一个域名下的localStorage容量是5M，假如现在a.com域名下localstorage存不下了，我们可以使用iframe创建b.com域框架（子页面）用于存储a.com剩下的数据。然后使用postMessage读写数据。</p><p>localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除</p><p>set-cookie: 开始状态管理所使用的Cookie信息    响应首部字段<br>Cookie  服务器接收到的 Cookie 信息   请求首部字段</p><p>cookie属性</p><pre><code>name: cookie名称value: cookie值domain: 即可访问此cookie的域名(不同级有不同限制)path: 可访问此cookie的页面路径expires/Max-Age: cookie超时时间, 默认为SessionSize: cookie大小http: 即httponly属性, true时只有http请求头会带有此信息, 而不能通过document.cookie来访问, 加以限制，使 Cookie 不能被 JavaScript 脚本访问secure: 设置是否只可通过https来传递此条cookie</code></pre><p>怎么避免localstorage存满了怎么办</p><p>(1). 划分域名。各域名下的存储空间由各业务组统一规划使用</p><p>(2). 跨页面传数据：考虑单页应用、优先采用 url 传数据</p><p>(3). 最后的兜底方案：清掉别人的存储</p><p>给每个文件设置时间，当存满后，对localstorage里面的文件进行排序，删除时间最久的插入最新的</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p><strong>指一个域下的文档或脚本试图去请求另一个域下的资源，由于浏览器同源策略限制而产生</strong></p><p><strong>同源策略: 协议+域名+端口三者相同且必须相同</strong></p><h3 id="1-JSONP实现跨域"><a href="#1-JSONP实现跨域" class="headerlink" title="(1). JSONP实现跨域"></a>(1). JSONP实现跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;http://example.com/jsonp/getSomething?uid=123&amp;callback=hadleResponse&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br><span class="line"><span class="comment">/*handleResponse(&#123;&quot;data&quot;: &quot;hey&quot;&#125;)*/</span></span><br></pre></td></tr></table></figure><p>动态添加<code>script</code>的标签，可控的去请求远端js并执行，这种跨域方式只能进行GET请求</p><p>当我们通过新建一个script标签请求时，后台会根据相应的参数来生成相应的JSON数据。比如说上面这个链接，传递了handleResponse给后台，然后后台根据这个参数再结合数据生成了handleResponse({“data”: “hey”})。</p><p>紧接着，这个返回的JSON数据其实就可以被当成一个js脚本，就是对一个函数的调用。<br>由于我们事先已经声明了这么一个回调函数，于是当资源加载进来的时候，直接就对函数进行调用，于是数据当然就能获取到了。</p><h3 id="2-CORS跨域"><a href="#2-CORS跨域" class="headerlink" title="(2). CORS跨域"></a>(2). CORS跨域</h3><pre><code>只要同时满足以下两大条件，就属于简单请求。</code></pre><p>（1) 请求方法是以下三种方法之一：</p><p><strong>HEAD GET POST</strong></p><p>（2）HTTP的头信息不超出以下几种字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><h4 id="a-Access-Control-Allow-Origin"><a href="#a-Access-Control-Allow-Origin" class="headerlink" title="a. Access-Control-Allow-Origin"></a>a. Access-Control-Allow-Origin</h4><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><h4 id="b-Access-Control-Allow-Credentials"><a href="#b-Access-Control-Allow-Credentials" class="headerlink" title="b. Access-Control-Allow-Credentials"></a>b. Access-Control-Allow-Credentials</h4><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性</p><h4 id="c-Access-Control-Expose-Headers"><a href="#c-Access-Control-Expose-Headers" class="headerlink" title="c. Access-Control-Expose-Headers"></a>c. Access-Control-Expose-Headers</h4><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><p>总的来说，CORS实现跨域的方法就是根据请求头的Origin值和响应头的Access-Control-Request-Headers和Access-Control-Request-Method的值进行比对，通过了就可以请求成功，没通过就请求失败。</p><h3 id="3-Nginx反向代理接口跨域"><a href="#3-Nginx反向代理接口跨域" class="headerlink" title="(3). Nginx反向代理接口跨域"></a>(3). Nginx反向代理接口跨域</h3><p>实现思路：通过Nginx配置一个代理服务器（域名与example1相同，端口不同）做跳板机，反向代理访问example2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h2 id="用户输入url到页面展示的流程"><a href="#用户输入url到页面展示的流程" class="headerlink" title="用户输入url到页面展示的流程"></a>用户输入url到页面展示的流程</h2><p>(1). 输入地址: 浏览器会自动在书签和浏览历史中搜寻，如果匹配则自动补全，在chrome中如果地址命中了缓存，会直接调用缓存展示页面;</p><p>(2). 浏览器查询域名的IP地址(发送请求至DNS服务器): 浏览器会在本地寻找是否有匹配的映射，如果有直接使用映射的IP地址，如果没有，浏览器会发送DNS请求DNS服务器，DNS服务器的作用在于根据请求中的域名返回与之对应IP地址;</p><p>DNS查找顺序: 浏览器缓存–&gt; 操作系统缓存–&gt; 本地host文件 –&gt; 路由器缓存–&gt; ISP DNS缓存 –&gt; 顶级DNS服务器/根DNS服务器</p><p>本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问</p><p>(3). 浏览器获取IP地址请求TCP/IP连接，客户端和服务器之间进行三次握手的链接，随后发送HTTP请求:</p><p>浏览器获取IP地址后会使用一个随机端口发送TCP连接请求，经过层层路由设备进入服务端，建立TCP/IP连接，随后浏览器会发送一个http请求;</p><p>(4). 服务器解析TCP连接解析HTTP请求;</p><p>(5). 服务器返回一个http响应: http响应由三个部分构成: 状态行，响应头，响应正文;</p><p>(6). 浏览器解析html: 构建dom树 =&gt; 构建render树 =&gt; 布局render树 =&gt; 绘制render树;</p><p>(7). 浏览器解析外联js css: 在解析html的过程中如果碰到外联的js脚本,会中断html的解析,等待js脚本下载解析完成后再恢复html的解析流程,构建完dom树,dom样式树,执行脚本后,页面就正确的展示出来了 </p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说同一时间内只能做一件事情，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。这就涉及到事件循环的问题</p><p>(8). 连接结束四次挥手</p><h2 id="OSI网络分层模型，五层协议，-TCP-IP网络分层模型"><a href="#OSI网络分层模型，五层协议，-TCP-IP网络分层模型" class="headerlink" title="OSI网络分层模型，五层协议， TCP/IP网络分层模型"></a>OSI网络分层模型，五层协议， TCP/IP网络分层模型</h2><h3 id="OSI网络分层模型"><a href="#OSI网络分层模型" class="headerlink" title="OSI网络分层模型"></a>OSI网络分层模型</h3><p>(1). 应用层: 文件传输，常用协议http, snmp, ftp; 报文</p><p>(2). 表示层: 数据格式化，代码转换，数据加密;</p><p>(3). 会话层: 建立，解除会话; </p><p>(4). 传输层: 提供端对端的接口， tcp，udp; 报文段/用户数据报</p><p>(5). 网络层: 为数据包选择路由， ip, icmp; 数据报</p><p>(6). 数据链路层: 传输有地址的帧; （Ethernet, FDDI）帧</p><p>(7). 物理层: 二进制的数据形式在物理媒体上传输数据; 比特</p><h3 id="五层"><a href="#五层" class="headerlink" title="五层:"></a>五层:</h3><p>(1). 物理层<br>(2). 数据链路层<br>(3). 网络层<br>(4). 运输层<br>(5). 应用层</p><h3 id="TCP-IP网络分层模型"><a href="#TCP-IP网络分层模型" class="headerlink" title="TCP/IP网络分层模型"></a>TCP/IP网络分层模型</h3><p>(1). 网络接口层<br>(2). 网际层IP<br>(3). 运输层(TCP或UDP)<br>(4). 应用层(Telnet, FTP, SMTP)</p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>(1). UDP: 无连接; 面向报文，只是报文的搬运工; 不可靠，没有拥塞控制; 高效，头部开销只有8字节; 支持一对一，一对多，多对多，多对一; 适合直播，视频，语音，会议等实时性要求高的</p><p>(2). TCP: 面向连接: 传输前需要先连接; 可靠的传输; 流量控制: 发送方不会发送速度过快，超过接收方的处理能力; 拥塞控制: 当网络负载过多时能限制发送方的发送速率; 不能提供延时保障; 不提供最小带宽保障</p><h3 id="TCP协议保证可靠传输的手段"><a href="#TCP协议保证可靠传输的手段" class="headerlink" title="TCP协议保证可靠传输的手段"></a>TCP协议保证可靠传输的手段</h3><p>(1). 应用数据块分割成TCP认为合适发送的数据块;<br>(2). TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层;<br>(3). 校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。TCP的接收端会丢弃重复的数据.;<br>(4). TCP 的接收端会丢弃重复的数据。;<br>(5). 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）;<br>(6). 当网络拥塞时，减少数据的发送。;<br>(7). ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。;<br>(8). 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 </p><h3 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因:"></a>三次握手的原因:</h3><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p><p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p><p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p><p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放</p><p>四次挥手的原因: TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送，之后就会中断这次TCP连接。</p><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p> HTTP是一个在计算机世界里专门在两点之间传输文字，图片，音频等超文本数据的约定和规范</p><h2 id="常见HTTP请求方法"><a href="#常见HTTP请求方法" class="headerlink" title="常见HTTP请求方法"></a>常见HTTP请求方法</h2><p> 在HTTP1.0中有三种方法分别是<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>GET</code>是从指定资源中请求数据，<code>POST</code>向指定的资源提交要被处理的数据，<code>HEAD</code>类似于<code>GET</code>请求但不返回具体内容，只有头部，可检查超链接的有效性和检查网页是否被修改</p><p>HTTP1.1中加入了<code>PUT</code>替换或创建指定资源，<code>DELETE</code>对指定资源进行删除</p><p>HTTP1.1在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content)</p><p>HTTP2.0中加入了<code>OPTION</code>用于获取目的资源所支持的通信选项，比如服务器支持的请求方式, <code>TRACE</code>: 实现沿通向目标资源的路径的消息环回(loop-back)测试，提供一种实用的debug机制，<code>connect</code>为代理服务器准备的</p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a><code>GET</code>和<code>POST</code>的区别</h2><p>(1). get参数通过url传递，post放在request body中；</p><p>(2). get请求在url中传递的参数是有长度限制的，而post没有；</p><p>(3). get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息；</p><p>(4). get只能进行url编码，而post支持多种编码方式</p><h2 id="HTTP2-0与HTTP1-1区别"><a href="#HTTP2-0与HTTP1-1区别" class="headerlink" title="HTTP2.0与HTTP1.1区别"></a>HTTP2.0与HTTP1.1区别</h2><p>(1). HTTP2.0允许多路复用 (通过二进制分帧层实现);</p><p>(2). 首部压缩，在HTTP1中HTTP请求和响应都是由状态行，请求/响应头部，消息主题三部分组成;</p><p>(3). 设置请求的优先级，可以设置让某些重要的数据优先被服务器处理并返回。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="(1). 对称加密"></a>(1). 对称加密</h4><p>对称加密就是通信的双方都持有同一个密钥，加密和解密都是使用这一个密钥进行的</p><p>优点: 加密和解密的速度快，不会造成性能上太大的损失，尤其是在加密大量数据的情况下</p><p>缺点: 商定加密规则的时候不安全</p><h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="(2). 非对称加密"></a>(2). 非对称加密</h4><p>非对称加密存在两个密钥，一个称为公钥一个称为私钥，既可以使用公钥加密，也可以使用私钥加密，但是使用公钥加密那么就只有私钥才能解密，使用私钥加密就只能使用公钥解密</p><p>优点: 公钥是任何人都可以获取的，经过公钥加密的内容，只有私钥才可以解开</p><p>缺点: 必须保证私钥不能泄露，否则将无加密可言; 非对称加密相对于对称加密而言性能损耗较大，非对称加密还有一个最大的漏洞，中间人攻击</p><p>https = http + tls/ssl</p><h3 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h3><p>(1). 客户端发送’client hello’ 包含密码信息和随机字符串’client random’等;<br>(2). 服务器响应’server hello’包含密码组合和数字证书以及随机字符串’server random等’;<br>(3). 客户端验证数字证书并从证书种获取公钥，生成下一个随机字符串’premaster secret’并用公钥将其加密;<br>(4). 客户端发送加密后的premaster secret给服务器;<br>(5). 服务器使用私钥解密获取premaster secret;<br>(6). 客户端和服务器双方使用相同的算法，并使用client random, server random和premaster secret生产相同的密钥key，用于后面的对称加密;<br>(7). 客户端发送finished;<br>(8). 服务器发送finished;;<br>(9). 成功简历安全连接，双方使用共同的密钥key对称加密进行安全通信;</p><p>使用数字签名，我们能够鉴别信息的发送者，(私钥加密签名)</p><h2 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h2><p>(1). HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费;</p><p>(2). HTTP协议运行在TCP之上，所有的传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都是经过加密的;</p><p>(3). HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不太一样，前者是80，后者是443;</p><p>(4). HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题;</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>解析顺序首先从浏览器缓存，操作系统缓存和本地DNS缓存逐级查找，然后从本地DNS服务器，根DNS，顶级DNS以及权威DNS层层递归查询</p><p>不过传统的 DNS 有很多问题(解析慢、更新不及时)，HTTPDNS 通过客户端 SDK 和服务端配合，直接通过 HTTP 调用解析 DNS 的方式，可以绕过传统 DNS 这些缺点，实现智能调度。</p><h3 id="DNS查询的两种方式"><a href="#DNS查询的两种方式" class="headerlink" title="DNS查询的两种方式"></a>DNS查询的两种方式</h3><h4 id="1-递归解析"><a href="#1-递归解析" class="headerlink" title="(1). 递归解析;"></a>(1). 递归解析;</h4><p>局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端</p><h4 id="2-迭代解析"><a href="#2-迭代解析" class="headerlink" title="(2). 迭代解析;"></a>(2). 迭代解析;</h4><p>局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>浏览器缓存是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者子啊次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览</p><h3 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h3><p>浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；</p><p>下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；</p><p>服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；</p><p>如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>通常浏览器缓存策略分为两种：强缓存（Expires，cache-control）和协商缓存（Last-modified ，Etag），并且缓存策略都是通过设置 HTTP Header 来实现的。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强制缓存。</p><p>Cache-Control<br>当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Expires和Cache-Control的区别<br>Expires 是http1.0的产物，Cache-Control是http1.1的产物</p><p>两者同时存在的话，Cache-Control优先级高于Expires；</p><p>在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法</p><p>Expires是一个具体的服务器时间，这就导致一个问题，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control是一个时间段，控制就比较容易</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>ETag和If-None-Match</p><p>这两个要一起说。Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存</p><p>Last-Modified和If-Modified-Since</p><p>这两个也要一起说。Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。</p><p>ETag和Last-Modified区别</p><p>在方式上，Etag是对资源的一种唯一标识，而Last-Modified是该资源文件最后一次更改时间</p><p>在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p><p>在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p><p>在优先级上，服务器校验优先考虑Etag。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h3 id="1-1xx-Informational-收到请求，正在处理"><a href="#1-1xx-Informational-收到请求，正在处理" class="headerlink" title="(1). 1xx (Informational): 收到请求，正在处理"></a>(1). 1xx (Informational): 收到请求，正在处理</h3><p>100 (继续): 请求者应当继续提出请求，服务器返回此代码表示已经收到请求的第一部分，正在等待其余部分;</p><p>101 (切换协议): 请求者已要求服务器切换协议，服务器确认并准备切换;</p><h3 id="2-2xx-Successful-该请求已成功收到，理解并接受"><a href="#2-2xx-Successful-该请求已成功收到，理解并接受" class="headerlink" title="(2). 2xx (Successful): 该请求已成功收到，理解并接受"></a>(2). 2xx (Successful): 该请求已成功收到，理解并接受</h3><p>200 (成功): 服务器完成已成功处理了请求，通常，这表示服务器提供了请求的网页;</p><p>201 (已创建): 请求成功并且服务器创建了新的资源;</p><p>202 (已接受): 服务器已接收请求，但尚未处理;</p><p>203 (非授权信息): 服务器已成功处理了请求，但返回的信息可能来自另一来源;</p><p>204 (无内容): 服务器成功处理了请求，但没有返回任何内容;</p><p>205 (重置内容): 响应执行成功，重置页面(Form表单)，方便用户下次输入;</p><p>206 (部分内容): 服务器成功处理了部分<code>get</code>请求;</p><h3 id="3-3xx-Redirection-重定向"><a href="#3-3xx-Redirection-重定向" class="headerlink" title="(3). 3xx (Redirection): 重定向"></a>(3). 3xx (Redirection): 重定向</h3><p>300 (多种选择): 针对请求，服务器可执行多种操作，服务器可根据请求者(user agent)选择一项操作，或提供操作列表供请求者选;</p><p>301 (永久移动): 请求的网页已永久移动到新位置，服务器返回此响应(对<code>GET</code>或<code>HEAD</code>请求的响应)时，会自动将请求者转到新位置;</p><p>302 (临时移动): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;</p><p>303 (查看其他位置): 请求者应当对不同的位置使用单独的<code>GET</code>请求来检索响应时，服务器返回此代码;</p><p>304 (未修改): 自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容;</p><p>305 (使用代理): 请求者只能使用代理访问请求的网页，如果服务器返回此响应，还表示请求者应使用代理;</p><p>307 (临时重定向): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;</p><h3 id="4-4xx-Client-Error-该请求包含错误的语法或不能为完成"><a href="#4-4xx-Client-Error-该请求包含错误的语法或不能为完成" class="headerlink" title="(4). 4xx (Client Error): 该请求包含错误的语法或不能为完成"></a>(4). 4xx (Client Error): 该请求包含错误的语法或不能为完成</h3><p>400 (错误请求): 服务器不理解请求的语法;</p><p>401 (未授权): 请求要求身份验证，对于需要登陆的网页，服务器可可能返回此响应;</p><p>403 (禁止): 服务器拒绝请求;</p><p>404 (未找到): 服务器找不到请求的网页;</p><p>405 (方法禁用): 禁用请求中指定的方法;</p><p>406 (不接受): 无法使用请求的内容特性响应请求的网页;</p><p>407 (需要代理授权): 此状态码与401(未授权)类似，但指定请求者应当授权使用代理;</p><p>408 (请求超时): 服务器等候请求时发生超时;</p><p>409 (冲突): 服务器在完成请求时发生冲突，服务器必须在响应中包含有关冲突的信息;</p><p>410 (已删除): 如果请求的资源已永久删除，服务器就会返回此响应;</p><p>411 (需要有效长度): 服务器不接受不含有效内容长度标头字段的请求;</p><p>412 (未满足前提条件): 服务器未满足请求者在请求中设置的其中一个前提条件;</p><p>413 (请求实体过大): 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力;</p><p>414 (请求URL过长): 请求的URL(通常为网址)过长，服务器无法处理;</p><p>415 (不支持的媒体类型): 请求的格式不接受请求页面的支持;</p><p>416 (请求范围不符合要求): 如果页面无法提供请求的范围，则服务器会返回此状态状态码;</p><p>417 (未满足期望值): 服务器未满足”期望”请求标头字段的要求;</p><h3 id="5-5xx-Server-Error-服务器错误-504-网关超时"><a href="#5-5xx-Server-Error-服务器错误-504-网关超时" class="headerlink" title="(5). 5xx (Server Error): 服务器错误 504 - 网关超时"></a>(5). 5xx (Server Error): 服务器错误 504 - 网关超时</h3><p>500 (服务器内部错误): 服务器遇到错误，无法完成请求;</p><p>501 (尚未实施): 服务器不具备完成请求的功能。例如服务器无法识别请求方法时可能会返回此代码;</p><p>502 (错误网关): 服务器作为网关或代理，从上游服务器收到无效响应;</p><p>503 (服务不可用): 服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态;</p><p>504 (网关超时): 服务器作为网关或代理，但是没有及时从上游服务器收到请求;</p><p>505 (HTTP版本不受支持): 服务器不支持请求中所用的HTTP版本协议;</p><h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><p>请求报文: 请求行 (方法字段，URL字段，HTTP协议版本字段)，请求头，空行，请求数据</p><p>响应报文: 响应行(协议版本，状态码以及描述)，响应头，空行，响应体</p><h2 id="HTTP常用的首部字段"><a href="#HTTP常用的首部字段" class="headerlink" title="HTTP常用的首部字段"></a>HTTP常用的首部字段</h2><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>Cache-Control 控制缓存<br>Connection 连接管理<br>Transfor-Encoding 报文主体的传输编码格式<br>Date 创建报文的时间<br>Upgrade 升级为其他协议</p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>Host 请求资源所在的服务器 (唯一一个HTTP/1.1规范里要求必须出现的字段)Accept 客户端或者代理能够处理的媒体类型If-Match 比较实体标记 (ETag)If-None-Match 比较实体标记 (ETag)，与 If-Match 相反If-Modified-Since 比较资源更新时间 (Last-Modified)If-Unmodified-Since 比较资源更新时间 (Last-Modified)， 与 If-Modified-Since 相反Range 实体的字节范围请求User-Agent 客户端信息</p><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>Accept-Ranges 能接受的字节范围<br>Location 命令客户端重定向的 URI<br>ETag 能够表示资源唯一资源的字符串<br>Server 服务器的信息</p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>Allow 资源可支持 HTTP 请求方法Last-Modified 资源最后修改时间Expires 实体主体过期时间Content-Language 实体资源语言Content-Encoding 实体编码格式Content-Length 实体大小Content-Type 实体媒体类型</p><h2 id="URL包含哪几个部分"><a href="#URL包含哪几个部分" class="headerlink" title="URL包含哪几个部分"></a>URL包含哪几个部分</h2><p>(1). 协议类型;<br>(2). 主机名;<br>(3). 端口号;<br>(4). 路径;<br>(5). 参数(:parameters);<br>(6). 查询(?query);<br>(7). 信息片段(fragment);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程与线程的区别&quot;&gt;&lt;a href=&quot;#进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的区别&quot;&gt;&lt;/a&gt;进程与线程的区别&lt;/h2&gt;&lt;p&gt;进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="网络" scheme="https://andylinwenqin.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架面试总结</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-04T15:39:19.000Z</published>
    <updated>2021-09-12T12:41:42.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="真实DOM和其解析流程"><a href="#真实DOM和其解析流程" class="headerlink" title="真实DOM和其解析流程"></a>真实DOM和其解析流程</h2><p>(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵DOM树;</p><p>(2). 生成样式表，用css分析器，分析css文件和元素上的inline样式，生成页面的样式表;</p><p>(3). 构建Render树: 将DOM树和样式表关联起来，构建一颗Render树(Attachment) 每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)，这些render对象最终会构建成一颗render树;</p><p>(4). 确定节点坐标: 根据Render树结构，为每个Render树上的节点确定一个在显示屏上出现的精确坐标;</p><p>(5). 绘制页面: 根据Render树和节点显示坐标，然后调用每个节点的paint方法，将它门绘制出来;</p><p>注意点:</p><p>(1). 构建DOM树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个HTML文档解析完成之后才开始构建render树和布局;</p><p>(2). Render树DOM树和CSS样式表这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析以及一边渲染;</p><p>(3). CSS的解析是从右往左逆向解析的，嵌套标签越多，解析越慢;</p><p>(4). 用我们传统的开发模式，原声JS操作DOM时，浏览器会从构建DOM树开始从头到尾执行一边流程，在一次操作中，我们需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会立即马上执行流程，最终执行10次，这样会导致页面卡顿并且影响用户体验;</p><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>虚拟DOM的好处：</p><p>虚拟DOM就是为了解决浏览器性能问题而被设计出来的，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attach到DOM树上，再进行后续操作，避免大量无谓的计算量，所以用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制</p><p>比较两颗虚拟DOM树的差异 - diff算法</p><p>diff算法用来比较virtual dom树的差异，如果两颗树完全比较，那么diff算法的时间复杂度位O(n^3)，但是在前端当中，会很少跨越层级地移动DOM元素，所以virtual dom只会对同一层级的元素进行对比，这样算法复杂度就可以达到O(n)</p><p>(1).深度优先遍历记录差异;</p><p>(2). 差异类型;</p><ol><li><p>节点替换：节点改变了，例如将上面的 div 换成 h1;</p></li><li><p>顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；</p></li><li><p>属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；</p></li><li><p>文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”;</p></li></ol><p>(3). 列表对比算法</p><p>子节点的对比算法，例如:p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动</p><h2 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h2><p>(1). Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能而React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染;</p><p>(2). Vue支持双向绑定，而React的数据流一直提倡单向数据流，他称之为 onChange/setState()模式。;</p><p>(3). 模版渲染方式不同 React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现;</p><h2 id="SPA单页面应用"><a href="#SPA单页面应用" class="headerlink" title="SPA单页面应用"></a>SPA单页面应用</h2><p>其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。</p><p>优 点: 减轻服务端的压力，可维护性高</p><p>缺点: 首次加载速度慢，搜索引擎优化效果不好</p><p>为什么首屏时间慢，SEO 差？<br>单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。</p><p>SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。</p><p>多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。</p><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的contorller演变成ViewModel,Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p><h2 id="介绍下Vue的响应式数据"><a href="#介绍下Vue的响应式数据" class="headerlink" title="介绍下Vue的响应式数据"></a>介绍下Vue的响应式数据</h2><p>Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)</p><p><strong>Vue3.x响应式数据原理</strong><br>    Vue3.x该用proxy代替Object.defineProperty. 因为Proxy可以直接监听对象和数组的变化<br>    <strong>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</strong><br>        判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>    <strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong><br>        我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h2 id="Vue2-x中如何监测数组变化"><a href="#Vue2-x中如何监测数组变化" class="headerlink" title="Vue2.x中如何监测数组变化"></a>Vue2.x中如何监测数组变化</h2><p>​    使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控，这样就实现了监测数组变化。</p><h2 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理"></a>nextTick实现原理</h2><p>在下次DOM更新循环结束之后执行延迟回调，nextTick主要使用了宏任务和微任务，根据执行环境分别尝试采用(1).promise;(2).MutationObserver;(3).setImmediate;(4).如果以上都不行采用setTimeout定义一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p> Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模版，挂载Dom,渲染, 更新 再渲染， 销毁等一系列过程，我们称这个为vue的生命周期。</p><p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段: 初始化，运行中，销毁</p><p>(1). 实例，组件通过new Vue()创建出来之后会初始化事件和生命周期，然后就会执行<code>beforeCreate</code>钩子函数，这个时候数据还没有挂载，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</p><p>(2). 挂载数据，绑定事件等，然后执行<code>created</code>函数，这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发update函数，在这里可以再渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以再这里初始数据的获取</p><p>(3). 接下里开始实例或者组件对应的模版，编译模版为虚拟dom放入到render函数中准备渲染，然后执行<code>beforeMount</code>钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染，在这里也可以更改数据，不会触发update，这里是渲染前最后一次更改数据的机会，不会触发其他钩子函数，一般可以在这里做初始数据的获取</p><p>(4). 接下来开始render，渲染出真实dom，然后执行<code>mounted</code>钩子函数，此时，组件已经出现在页面中，数据，真实dom都已经处理好了，事件已经挂载好了，可以在这里操作真实dom等事情；</p><p>(5). 当组件或实例的数据更改之后，会立即执行<code>beforeUpdate</code>,然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用<code>diff</code>算法进行对比之后重新渲染，一般不做什么事</p><p>(6). 当更新完成后，执行<code>updated</code>，数据已经更新完成，dom也重新render完成，可以操作更新后的虚拟dom</p><p>(7). 当经过某种途径调用$destory方法之后，立即执行<code>beforeDestroy</code>,一般在这里做一些善后工作，例如清除计时器，清除非指令绑定的事件等</p><p>(8). 组件的数据绑定，监听去掉后只剩下dom空壳，这个时候执行<code>destoryed</code>,在这里做善后工作也可以</p><p> 嵌套组件的生命周期的执行顺序：</p><pre><code>vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted</code></pre><p>更改组件数据　　修改子组件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted ——&gt; son.beforeUpdate ——&gt; son.updated</span><br></pre></td></tr></table></figure><p> Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。</p><p>当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它</p><h2 id="Vue的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue的父组件和子组件生命周期钩子函数执行顺序"></a>Vue的父组件和子组件生命周期钩子函数执行顺序</h2><p><strong>加载渲染过程</strong></p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><p><strong>子组件更新过程</strong></p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><p><strong>父组件更新过程</strong></p><p>父 beforeUpdate -&gt; 父 updated</p><p><strong>销毁过程</strong></p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p><p><strong>在哪个生命周期内调用异步请求</strong></p><p>可以在钩子函数created，beforeMount, mounted中进行调用，因为在这三个钩子函数中，data已经创建，可以将服务端返回的数据进行赋值，</p><p><strong>在什么阶段才能访问操作</strong>DOM</p><p>在钩子函数mounted被调用前，Vue已经将编译号的模版挂载到页面上，所以在mounted中可以访问操作DOM</p><h2 id="created和mounted的区别"><a href="#created和mounted的区别" class="headerlink" title="created和mounted的区别"></a>created和mounted的区别</h2><p><code>created</code>: 在模版渲染成html前调用，即挂载数据和绑定事件等等，此时是无法对html的dom节点进行操作的，此时更改数据不会触发<code>update</code>函数</p><p><code>mounted</code>: 在模版渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作，此时更改数据会触发<code>update</code>函数</p><h2 id="Vue双向绑定的原理"><a href="#Vue双向绑定的原理" class="headerlink" title="Vue双向绑定的原理"></a>Vue双向绑定的原理</h2><p>vue数据双向绑定事通过数据劫持结合发布者-订阅者模式的方式来实现的。<br>vue通过<code>Object.defineProperty()</code>这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p><p><code>Object.defineProperty()</code>的第一个缺陷，无法监听数组变化，第二个缺陷是只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历</p><ol><li><p>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p></li><li><p>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对 应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></li><li><p>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p></li></ol><p>在自身实例化时往属性订阅器(dep)里面添加自己 ，自身必须有一个 update() 方法，待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</p><ol start="4"><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听<br>自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变 更的双向绑定效果。</li></ol><p><strong>v-model本质上是一个父子通信组件的语法糖，通过props和$emit实现</strong></p><h2 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h2><p>v-if: 是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块</p><p>v-show: 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的‘display’属性进行切换</p><p>所以v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景</p><h2 id="v-for中-key-值的作用"><a href="#v-for中-key-值的作用" class="headerlink" title="v-for中 key 值的作用"></a>v-for中 key 值的作用</h2><p>在列表渲染过程中，key可以提高列表渲染的效率，提高页面的性能，因为<code>v-for</code>更新已渲染的元素列表时，默认用就地复用的原则对列表进行修改，他会根据key的值去判断某个值是否修改，如果修改了key，则重新渲染这一项，否则复用之前的元素。</p><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><p>父传子: 通过<code>v-on</code>绑定一个变量名称，在子组件中用props进行接收</p><p>子传父: 在子组件中绑定一个方法，将参数传入之后通过<code>$emit()</code>传递出去， <code>$emit()</code>里的参数是父组件中定义的方法名称以及参数</p><h2 id="为什么组件里的data必须是函数而不是对象？"><a href="#为什么组件里的data必须是函数而不是对象？" class="headerlink" title="为什么组件里的data必须是函数而不是对象？"></a>为什么组件里的<code>data</code>必须是函数而不是对象？</h2><p> 因为组件在Vue中是可以重复调用的，那么如果这个组件被多次调用并且<code>data</code>是对象的话，所有这个组件的实例会共同share一份<code>data</code>这样就会造成数据的泄漏，并且组件中的数据会对不上号，可能实例a的数据应用在了实例b上， 所以如果<code>data</code>是函数，就能确保每一个实例都有一份自己的<code>data</code>,使得统一组件的不同实例间的<code>data</code>不会互相影响。</p><h2 id="怎样理解Vue的单向数据流"><a href="#怎样理解Vue的单向数据流" class="headerlink" title="怎样理解Vue的单向数据流"></a>怎样理解Vue的单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h2 id="Vue中key的作用"><a href="#Vue中key的作用" class="headerlink" title="Vue中key的作用"></a>Vue中key的作用</h2><p> key是为Vue中vnode的唯一标记，通过key，我们的diff操作可以更加准确，更快速，Vue的diff过程可以概括为: oldCh和newCh各有两个头尾的变量oldStartIndex, oldEndIndex和newStartIndex, newEndIndex，新旧节点会两两对比，即一共有四种比较方式, 如果以上4种都没有匹配，如果设置了key，就会用key再进行比较，在比较的过程中，遍历会往中间靠，一旦StartIndex &gt; EndIndex表明oldCh和newCh至少一个已经遍历完了，就会结束比较(如果没有key,4种都没有匹配成功就会将newStartIndex所在的节点直接生成新的节点且插入到原有的root的子节点中)</p><p>VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。</p><p>所以key是Vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确，更快速</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。<br>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p><h2 id="Vue2-x和Vue3-x渲染器的diff不同处"><a href="#Vue2-x和Vue3-x渲染器的diff不同处" class="headerlink" title="Vue2.x和Vue3.x渲染器的diff不同处"></a>Vue2.x和Vue3.x渲染器的diff不同处</h2><p>简单来说，diff算法的过程</p><p>(1). 同级比较，再比较子节点;<br>(2). 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除);<br>(3). 比较都有子节点的情况;<br>(4). 递归比较子节点;</p><p>正常Diff两个树的时间复杂度时O(N ^ 3),但实际情况下我们很少会进行跨层级的移动DOM,所以Vue将Diff进行优化，从O(N^3) -&gt; O(N)只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较</p><h3 id="vue2-vu3算法区别"><a href="#vue2-vu3算法区别" class="headerlink" title="vue2 vu3算法区别"></a>vue2 vu3算法区别</h3><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。</p><p>Vue3的diff算法在创建VNode时就确定其类型1，以及在mounted/patch的过程中采用位运算来判断一个VNode的类型，在这个基础上再配合核心的Diff算法</p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点：</p><p>首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；</p><p>在vnode没有文本节点的情况下，进入子节点的 diff；</p><ul><li>当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；</li></ul><ul><li>若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中；</li></ul><ul><li>若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；</li></ul><ul><li>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。</li></ul><h2 id="Vue事件绑定原理"><a href="#Vue事件绑定原理" class="headerlink" title="Vue事件绑定原理"></a>Vue事件绑定原理</h2><p>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p><h2 id="watch中deep和immediate的作用？"><a href="#watch中deep和immediate的作用？" class="headerlink" title="watch中deep和immediate的作用？"></a>watch中deep和immediate的作用？</h2><p>deep，默认值是 false，代表是否深度监听。<br>immediate:true代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。</p><h2 id="Vue模版编译原理"><a href="#Vue模版编译原理" class="headerlink" title="Vue模版编译原理"></a>Vue模版编译原理</h2><p>简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：</p><ol><li>生成AST树</li><li>优化</li><li>codegen</li></ol><p>首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。</p><p>使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p><p>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的AST树转换为可执行的代码。</p><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><ul><li>Vue-router是什么？有哪些组件？</li></ul><p>Vue-router是<code>Vue.js</code>官方的路由管理器，它和<code>Vue.js</code>的核心深度集成，让构建单页面应用变得易如反掌</p><p>共有三个组件分别是<code>&lt;router-link&gt;, &lt;router-view&gt;和&lt;keep-alive&gt;(vue2.0提供)</code></p><ul><li>Vue-router有几种钩子函数？具体时什么以及参数</li></ul><p>(1). 前置守卫 在进入这个路由之前;<br>(2). 全局解析守卫;<br>(3). 后置钩子 ;<br>(4). 路由独享的钩子;<br>(5). 组件内的导航钩子</p><ul><li>导航解析流程</li></ul><p>(1). 导航被触发;</p><p>(2). 在失活的组件里调用<code>beforeRouteLeave</code>守卫;</p><p>(3). 调用全局的<code>beforeEach</code>守卫;</p><p>(4). 在重用的组件里调用<code>beforeRouteUpdate</code>守卫;</p><p>(5). 在路由配置里调用<code>beforeEnter</code>;</p><p>(6). 解析异步路由组件;</p><p>(7). 在被激活的组件里调用<code>beforeRouterEnter</code>;</p><p>(8). 调用全局的<code>beforeResolve</code>守卫;</p><p>(9). 导航被确认;</p><p>(10). 调用全局的<code>afterEach</code>钩子;</p><p>(11). 触发DOM更新;</p><p>(12). 调用<code>beforeRouterEnter</code>守卫中传给<code>next</code>的回调函数，创建好的组件实例会作为回调函数的参数传入;</p><h2 id="route和-router的区别是什么？"><a href="#route和-router的区别是什么？" class="headerlink" title="$route和$router的区别是什么？"></a>$route<code>和</code>$router的区别是什么？</h2><p><code>router</code>为vue-router的实例，是一个全局路由对象，包含了路由跳转的方法，钩子函数等</p><p><code>route</code>是路由信息对象和跳转的路由对象，每一个路由都一个route对象，是一个局部对象，包含<code>path, params, hash, query, fullpath, matched, name</code>等路由信息参数</p><h2 id="Vue-router传参方式"><a href="#Vue-router传参方式" class="headerlink" title="Vue-router传参方式"></a>Vue-router传参方式</h2><p>(1). 直接调用<code>$router.push</code>实现携带参数的跳转;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;path: `/describe/$&#123;id&#125;`&#125;)</span><br><span class="line"></span><br><span class="line">// 对应的路由配置</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/describe/:id&#x27;,</span><br><span class="line">    name: &#x27;Describe&#x27;,</span><br><span class="line">    component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure><p>(2).父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。</p><pre><code>this.$router.push(&#123;    name: &#39;Describe&#39;,    params: &#123;        id: id    &#125;&#125;)&#123;    path: &#39;/describe/:id&#39;,    name: &#39;Describe&#39;,    component: Describe&#125;this.$route.params.id</code></pre><p>(3). 父组件：使用path来匹配路由，然后通过query来传递参数;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">  path: &#x27;/describe&#x27;,</span><br><span class="line">  query: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> path: &#x27;/describe&#x27;,</span><br><span class="line"> name: &#x27;Describe&#x27;,</span><br><span class="line"> component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.query.id</span><br></pre></td></tr></table></figure><h2 id="Vue-router的跳转方式"><a href="#Vue-router的跳转方式" class="headerlink" title="Vue-router的跳转方式"></a>Vue-router的跳转方式</h2><p>(1). router-link;<br>(2). this.$router.push();<br>(3). this.$router.replace();<br>(4). this.$router.go();<br>(5). this.$router.forward();<br>(6). this.$router.back();</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取新的state的值，重新渲染Vue componments,界面随之更新</p><p><strong>vuex为什么需要用 mutation 这些来修改 state 数据，而不是直接更改</strong></p><p>Vuex 单向数据流有关，因为需要知道数据修改的来源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;真实DOM和其解析流程&quot;&gt;&lt;a href=&quot;#真实DOM和其解析流程&quot; class=&quot;headerlink&quot; title=&quot;真实DOM和其解析流程&quot;&gt;&lt;/a&gt;真实DOM和其解析流程&lt;/h2&gt;&lt;p&gt;(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>v-bind</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/v-bind/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/v-bind/</id>
    <published>2021-09-04T12:04:21.000Z</published>
    <updated>2021-09-05T16:18:23.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><hr><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A-HTML-Class">绑定 HTML Class</a></h2><p><a href="https://learning.dcloud.io/#/?vid=7">观看本节视频讲解</a></p><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95">对象语法</a></h3><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据 property <code>isActive</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthiness</a>。</p><p>你可以在对象中传入更多字段来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class attribute 共存。当有如下模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p><p>绑定的数据对象不必内联定义在模板里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#x27;text-danger&#x27;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<a href="https://cn.vuejs.org/v2/guide/computed.html">计算属性</a>。这是一个常用且强大的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95">数组语法</a></h3><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#x27;active&#x27;,</span><br><span class="line">  errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 是 truthy[<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1">1]</a> 时才添加 <code>activeClass</code>。</p><p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A">用在组件上</a></h3><blockquote><p>这个章节假设你已经对 <a href="https://cn.vuejs.org/v2/guide/components.html">Vue 组件</a>有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p></blockquote><p>当在一个自定义组件上使用 <code>class</code> property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。</p><p>例如，如果你声明了这个组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在使用它的时候添加一些 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>HTML 将被渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>对于带数据绑定 class 也同样适用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 为 truthy[<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1">1]</a> 时，HTML 将被渲染成为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F">绑定内联样式</a></h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-1">对象语法</a></h3><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &#x27;red&#x27;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &#x27;red&#x27;,</span><br><span class="line">    fontSize: &#x27;13px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对象语法常常结合返回对象的计算属性使用。</p><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-1">数组语法</a></h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80">自动添加前缀</a></h3><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix">浏览器引擎前缀</a>的 CSS property 时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%A4%9A%E9%87%8D%E5%80%BC">多重值</a></h3><blockquote><p>2.3.0+</p></blockquote><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p><p><strong>译者注</strong><br>[1] truthy 不是 <code>true</code>，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">MDN</a> 的解释。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Class-与-Style-绑定&quot;&gt;&lt;a href=&quot;#Class-与-Style-绑定&quot; class=&quot;headerlink&quot; title=&quot;Class 与 Style 绑定&quot;&gt;&lt;/a&gt;Class 与 Style 绑定&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;操作元素的 cla</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS动画</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/CSS%E5%8A%A8%E7%94%BB/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/CSS%E5%8A%A8%E7%94%BB/</id>
    <published>2021-09-04T08:42:38.000Z</published>
    <updated>2021-09-05T16:18:23.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS动画和实现方法"><a href="#CSS动画和实现方法" class="headerlink" title="CSS动画和实现方法"></a>CSS动画和实现方法</h1><hr><h2 id="css3颜色渐变"><a href="#css3颜色渐变" class="headerlink" title="css3颜色渐变"></a>css3颜色渐变</h2><p>CSS 渐变使您可以显示两种或多种指定颜色之间的平滑过渡。</p><p>CSS 定义了两种渐变类型：</p><ul><li><em>线性渐变</em>（向下/向上/向左/向右/对角线）</li><li><em>径向渐变</em>（由其中心定义）</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom right, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904164739.png"></p><h3 id="使用角度"><a href="#使用角度" class="headerlink" title="使用角度"></a>使用角度</h3><p>如果希望对渐变角度做更多的控制，您可以定义一个角度，来取代预定义的方向（向下、向上、向右、向左、向右下等等）。值 0deg 等于向上（to top）。值 90deg 等于向右（to right）。值 180deg 等于向下（to bottom）。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(-<span class="number">90deg</span>, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用透明度"><a href="#使用透明度" class="headerlink" title="使用透明度"></a>使用透明度</h3><p>CSS 渐变还支持透明度，也可用于创建渐变效果。</p><p>如需添加透明度，我们使用 rgba() 函数来定义色标。 rgba() 函数中的最后一个参数可以是 0 到 1 的值，它定义颜色的透明度：0 表示全透明，1 表示全彩色（无透明）。</p><p>下面的例子展示了从左开始的线性渐变。它开始完全透明，然后过渡为全色红色：</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background-image: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css3使用animation属性实现背景颜色动态渐变的效果"><a href="#css3使用animation属性实现背景颜色动态渐变的效果" class="headerlink" title="css3使用animation属性实现背景颜色动态渐变的效果"></a>css3使用animation属性实现背景颜色动态渐变的效果</h2><p>首先我们来看一下CSS3关键帧动画的基础知识</p><p>让我们先了解逐渐改变元素的动画！在CSS 3 animation属性中，您可以设置关键帧并绘制详细的运动。关于动画的时间和时机、无限的循环，只有CSS就可以指定了！</p><h3 id="什么是关键帧？"><a href="#什么是关键帧？" class="headerlink" title="什么是关键帧？"></a>什么是关键帧？</h3><p>关键帧（传递点）是在动画中定义更改的帧。我们@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，您需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。</p><p>@keyframes规则的名称声明为“ @keyframes +任意名称 ”。我将写入0％到100％的关键帧信息。0％表示开始动画，100％表示结束时间。0％from，100％可以用to替换。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> name &#123;</span><br><span class="line"> <span class="number">0%</span> &#123; <span class="attribute">background</span>: red; &#125;</span><br><span class="line"> <span class="number">50%</span> &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line"> <span class="number">100%</span> &#123; <span class="attribute">background</span>: pink; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="animation相关属性"><a href="#animation相关属性" class="headerlink" title="animation相关属性"></a>animation相关属性</h3><p><strong>animation-name（动画名）</strong></p><p>@keyframes指定中定义的名称。如果未指定此项，则不会执行动画。此外，如果指定的动画名称与任何关键帧都不匹配，则不会执行该关键帧。</p><p><strong>animation-duration（动画持续时间）</strong></p><p>通过“秒+ s”指定执行一个动画的时间长度。例如，“5秒”持续5秒。如果为0，则不会执行。即使指定了负值，也会将其视为0。</p><p><strong>animation-timing-function（动画定时功能）</strong></p><p>指定动画的时间以及如何继续。您可以通过调整动画进度速度的比例来表达平滑运动。</p><p><strong>ease（初期値）</strong></p><p>ease-in</p><p>ease-out</p><p>ease-in-out</p><p>linear</p><p><strong>animation-delay（动画延迟）</strong></p><p>读取元素时，从“元素编号+ s”指定“动画开始”的时间。例如，“5秒”持续5秒。初始值0将立即执行。</p><p><strong>animation-iteration-count（动画迭代计数）</strong></p><p>指定使用数字重复动画的次数。infinite要指定无限循环，请指定。</p><p><strong>animation-direction（动画方向）</strong></p><p>指定重复动画的方向。</p><p><strong>normal …正常方向播放（初始值）</strong></p><p>alternate …在正常和偶数时间以相反方向重新生成奇数次（返回并返回…）</p><p>reverse…向后播放</p><p>alternate-reverse…反向播放</p><p><strong>animation-play-state（动画播放状态）</strong></p><p>指定动画暂停（paused）和播放（running）。但是，似乎没有太多使用。</p><p>animation-fill-mode（动画填充模式）</p><p>指定播放动画之前和之后的状态。</p><p>none（默认值）</p><p>forwards..播放后保持最后一个关键帧的状态</p><p>backwards…在播放前应用第一个关键帧的状态</p><p>both … forwards ……向前和向后都应用</p><h3 id="属性总结"><a href="#属性总结" class="headerlink" title="属性总结"></a>属性总结</h3><p>animation属性允许您分别指定每个属性的值，用空格分隔。项目可以省略，但动画名称必须在执行前写入。建议按以下顺序列出。</p><p>animation-name（动画名）</p><p>animation-duration（动画持续时间）</p><p>animation-timing-function（动画定时功能）</p><p>animation-delay（动画延迟）</p><p>animation-iteration-count（动画迭代计数）</p><p>animation-direction（动画方向）</p><p>animation-fill-mode（动画填充模式）</p><p>animation-play-state（动画播放状态）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: test <span class="number">5s</span> ease <span class="number">1s</span> infinite forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面我们来看看背景颜色改变的具体内容</strong></p><p>在了解了基础的知识之后，我们来详细看看具体的实现方法。首先，将关键帧的名称设置为“bg - color”，并将背景颜色设置为从0到100％的过渡。如果将相同的颜色设置为0％和100％，则在循环动画时它会平滑移动。我们还将描述您为基于Webkit的浏览器启用的版本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@-webkit-keyframes</span> bg-color &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">  <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span><br><span class="line">  <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span><br><span class="line">  <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span><br><span class="line">  <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> bg-color &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">  <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span><br><span class="line">  <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span><br><span class="line">  <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span><br><span class="line">  <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于此时指定整个网页的背景颜色，body以animation指定属性。值为“关键帧名称”，bg-color“更改”在10秒内添加，“，10s”指定无限循环infinite。不要忘记webkit的版本。background-color让我们指定基本背景颜色作为背景色，为动画不起作用的情况做准备。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">              <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line"><span class="css">              <span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="css">              -webkit-<span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="keyword">@-webkit-keyframes</span> bg-color &#123;</span></span><br><span class="line"><span class="css">                <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="keyword">@keyframes</span> bg-color &#123;</span></span><br><span class="line"><span class="css">                <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">            &#125; </span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>andyLin博客<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904170016.gif"></p><h2 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h2><h2 id="实现一个简单的三角形"><a href="#实现一个简单的三角形" class="headerlink" title="实现一个简单的三角形"></a>实现一个简单的三角形</h2><p>使用CSS盒模型中的border（边框）即可实现如下所示的三角形：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904170941.webp"></p><p>CSS实现简单三角形</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>首先来看在为元素添加border时，border的样子；假设有如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    border: 2px solid orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171004.webp"></p><p>border的一般使用</p><p>这是我们平常使用border最普遍的情况——往往只给border一个较小的宽度（通常为1-2px）；然而这样的日常用法就会容易让大家对border的形成方式产生<strong>误解</strong>，即认为元素的border是由四个矩形边框拼接而成。</p><p>然而事实并不是这样。实际上，元素的border是由<strong>三角形</strong>组合而成，为了说明这个问题，我们可以增大border的宽度，并为各border边设置不同的颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171017.webp"></p><p>border的形成方式</p><p>既然如此，那么更进一步，把元素的内容尺寸设置为0会发生什么情况呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171026.webp"></p><p>元素内容尺寸为0</p><p>我们将惊奇地发现，此时元素由上下左右4个三角形“拼接”而成；那么，为了实现最终的效果，即保留最下方的三角形，还应该怎么做？很简单，我们只需要把其它border边的颜色设置为<strong>白色</strong>或<strong>透明色</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171041.webp"></p><p>Duang~ 最终的简单三角形就绘制出来了。同理，如果想要得到其它边上的三角形，只需要将剩余的border边颜色设置为白色或透明色即可。</p><p>不过，被“隐藏”的上border仍然占据着空间，要想使得绘制出的三角形尺寸最小化，还需要将上border的宽度设置为0（其它情况同理）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">40px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出自-CSS绘制三角形—border法"><a href="#出自-CSS绘制三角形—border法" class="headerlink" title="出自 CSS绘制三角形—border法"></a>出自 <a href="https://www.jianshu.com/p/9a463d50e441">CSS绘制三角形—border法</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS动画和实现方法&quot;&gt;&lt;a href=&quot;#CSS动画和实现方法&quot; class=&quot;headerlink&quot; title=&quot;CSS动画和实现方法&quot;&gt;&lt;/a&gt;CSS动画和实现方法&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;css3颜色渐变&quot;&gt;&lt;a href=&quot;#css3颜色渐变</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>watch和computed</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/watch%E5%92%8Ccomputed/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/watch%E5%92%8Ccomputed/</id>
    <published>2021-09-04T07:31:54.000Z</published>
    <updated>2021-09-05T16:18:23.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算属性computed："><a href="#计算属性computed：" class="headerlink" title="计算属性computed："></a>计算属性computed：</h1><ul><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li><li>如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li></ul><h1 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a>侦听属性watch：</h1><ul><li>不支持缓存，数据变，直接会触发相应的操作；</li><li>watch支持异步；</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li></ul><h1 id="watch和computed的区别和应用场景（面试版）"><a href="#watch和computed的区别和应用场景（面试版）" class="headerlink" title="watch和computed的区别和应用场景（面试版）"></a>watch和computed的区别和应用场景（面试版）</h1><pre><code>计算属性`computed`和监听器`watch`都可以观察属性的变化从而做出响应，不同的是: 计算属性`computed`更多是作为缓存功能的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，`computed`不会立即重新计算生成新的值，而是先标记为脏数据，当下次`computed`被获取的时候，才会进行重新计算并返回;而监听器`watch`并不具备缓存性，监听器`watch`提供一个监听函数，当监听的属性发生变化时，会立即执行该函数异步请求就用`watch`computed: 是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时，才会重新计算computed的值watch: 更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续的操作应用场景:    (1).当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可利用computed的缓存特性，避免每次获取值时，都要重新计算;    (2). 当我们需要在数据变化时执行异步或者开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的;</code></pre><p><strong>immediate</strong>：<strong>组件加载立即触发回调函数执行</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = newName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 代表在wacth里声明了firstName这个方法之后立即执行handler方法</span></span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    <span class="built_in">handler</span>(newName, oldName) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&#x27;obj.a changed&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h1><table><thead><tr><th></th><th>watch</th><th align="right">computed</th></tr></thead><tbody><tr><td>定义格式</td><td>必须监听存在的属性(data、props、computed)</td><td align="right">不能和data定义的变量相同</td></tr><tr><td>异步</td><td>支持异步操作</td><td align="right">不支持异步</td></tr><tr><td>开销</td><td>适合一些开销较大的操作</td><td align="right">适合做一些简单依赖的计算</td></tr></tbody></table><p>对于computed能做的 watch都可以做，至于选择哪个去做，都应该去看使用场景</p><h2 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h2><p>第一个输入框+第二个输入框 进行拼接</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904153613.png"></p><pre><code>&lt;input type=&quot;text&quot; v-model=&quot;num1&quot; name=&quot;&quot; id=&quot;&quot;&gt;+&lt;input type=&quot;text&quot; v-model=&quot;num2&quot; name=&quot;&quot; id=&quot;&quot;&gt;=&#123;&#123;num3&#125;&#125;&#123;&#123;res&#125;&#125;</code></pre><h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">      res()&#123;</span><br><span class="line">      this.num3= this.num1+this.num2</span><br><span class="line">      &#125;,</span><br><span class="line">      num2()&#123;</span><br><span class="line">      this.num3= this.num1+this.num2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  res() &#123;</span><br><span class="line">    return this.num1+this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><p>从代码量来看 显然更适合 用计算属性去做，而使用watch 就要检测两个值的变化 稍微繁琐了些</p></li><li><p>但是 watch 可以做一些异步的事情 并且可以设置改变多个值   这是计算属性做不到的</p></li></ul><h2 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h2><p>关于缓存问题 个人感觉 这两个并不能比，可以用computed和methods去比</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre><code>&#123;&#123;res()&#125;&#125;&#123;&#123;res()&#125;&#125; methods: &#123;  res() &#123;    console.log(&#39;方法被执行了&#39;);   return this.num1+this.num2  &#125;&#125;,</code></pre><p> 如果视图上多个使用这个方法 每个调用都会执行 </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904153529.png"></p><h3 id="计算属性-1"><a href="#计算属性-1" class="headerlink" title="计算属性"></a>计算属性</h3><p> 而计算属性不同，只有当值发生改变的时候他才会执行，如果上次没有改变他会取从缓存拿值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;res&#125;&#125;</span><br><span class="line">&#123;&#123;res&#125;&#125;</span><br><span class="line"> </span><br><span class="line">computed: &#123;</span><br><span class="line">  res() &#123;</span><br><span class="line">    console.log(&#x27;计算属性执行了&#x27;);</span><br><span class="line">    return this.num1+this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算属性computed：&quot;&gt;&lt;a href=&quot;#计算属性computed：&quot; class=&quot;headerlink&quot; title=&quot;计算属性computed：&quot;&gt;&lt;/a&gt;计算属性computed：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;支持缓存，只有依赖数据发生改变，才会重新</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>属性选择器</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2021-09-04T06:36:46.000Z</published>
    <updated>2021-09-05T16:18:23.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><hr><p>CSS <strong>属性选择器</strong>通过已经存在的属性名或属性值匹配元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存在title属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在class属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">&quot;logo&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p><code>[attr]</code></p><p>表示带有以 attr 命名的属性的元素。</p></li><li><p><code>[attr=value]</code></p><p>表示带有以 attr 命名的属性，且属性值为 value 的元素。</p></li><li><p><code>[attr~=value]</code></p><p>表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 value。</p></li><li><p><code>[attr|=value]</code></p><p>表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（”<code>-</code>“为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。</p></li><li><p><code>[attr^=value]</code></p><p>表示带有以 attr 命名的属性，且属性值是以 value 开头的元素。</p></li><li><p><code>[attr$=value]</code></p><p>表示带有以 attr 命名的属性，且属性值是以 value 结尾的元素。</p></li><li><p><code>[attr*=value]</code></p><p>表示带有以 attr 命名的属性，且属性值至少包含一个 value 值的元素。</p></li><li><p><code>[*attr* *operator* *value* i]</code></p><p>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>i</code>（或 <code>I</code>），可以在匹配属性值时忽略大小写（支持 ASCII 字符范围之内的字母）。</p></li><li><p><code>[*attr* *operator* *value* s]</code> </p><p>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>s</code>（或 <code>S</code>），可以在匹配属性值时区分大小写（支持 ASCII 字符范围之内的字母）。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以 &quot;#&quot; 开头的页面本地链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;#&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;example&quot; 的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: silver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;insensitive&quot; 的链接,不区分大小写 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;insensitive&quot;</span> i]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: cyan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;cAsE&quot; 的链接，区分大小写 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;cAsE&quot;</span> s]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以 &quot;.org&quot; 结尾的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;属性选择器&quot;&gt;&lt;a href=&quot;#属性选择器&quot; class=&quot;headerlink&quot; title=&quot;属性选择器&quot;&gt;&lt;/a&gt;属性选择器&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;CSS &lt;strong&gt;属性选择器&lt;/strong&gt;通过已经存在的属性名或属性值匹配元素。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误</title>
    <link href="https://andylinwenqin.github.io/2021/08/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux-centos7%E7%B3%BB%E7%BB%9F-%E5%8F%8A-mysql8%EF%BC%88%E8%80%81%E7%89%88%E6%9C%AC%EF%BC%89%E9%85%8D%E7%BD%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://andylinwenqin.github.io/2021/08/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux-centos7%E7%B3%BB%E7%BB%9F-%E5%8F%8A-mysql8%EF%BC%88%E8%80%81%E7%89%88%E6%9C%AC%EF%BC%89%E9%85%8D%E7%BD%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/</id>
    <published>2021-08-23T07:11:19.000Z</published>
    <updated>2021-09-05T16:18:23.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误"><a href="#虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误" class="headerlink" title="虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误"></a>虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误</h1><hr><h2 id="VMware安装虚拟机centos7的步骤，截图讲解"><a href="#VMware安装虚拟机centos7的步骤，截图讲解" class="headerlink" title="VMware安装虚拟机centos7的步骤，截图讲解"></a><a href="https://zhuanlan.zhihu.com/p/87740022">VMware安装虚拟机centos7的步骤，截图讲解</a></h2><p>安装前准备以下路径下载centOS7镜像：<a href="https://link.zhihu.com/?target=https://mirrors.aliyun.com/centos/7/isos/x86_64/">https://mirrors.aliyun.com/cent</a></p><h3 id="安装虚拟机的步骤"><a href="#安装虚拟机的步骤" class="headerlink" title="安装虚拟机的步骤"></a>安装虚拟机的步骤</h3><p>1.点击“创建虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153337.jpg"></p><p>2.点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153405.jpg"></p><p>3.点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153416.jpg"></p><p>4.选择“稍后安装操作系统”，然后“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153430.jpg"></p><p>5.选择Linux—&gt;&gt;版本号CentOS–&gt;&gt;下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153442.jpg"></p><p>6.填写“虚拟机名称”以及选择存放路径 ，然后点击下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153451.jpg"></p><p>7.选择处理器数显 默认是1 我这里选项2，然后“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153936.jpg"></p><p>8.选择内存，我这里选着2，默认是1 然后下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153513.jpg"></p><p>9.选择网络类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153525.jpg"></p><p>10.控制器类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153538.jpg"></p><p>11.磁盘类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153548.jpg"></p><p>12.选着“创建新虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153559.jpg"></p><p>13.这里磁盘大小，随便多少都行，5GB也行，磁盘存储单文件或者多文件都行，然后点击下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153606.jpg"></p><p>14。点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154107.jpg"></p><p>15。选自定义，然后选择刚才下载的镜像，然后点击“关闭”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153704.jpg"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153716.jpg"></p><p>16.点击“完成”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154256.jpg"></p><p>17.点击“开始此虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154400.jpg"></p><p>18.等待安装中</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154423.jpg"></p><p>19.选择键盘操作语言，我选择“中文简体”，然后点击“继续”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154513.jpg"></p><p>然后选择“软件选择”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154551.jpg"></p><p>然后顺便你选择 我闲着图形界面，点击“完成”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154611.jpg"></p><p>20 点击 选择时间</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154629.jpg"></p><p>然后选择亚洲–上海时间，———》点击完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154723.jpg"></p><p>21.选分区</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155241.jpg"></p><p>22.选着网络配置</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155256.jpg"></p><p>首先要打开网卡，然后查看是否能获取到IP地址</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155508.jpg"></p><p>23.点击“开始安装”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160228.jpg"></p><p>24.点击设置“密码”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160243.jpg"></p><p>填写密码，点击完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160256.jpg"></p><p>这里也可以创建用户，但是我创建用户，然后<strong>等待安装中</strong></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160307.jpg"></p><p>25.安装完成，点击重启</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160323.jpg"></p><p>26.点击重启后，点击然后接受–完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160350.jpg"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160413.jpg"></p><p>然后完成配置</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160423.jpg"></p><p>设置用户名</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160433.jpg"></p><p>安装成功</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160458.jpg"></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>1.在终端中切换目录 ：cd /etc/sysconfig/network-scripts/</p><p>2.在查看当前目录的文件：ls -a</p><p>3.输入su 切换到根目录root中，输入根目录的密码，点击Enter键</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160630.jpg"></p><p>4.输入vi ifcfg-ens33 打开网络配置文件点击“i”进入可编辑文件</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160842.jpg"></p><p>将ONBOOT=no改为ONBOOT=yes，即可配置开机自启动。多增加这几行</p><p>IPADDR=192.168.117.128(ip地址)</p><p>NETMASK=255.255.255.0(子网掩码)</p><p>GATEWAY=192.168.117.13(默认路由)</p><p>DNS1=114.114.114.114(dns)</p><p>按ESC后，再输入:wq，按Enter键，即可保存并退出编辑。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823161006.png"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160938.jpg"></p><p>退出到命令行界面，然后输入重启命令reboot，重启一下系统即可。</p><p>测试外网成功</p><p>ping baidu.com</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823161204.jpg"></p><h2 id="Linux环境-Centos-7-安装MySQL数据库"><a href="#Linux环境-Centos-7-安装MySQL数据库" class="headerlink" title="Linux环境(Centos 7)安装MySQL数据库"></a><a href="https://www.cnblogs.com/guoxiangyue/p/12768560.html">Linux环境(Centos 7)安装MySQL数据库</a></h2><h3 id="1-卸载mariadb"><a href="#1-卸载mariadb" class="headerlink" title="1.卸载mariadb"></a>1.卸载mariadb</h3><p>查看是否已安装mariadb</p><p># yum list installed mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164227.png"></p><p>系统中已经安装mariadb，进行卸载。</p><p># yum remove mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164237.png"></p><p>查看是否卸载成功</p><p># yum list installed mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164251.png"></p><p>删除mariadb配置文件</p><p># rm -f /etc/my.cnf </p><p>删除mariadb数据目录</p><p># rm -rf /var/lib/mysql/  </p><h3 id="2-下载MySQL-使用rpm来安装MySQL"><a href="#2-下载MySQL-使用rpm来安装MySQL" class="headerlink" title="2.下载MySQL 使用rpm来安装MySQL"></a>2.下载MySQL 使用rpm来安装MySQL</h3><p>因为CentOS 7默认安装的数据库是Mariadb,所以使用YUM命令是无法安装MySQL的，只会更新Mariadb。使用rpm来进行安装。可以在<a href="https://links.jianshu.com/go?to=http://repo.mysql.com/">mysql的repo源仓库</a>右键复制指定版本的数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># wget http:<span class="comment">//repo.mysql.com/mysql80-community-release-el7-1.noarch.rpm</span></span></span><br></pre></td></tr></table></figure><p>安装mysql80-community-release-el7-1.noarch.rpm包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo rpm -ivh mysql80-community-release-el7-<span class="number">1</span><span class="selector-class">.noarch</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><p>安装完成后会在 /etc/yum.repos.d文件夹里面获得两个文件：mysql-community.repo &amp;&amp; mysql-community-source.repo</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165019.webp"><br> 使用yum安装mysql服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo yum install mysql-server</span></span><br></pre></td></tr></table></figure><p>如果显示以下内容说明安装成功<br> <strong>Complete!</strong><br> 检查是否已经设置为开机启动MySQL服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl list-unit-files|grep mysqld</span></span><br></pre></td></tr></table></figure><p>如果显示</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165122.webp"></p><p> 则表示已经设置为开机启动，如果没有设置为开机启动则执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl enable mysqld.service</span></span><br></pre></td></tr></table></figure><p>查看MySQL是否启动未启动则执行启动服务命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看是否启动MySQL服务</span><br><span class="line"><span class="comment"># ps -ef|grep mysql</span></span><br><span class="line"></span><br><span class="line">启动服务</span><br><span class="line"><span class="comment"># systemctl start mysqld.service</span></span><br></pre></td></tr></table></figure><p>初始化MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld --initialize</span></span><br></pre></td></tr></table></figure><p>查看MySQL初始默认密码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grep <span class="string">&#x27;temporary password&#x27;</span> /<span class="keyword">var</span>/log/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165150.webp"> 复制 root@localhost: 后面的密码。登录mysql，并粘贴默认密码<br> 因为MySQL8.0的更改，导致必须要重置密码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;12345678&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果设置密码时候出现提示</p><blockquote><p>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</p></blockquote><p>代表需要降低policy的等级后在执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>开启MySQL远程连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="comment">#修改root账户权限</span></span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="comment">#刷新权限</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>到此完成mysql基本安装和配置  快拍一个虚拟机快照啊</p><h2 id="登录mysql和退出mysql"><a href="#登录mysql和退出mysql" class="headerlink" title="登录mysql和退出mysql"></a>登录mysql和退出mysql</h2><p>linux中登录mysql的方式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 127.0.0.1 -p；</span><br></pre></td></tr></table></figure><p>退出MySQL  输入 exit    摁enter</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><p>1.通过yum -y install python-pip命令进行安装提示没有可用软件包 python-pip</p><p>2、接着执行：yum -y install epel-release python-pip命令</p><p>3、最后在次执行：yum -y install python-pip即可成功</p><p>4、然后可通过pip -V查看版本</p><p>5、然后通过：pip install –upgrade pip –user进行升级</p><p>6、然后在执行：pip install –upgrade pip</p><p>7、此时在pip -V看版本即可升级成功</p><h2 id="mysql-老版本-配置问题及解决方法"><a href="#mysql-老版本-配置问题及解决方法" class="headerlink" title="mysql(老版本)配置问题及解决方法"></a>mysql(老版本)配置问题及解决方法</h2><h3 id="1、缺少libmysqlclient-so-18"><a href="#1、缺少libmysqlclient-so-18" class="headerlink" title="1、缺少libmysqlclient.so.18"></a>1、缺少libmysqlclient.so.18</h3><p> 发生服务器错误： Error loading MySQLdb module: libmysqlclient.so.18: cannot open shared object file: No such file or directory</p><h4 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h4><p>这个错误出现的原因是找不到 libmysqlclient.so.18 这个文件，根本原因是，一般我们使用的mysql都是自己从新安装的，不是系统自带的，所以在我们安装我们自己的mysql的时候，会把删除原来的mysql，此时会连带这删掉这个文件，32的目录是 /usr/lib/mysql/，64位的为 /usr/lib64/mysql/下面有这个文件。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>　　1、解决问题的关键是，在找一台未装过mysql的服务器，然后把此文件夹下面的 libmysqlclient.so.18.0.0 文件拷贝到此服务器的这个目录中，然后做软连接。</p><p>​        我选择更好的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/lib/libmysqlclient.so.18 http://files.directadmin.com/services/es_7.0_64/libmysqlclient.so.18</span><br></pre></td></tr></table></figure><p>直接下载缺失文件到对应位置</p><p>　　2、然后 vi /etc/ld.so.conf 后面增加一条记录：/usr/lib64/mysql （libmysqlclient.so.18 和libmysqlclient.so.18.0.0所在目录）</p><p>　　3、运行 ldconfig 命令，让其生效。</p><p>　　ok,完美解决。</p><h3 id="2-Django启动服务器时，报错mysql的2059错误的解决办法。"><a href="#2-Django启动服务器时，报错mysql的2059错误的解决办法。" class="headerlink" title="2.Django启动服务器时，报错mysql的2059错误的解决办法。"></a>2.Django启动服务器时，报错mysql的2059错误的解决办法。</h3><p>启动方式为如下：</p><blockquote><p>python manage.py runserver 0.0.0.0:8000</p></blockquote><p>经过一番查询，调试，最终发现了问题所在。主要就是mysql8.0的问题。<br>目前最新的mysql8.0对用户密码的加密方式为caching_sha2_password, django暂时还不支持这种新增的加密方式。只需要将用户加密方式改为老的加密方式即可。</p><p>解决步骤：<br>1.登录mysql，连接用户为root。</p><blockquote><p>mysql -u root -p</p></blockquote><p>2.执行命令查看加密方式</p><blockquote><p>use mysql;<br>select user,plugin from user where user=’root’;</p></blockquote><p>3.执行命令修改加密方式</p><blockquote><p>alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘yourpassword’</p></blockquote><p>4.属性权限使配置生效</p><blockquote><p>flush privileges</p></blockquote><p>其中遇到两个小问题</p><h4 id="1-Your-password-does-not-satisfy-the-current-policy-requirements"><a href="#1-Your-password-does-not-satisfy-the-current-policy-requirements" class="headerlink" title="1.Your password does not satisfy the current policy requirements"></a>1.Your password does not satisfy the current policy requirements</h4><p>密码策略问题异常信息</p><p>不符合正确密码规范</p><p>解决办法：</p><p>1、查看 mysql 初始的密码策略，<br>输入语句 “ SHOW VARIABLES LIKE ‘validate_password%’; ” 进行查看</p><p>2、首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，<br>输入设值语句 “ set global validate_password_policy=LOW; ” 进行设值，</p><p>3、当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，<br>输入设值语句 “ set global validate_password_length=6; ” 进行设值，</p><p>4、现在可以为 mysql 设置简单密码了，只要满足六位的长度即可，<br>输入修改语句 “ ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; ” 可以看到修改成功，表示密码策略修改成功了！！！</p><p>关于 mysql 密码策略相关参数；<br>1）、validate_password_length  固定密码的总长度；<br>2）、validate_password_dictionary_file 指定密码验证的文件路径；<br>3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；<br>4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；<br>5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；<br>关于 validate_password_policy 的取值：<br>0/LOW：只验证长度；<br>1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；<br>6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</p><h4 id="2-Operation-ALTER-USER-failed-for-‘root‘-’localhost’"><a href="#2-Operation-ALTER-USER-failed-for-‘root‘-’localhost’" class="headerlink" title="2.Operation ALTER USER failed for ‘root‘@’localhost’"></a>2.Operation ALTER USER failed for ‘root‘@’localhost’</h4><p>先登录mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select user,host from user;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| root             | %         |</span><br><span class="line">| admin            | localhost |</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| zhangj           | localhost |</span><br><span class="line">+------------------+-----------+</span><br></pre></td></tr></table></figure><p>注意root，host是’%’</p><p>你可能执行的是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p>改成:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">针对github开源项目wechat-spider的部署</summary>
    
    
    
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Linux" scheme="https://andylinwenqin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件传值</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2021-08-19T15:31:21.000Z</published>
    <updated>2021-09-05T16:18:23.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue组件传值"><a href="#Vue组件传值" class="headerlink" title="Vue组件传值"></a>Vue组件传值</h1><hr><p>先看一张总结图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210820002412.png"></p><h2 id="方法一-父组件向子组件传值-（props传参）"><a href="#方法一-父组件向子组件传值-（props传参）" class="headerlink" title="方法一 父组件向子组件传值 （props传参）"></a>方法一 父组件向子组件传值 （props传参）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son</span><br><span class="line">      str=&quot;字符串&quot;</span><br><span class="line">      :num=&quot;5&quot;</span><br><span class="line">      :obj=&quot;&#123; name: &#x27;对象信息&#x27; &#125;&quot;</span><br><span class="line">      :func=&quot;() =&gt; &#123;this.list()&#125;&quot;</span><br><span class="line">      :arr=&quot;arr&quot;</span><br><span class="line">    &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        arr: [1, 2, 3],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      list() &#123;</span><br><span class="line">        console.log(&#x27;list&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      arr: Array, //定义参数类型</span><br><span class="line">      num: Number,</span><br><span class="line">      str: String,</span><br><span class="line">      str2: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;默认是字符串&#x27;, //定义默认值</span><br><span class="line">      &#125;,</span><br><span class="line">      func: &#123;</span><br><span class="line">        type: Function,</span><br><span class="line">        require: false, // 定义参数是否必须值</span><br><span class="line">      &#125;,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        require: false,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(this.str) //字符串</span><br><span class="line">      console.log(this.str2) //默认字符串</span><br><span class="line">      console.log(this.num) //5</span><br><span class="line">      console.log(this.arr) //[1,2,3]</span><br><span class="line">      console.log(this.func()) // list</span><br><span class="line">      console.log(this.obj) // name:&#x27;对象信息&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法二-子组件向父组件传值-（事件传递）"><a href="#方法二-子组件向父组件传值-（事件传递）" class="headerlink" title="方法二 子组件向父组件传值 （事件传递）"></a>方法二 子组件向父组件传值 （事件传递）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son @func=&quot;speak&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">    methods: &#123;</span><br><span class="line">      speak(msg) &#123;</span><br><span class="line">        console.log(msg) //我是子组件发送的消息</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      this.$emit(&#x27;func&#x27;, &#x27;我是子组件发送的消息！&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法三-事件监听"><a href="#方法三-事件监听" class="headerlink" title="方法三 事件监听"></a>方法三 事件监听</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son ref=&quot;son&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">   mounted() &#123;</span><br><span class="line">     this.$refs[&#x27;son&#x27;].$on(&#x27;func&#x27;,(msg)=&gt;&#123;</span><br><span class="line">         console.log(msg);  //我是子组件传递的消息</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$emit(&#x27;func&#x27;, &#x27;我是子组件传递的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法四-消息发布与订阅"><a href="#方法四-消息发布与订阅" class="headerlink" title="方法四 消息发布与订阅"></a>方法四 消息发布与订阅</h2><p>安装pubsub-js插件:  npm install pubsub-js -s //可实现全局参数传递</p><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        pubsub.publishSync(&#x27;sendMsg&#x27;, &#x27;这是A组件发布的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是B组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;B&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      pubsub.subscribe(&#x27;sendMsg&#x27;, (e, msg) =&gt; &#123;</span><br><span class="line">        console.log(e, msg) //sendMsg 这是A组件发布的消息！</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>publishSync 同步发送消息</li><li>publish  同步发送消息</li><li>subscribe 订阅消息</li><li>unsubscribe 卸载特定订阅消息</li><li>clearAllSubscriptions 清除所有订阅消息</li></ul><h2 id="方法五-非父子组件传值-（EventBus传参）"><a href="#方法五-非父子组件传值-（EventBus传参）" class="headerlink" title="方法五 非父子组件传值 （EventBus传参）"></a>方法五 非父子组件传值 （EventBus传参）</h2><p>在main.js中挂载全局EventBus</p><blockquote><p>1.Vue.prototype.$EventBus = new Vue()</p></blockquote><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$EventBus.$emit(&#x27;sendMsg&#x27;,&#x27;这是A组件发送的消息！&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件</strong>B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是组件B&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;B&quot;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            this.$EventBus.$on(&#x27;sendMsg&#x27;,(msg)=&gt;&#123;</span><br><span class="line">                console.log(msg);//这是组件A发送的消息！</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过挂载全局Vue对象传递参数</p><h2 id="方法六-路由间传值"><a href="#方法六-路由间传值" class="headerlink" title="方法六 路由间传值"></a>方法六 路由间传值</h2><h3 id="i-使用问号传值"><a href="#i-使用问号传值" class="headerlink" title="i.使用问号传值"></a>i.使用问号传值</h3><p>A页面跳转B页面时使用 this.$router.push(’/B?name=danseek’)</p><p>B页面可以使用 this.$route.query.name 来获取A页面传过来的值</p><p>上面要注意router和route的区别</p><h3 id="ii-使用冒号传值"><a href="#ii-使用冒号传值" class="headerlink" title="ii.使用冒号传值"></a>ii.使用冒号传值</h3><p>配置如下路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/b/:name&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;../views/B.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>在B页面可以通过 this.$route.params.name 来获取路由传入的name的值</p><h3 id="iii-使用父子组件传值"><a href="#iii-使用父子组件传值" class="headerlink" title="iii.使用父子组件传值"></a>iii.使用父子组件传值</h3><p>由于router-view本身也是一个组件，所以我们也可以使用父子组件传值方式传值，然后在对应的子页面里加上props，因为type更新后没有刷新路由，所以不能直接在子页面的mounted钩子里直接获取最新type的值，而要使用watch。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :type=&quot;type&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 子页面</span><br><span class="line">......</span><br><span class="line">props: [&#x27;type&#x27;]</span><br><span class="line">......</span><br><span class="line">watch: &#123;</span><br><span class="line">    type()&#123;</span><br><span class="line">    // console.log(&quot;在这个方法可以时刻获取最新的数据:type=&quot;,this.type)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法七-Vuex"><a href="#方法七-Vuex" class="headerlink" title="方法七 Vuex"></a>方法七 Vuex</h2><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://blog.csdn.net/dan_seek/article/details/102641761">vue组件传值的11种方式</a></p>]]></content>
    
    
    <summary type="html">Vue组件传值的多种传值方式</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>文本换行省略</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/</id>
    <published>2021-08-19T15:28:19.000Z</published>
    <updated>2021-09-05T16:18:23.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-将一大串文字分两行显示，超出用省略号表示"><a href="#vue-将一大串文字分两行显示，超出用省略号表示" class="headerlink" title="vue 将一大串文字分两行显示，超出用省略号表示"></a>vue 将一大串文字分两行显示，超出用省略号表示</h1><hr><p>众所周知，通过css设置文字强制不换行超出用省略号表示很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: nowrap; 文本强制不换行；</span><br><span class="line"><span class="attribute">text-overflow</span>:ellipsis; 文本溢出显示省略号；</span><br><span class="line"><span class="attribute">overflow</span>:hidden; 溢出的部分隐藏；</span><br></pre></td></tr></table></figure><p>但是如果要想显示两行，超出用省略号表示要怎么写呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure><p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。<br>常见结合属性：<br>1，display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。<br>2，-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。<br>3，text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;a href=&quot;#vue-将一大串文字分两行显示，超出用省略号表示&quot; class=&quot;headerlink&quot; title=&quot;vue 将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;/a&gt;vue 将一大串文字分两行显</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>flex布局设置单个元素靠右</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/flex%E5%B8%83%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9D%A0%E5%8F%B3/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/flex%E5%B8%83%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9D%A0%E5%8F%B3/</id>
    <published>2021-08-19T12:45:02.000Z</published>
    <updated>2021-09-05T16:18:23.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flex布局设置单个元素靠右"><a href="#flex布局设置单个元素靠右" class="headerlink" title="flex布局设置单个元素靠右"></a>flex布局设置单个元素靠右</h1><h2 id="父元素布局"><a href="#父元素布局" class="headerlink" title="父元素布局"></a>父元素布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br></pre></td></tr></table></figure><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: auto;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flex布局设置单个元素靠右&quot;&gt;&lt;a href=&quot;#flex布局设置单个元素靠右&quot; class=&quot;headerlink&quot; title=&quot;flex布局设置单个元素靠右&quot;&gt;&lt;/a&gt;flex布局设置单个元素靠右&lt;/h1&gt;&lt;h2 id=&quot;父元素布局&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>下拉刷新 触底刷新</title>
    <link href="https://andylinwenqin.github.io/2021/08/10/Vue%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%20%E8%A7%A6%E5%BA%95%E5%88%B7%E6%96%B0/"/>
    <id>https://andylinwenqin.github.io/2021/08/10/Vue%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%20%E8%A7%A6%E5%BA%95%E5%88%B7%E6%96%B0/</id>
    <published>2021-08-10T13:34:26.000Z</published>
    <updated>2021-09-05T16:18:23.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下拉刷新-触底刷新"><a href="#下拉刷新-触底刷新" class="headerlink" title="下拉刷新 触底刷新"></a>下拉刷新 触底刷新</h1><hr><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>下拉刷新和上拉加载这两种交互方式通常出现在移动端中</p><p>本质上等同于PC网页中的分页，只是交互形式不同</p><p>开源社区也有很多优秀的解决方案，如<code>iscroll</code>、<code>better-scroll</code>、<code>pulltorefresh.js</code>库等等</p><p>这些第三方库使用起来非常便捷</p><p>我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>上拉加载及下拉刷新都依赖于用户交互</p><p>最重要的是要理解在什么场景，什么时机下触发交互动作</p><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>首先可以看一张图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210819203252.png"></p><p>上拉加载的本质是页面触底，或者快要触底时的动作</p><p>判断页面触底我们需要先了解一下下面几个属性</p><ul><li><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</li><li><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</li><li><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</li></ul><p>综上我们得出一个触底公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollTop + clientHeight &gt;= scrollHeight</span><br></pre></td></tr></table></figure><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clientHeight  = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">//浏览器高度</span></span><br><span class="line"><span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line"><span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">50</span>;  <span class="comment">//距离视窗还用50的时候，开始触发；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始加载数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p><p>关于下拉刷新的原生实现，主要分成三步：</p><ul><li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li><li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li><li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li></ul><p>举个例子：</p><p><code>Html</code>结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refreshText&quot;</span>&gt;</span>&lt;/p &gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;refreshContainer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>555<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ...</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>监听<code>touchstart</code>事件，记录初始的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refreshContainer&#x27;</span>),</span><br><span class="line">    _refreshText = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.refreshText&#x27;</span>),</span><br><span class="line">    _startPos = <span class="number">0</span>,  <span class="comment">// 初始的值</span></span><br><span class="line">    _transitionHeight = <span class="number">0</span>; <span class="comment">// 移动的距离</span></span><br><span class="line"></span><br><span class="line">_element.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    _startPos = e.touches[<span class="number">0</span>].pageY; <span class="comment">// 记录初始位置</span></span><br><span class="line">    _element.style.position = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">    _element.style.transition = <span class="string">&#x27;transform 0s&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>监听<code>touchmove</code>移动事件，记录滑动差值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_element.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// e.touches[0].pageY 当前位置</span></span><br><span class="line">    _transitionHeight = e.touches[<span class="number">0</span>].pageY - _startPos; <span class="comment">// 记录差值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">0</span> &amp;&amp; _transitionHeight &lt; <span class="number">60</span>) &#123; </span><br><span class="line">        _refreshText.innerText = <span class="string">&#x27;下拉刷新&#x27;</span>; </span><br><span class="line">        _element.style.transform = <span class="string">&#x27;translateY(&#x27;</span>+_transitionHeight+<span class="string">&#x27;px)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">55</span>) &#123;</span><br><span class="line">            _refreshText.innerText = <span class="string">&#x27;释放更新&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>最后，就是监听<code>touchend</code>离开的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_element.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    _element.style.transition = <span class="string">&#x27;transform 0.5s ease 1s&#x27;</span>;</span><br><span class="line">    _element.style.transform = <span class="string">&#x27;translateY(0px)&#x27;</span>;</span><br><span class="line">    _refreshText.innerText = <span class="string">&#x27;更新中...&#x27;</span>;</span><br><span class="line">    <span class="comment">// todo...</span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p><ul><li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</li><li>下拉到一定值时，显示松手释放后的操作提示</li><li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</li></ul><h3 id="触底刷新"><a href="#触底刷新" class="headerlink" title="触底刷新"></a>触底刷新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">containerHeight</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">innerHeight</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">scrollBottom</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.innerHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">        <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">        <span class="comment">// console.log(&quot;触发&quot;,scrollTop,this.containerHeight,this.innerHeight)</span></span><br><span class="line">        <span class="keyword">if</span> (scrollTop + <span class="built_in">this</span>.containerHeight &gt;= <span class="built_in">this</span>.innerHeight - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;触底了&#x27;);</span></span><br><span class="line">            <span class="built_in">this</span>.heightListInit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.containerHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="built_in">this</span>.innerHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="built_in">this</span>.scrollBottom);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下拉刷新-触底刷新&quot;&gt;&lt;a href=&quot;#下拉刷新-触底刷新&quot; class=&quot;headerlink&quot; title=&quot;下拉刷新 触底刷新&quot;&gt;&lt;/a&gt;下拉刷新 触底刷新&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>声网视频和音频的学习</title>
    <link href="https://andylinwenqin.github.io/2021/08/09/%E5%A3%B0%E7%BD%91%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://andylinwenqin.github.io/2021/08/09/%E5%A3%B0%E7%BD%91%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-09T15:20:23.000Z</published>
    <updated>2021-09-05T16:18:23.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="声网"><a href="#声网" class="headerlink" title="声网"></a><a href="https://www.agora.io/cn">声网</a></h1><hr><h2 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h2><p>Agora 互动直播（Interactive Live Streaming Premium）可以实现一对多，多对多的音视频互动直播。</p><p>Agora 互动直播不同于视频通话。视频通话不区分主播和观众，所有用户都可以发言并看见彼此；互动直播的用户分为主播和观众，只有主播可以自由发言，且被其他用户看见。详见<a href="https://docs.agora.io/cn/faq/profile_difference">通信和直播场景有什么区别</a>。</p><h2 id="加入和离开频道"><a href="#加入和离开频道" class="headerlink" title="加入和离开频道"></a>加入和离开频道</h2><p>Agora Web SDK 使用 [AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象来管理一个本地用户在目标频道内的行为。在加入目标频道之前，你需要先创建一个 <code>AgoraRTCClient</code> 对象。</p><h3 id="创建-AgoraRTCClient-对象"><a href="#创建-AgoraRTCClient-对象" class="headerlink" title="创建 AgoraRTCClient 对象"></a>创建 AgoraRTCClient 对象</h3><p>调用 [AgoraRTC.createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 即可创建 <code>AgoraRTCClient</code> 对象。在创建 <code>AgoraRTCClient</code> 时，你需要指定使用的编码格式（<code>codec</code>）以及频道场景（<code>mode</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = AgoraRTC.createClient(&#123;</span><br><span class="line">  <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="选择视频编码格式"><a href="#选择视频编码格式" class="headerlink" title="选择视频编码格式"></a>选择视频编码格式</h3><p><code>codec</code> 设置支持 <code>&quot;vp8&quot;</code>（VP8）和 <code>&quot;h264&quot;</code>（H.264）两种视频编码格式。该设置只会影响发布端的视频编码格式，对于订阅端来说只要其支持该格式的解码，都能正常完成订阅。</p><p>举例来说，桌面端 Chrome 58 及以上版本既支持 VP8 也支持 H.264，而 Safari 12.1 以下版本不支持 VP8 编解码；如果频道中有两个主播分别发布了 VP8 和 H.264 的视频流，使用桌面端 Chrome 58 的观众可以解码这两个主播的视频，使用 Safari 12.1 以下版本浏览器的观众只能解码 H.264 的视频流。</p><p>不同浏览器和不同设备对这两种编解码格式支持都不同。下表列出不同浏览器所支持的编解码格式作为参考：</p><table><thead><tr><th align="left">浏览器</th><th align="left">VP8</th><th align="left">H.264</th></tr></thead><tbody><tr><td align="left">桌面端 Chrome 58+</td><td align="left">✔</td><td align="left">✔</td></tr><tr><td align="left">Firefox 56+</td><td align="left">✔</td><td align="left">✔*</td></tr><tr><td align="left">Safari 12.1+</td><td align="left">✔</td><td align="left">✔</td></tr><tr><td align="left">Safari &lt; 12.1</td><td align="left">✘</td><td align="left">✔</td></tr><tr><td align="left">Android Chrome 58+</td><td align="left">✔</td><td align="left">?*</td></tr></tbody></table><h3 id="选择频道场景"><a href="#选择频道场景" class="headerlink" title="选择频道场景"></a>选择频道场景</h3><p>频道场景（<code>mode</code>）是 Agora 为了对不同的实时音视频场景进行针对性算法优化而提供的一种设置选项。SDK 支持两种频道场景：<code>&quot;rtc&quot;</code>（通信场景） 和 <code>&quot;live&quot;</code>（直播场景）。</p><p><strong>通信场景</strong></p><p><code>&quot;rtc&quot;</code>（通信场景）适用于频道内所有用户需要相互交流且用户总数不太多的场景，如多人会议和在线聊天。</p><p><strong>直播场景</strong></p><p><code>&quot;live&quot;</code>（直播场景）适用于发布端很少但是订阅端很多的场景，这种场景下 SDK 定义了两种用户角色：观众（默认）和主播。主播能够发送和接收音视频，观众不能发送、只能接收音视频。你可以通过设置 <code>createClient</code> 的 [role](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/clientconfig.html#role) 参数来指定用户角色，也可以调用 [setClientRole](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#setclientrole) 来动态修改用户角色。</p><h3 id="加入频道"><a href="#加入频道" class="headerlink" title="加入频道"></a>加入频道</h3><p>创建 <code>AgoraRTCClient</code> 对象后，就可以调用 [AgoraRTCClient.join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 加入频道。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>注意 <code>join</code> 方法的第四个参数 <code>uid</code> 的设置。不传入任何值时，Agora 会为这个加入的本地用户自动分配一个 Number 型的用户 ID 作为其唯一的身份标识。你也可以通过该参数自行指定一个 Number 型的用户 ID。</p><p>请确保频道内用户 ID 的唯一性。Agora 建议你在业务层面避免用户使用相同的 ID 加入一个频道。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动分配数字 UID</span></span><br><span class="line"><span class="keyword">const</span> uid = <span class="keyword">await</span> client.join(<span class="string">&quot;APPID&quot;</span>, <span class="string">&quot;CHANNEL&quot;</span>, <span class="string">&quot;TOKEN&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数字 UID</span></span><br><span class="line"><span class="keyword">await</span> client.join(<span class="string">&quot;APPID&quot;</span>, <span class="string">&quot;CHANNEL&quot;</span>, <span class="string">&quot;TOKEN&quot;</span>, <span class="number">393939</span>);</span><br></pre></td></tr></table></figure><h3 id="离开频道"><a href="#离开频道" class="headerlink" title="离开频道"></a>离开频道</h3><p>调用 [AgoraRTCClient.leave](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave) 可以离开当前频道。该方法可以在任何时候调用，包括正在加入频道时或者正在重连时。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>调用 <code>leave</code> 后，SDK 会立刻销毁与当前频道相关的对象，包括订阅的远端用户对象、远端轨道对象、记录连接状态的对象等。如果需要再次加入频道，在调用 <code>leave</code> 后再调用 <code>join</code> 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> client.leave();</span><br></pre></td></tr></table></figure><h3 id="频道内的连接状态"><a href="#频道内的连接状态" class="headerlink" title="频道内的连接状态"></a>频道内的连接状态</h3><p>详见[频道连接状态管理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/channel_connection_web_ng?platform=Web)。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在加入频道的过程中，因为 SDK 使用不当或者网络异常等原因，可能会抛出以下错误：</p><ul><li><code>INVALID_PARAMS</code>: 提供的参数错误，比如提供了格式非法的 Token。</li><li><code>INVALID_OPERATION</code>: 非法操作。该错误通常是重复加入频道引起的，请确保重复加入时先调用 <code>leave</code>。</li><li><code>OPERATION_ABORTED</code>: 加入被中止，表示在 <code>join</code> 方法成功之前就调用了 <code>leave</code> 方法。</li><li><code>UNEXPECTED_RESPONSE</code>: Agora 服务器返回了非预期的响应，通常是因为 App ID 或 Token 鉴权失败，例如开启了 App 证书却未传入 Token。</li><li><code>UID_CONFLICT</code>: 创建了多个 <code>AgoraRTCClient</code> 对象，且重复使用了同一个用户 ID。</li></ul><h2 id="创建本地轨道对象"><a href="#创建本地轨道对象" class="headerlink" title="创建本地轨道对象"></a>创建本地轨道对象</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。</p><p>本文详细介绍如何使用 Agora Web SDK 创建本地的音视频轨道对象。</p><p>在介绍具体的 API 之前，你需要了解本地轨道对象的一些设计细节。Agora Web SDK 使用了面向对象的设计模式，使用 [LocalTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html) 这一个基础的抽象类来描述所有的本地轨道对象，它定义了本地轨道对象的公共方法和行为，所有的本地轨道对象都继承于 <code>LocalTrack</code>。</p><p><code>publish</code> 方法只要求发布的对象是 <code>LocalTrack</code> ，所以无论通过什么方式创建的本地轨道对象，都满足 <code>publish</code> 方法的参数要求。</p><p>基于 <code>LocalTrack</code>，SDK 定义了 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 和 [LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html)，分别代表本地音频轨道对象和本地视频轨道对象。这两个类分别针对音视频不同的特性增加了不同的方法，比如 <code>LocalAudioTrack</code> 增加了获取和控制音量的方法、<code>LocalVideoTrack</code> 增加了设置美颜功能的方法。</p><p>最后，根据不同的应用场景和创建方式， SDK 基于 <code>LocalAudioTrack</code> 和 <code>LocalVideoTrack</code> 提供了更上层的本地轨道类。比如继承自 <code>LocalVideoTrack</code> 的 <code>CameraVideoTrack</code>，这个类表明这个本地视频轨道是来自于摄像头采集的视频，所以这个类增加了控制摄像头、调整分辨率等方法。</p><p>下图展示了这几个类之间的关系：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210809235859.png"></p><h3 id="创建轨道"><a href="#创建轨道" class="headerlink" title="创建轨道"></a>创建轨道</h3><p>SDK 支持通过以下方式创建本地轨道对象。</p><h3 id="使用麦克风和摄像头"><a href="#使用麦克风和摄像头" class="headerlink" title="使用麦克风和摄像头"></a>使用麦克风和摄像头</h3><p>最常用的方法是直接通过麦克风或者摄像头采集的音视频来创建本地轨道对象，SDK 提供了三种方法：</p><ul><li>[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)：使用摄像头采集的视频来创建本地视频轨道，返回一个 [CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 对象。</li><li>[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)：使用麦克风采集的音频来创建本地音频轨道，返回一个 [MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 对象。</li><li>[createMicrophoneAndCameraTracks](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks)：同时使用麦克风和摄像头采集的音视频创建本地轨道，返回一个包含 [CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 和 [MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 的列表。</li></ul><p>如果使用 <code>createMicrophoneAndCameraTracks</code> 创建本地轨道，因为音频和视频采集是一次完成的，所以只要摄像头和麦克风其中一个无法完成采集就会导致整个采集的失败，SDK 会抛出错误，详见[错误处理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/create_local_track_web_ng?platform=Web#error)。如果分别调用 <code>createCameraVideoTrack</code> 和 <code>createMicrophoneAudioTrack</code> ，其中一个采集失败不会影响另外一个。请根据你的实际需求选用合适的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采集摄像头</span></span><br><span class="line"><span class="keyword">const</span> cameraTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采集麦克风</span></span><br><span class="line"><span class="keyword">const</span> microphoneTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时采集摄像头和麦克风</span></span><br><span class="line"><span class="keyword">const</span> [microphoneTrack, cameraTrack] = <span class="keyword">await</span> AgoraRTC.createMicrophoneAndCameraTracks();</span><br></pre></td></tr></table></figure><p>调用以上方法时你可以传入一个配置参数来控制采集的行为，详细的参数定义可以参考 [CameraVideoTrackInitConfig](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/cameravideotrackinitconfig.html) 或者 [MicrophoneAudioTrackInitConfig](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/microphoneaudiotrackinitconfig.html)。</p><p>以上方法均为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><h3 id="使用屏幕画面"><a href="#使用屏幕画面" class="headerlink" title="使用屏幕画面"></a>使用屏幕画面</h3><p>SDK 提供 [createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 方法来创建屏幕共享轨道，这个方法会返回 <code>LocalVideoTrack</code> 对象。由于 <code>LocalVideoTrack</code> 只实现了视频轨道对象的基础方法，因此通过屏幕创建的轨道无法像摄像头轨道那样控制分辨率或切换设备。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> screenTrack = <span class="keyword">await</span> AgoraRTC.createScreenVideoTrack();</span><br></pre></td></tr></table></figure><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>如果你需要在 Electron 或较老版本的 Chrome 上使用屏幕共享，或者希望在共享屏幕的同时分享音频，可以参考[屏幕共享](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/screensharing_web_ng)。</p><h3 id="使用本地或在线的音频文件"><a href="#使用本地或在线的音频文件" class="headerlink" title="使用本地或在线的音频文件"></a>使用本地或在线的音频文件</h3><p>SDK 提供 [createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 方法来通过本地或者在线的音频文件创建本地音频轨道对象。通过该方法创建的对象类型为 <code>BufferSourceAudioTrack</code>，该对象继承自 <code>LocalAudioTrack</code>，在其基础上增加了控制音频文件播放行为的方法，比如暂停播放、跳转播放、循环播放等。</p><p>你可以使用这个方法实现混音或者播放音效的功能，详见[播放音效/混音](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/audio_effect_mixing_web_ng)。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioFileTrack = <span class="keyword">await</span> AgoraRTC.createBufferSourceAudioTrack(&#123;</span><br><span class="line">  <span class="attr">source</span>: <span class="string">&quot;https://web-demos-static.agora.io/agora/smlt.flac&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在播放之前先调用该方法读取音频文件</span></span><br><span class="line">audioFileTrack.startProcessAudioBuffer();</span><br><span class="line"></span><br><span class="line">audioFileTrack.play();</span><br></pre></td></tr></table></figure><h3 id="使用自定义方式"><a href="#使用自定义方式" class="headerlink" title="使用自定义方式"></a>使用自定义方式</h3><p>如果你熟悉 WebRTC 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack">MediaStreamTrack</a> 相关的 API，你可以通过自己实现采集来完成 <code>MediaStreamTrack</code> 的创建，然后通过 [createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 或者 [createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 方法将 <code>MediaStreamTrack</code> 对象转换成 SDK 内部的 <code>LocalAudioTrack</code> 或者 <code>LocalVideoTrack</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过自己实现采集获取 `MediaStreamTrack` 对象</span></span><br><span class="line"><span class="keyword">const</span> customMediaStreamTrack = getMediaStreamTrackFromXXX(<span class="comment">/* .. */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义的视频轨道</span></span><br><span class="line"><span class="keyword">const</span> customTrack = AgoraRTC.createCustomVideoTrack(&#123;</span><br><span class="line">  <span class="attr">mediaStreamTrack</span>: customMediaStreamTrack,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="启用和禁用本地轨道"><a href="#启用和禁用本地轨道" class="headerlink" title="启用和禁用本地轨道"></a>启用和禁用本地轨道</h3><p>创建好本地的轨道对象后，如果想要暂时关闭麦克风或摄像头，你可以禁用该轨道。SDK 提供 [LocalTrack.setEnabled](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 方法来启用或者禁用本地轨道对象。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>调用 <code>setEnabled(true)</code> 禁用本地轨道后，该轨道会停止本地播放。如果该轨道已经发布，发布也会停止，此时远端会收到 <code>user-unpublished</code> 回调；调用 <code>setEnabled(true)</code> 后，SDK 会自动重新发布轨道。</p><p>根据本地轨道类型的不同，调用 <code>setEnabled</code> 后会有一些不同的行为：</p><ul><li>通过设备采集创建的本地轨道（<code>CameraVideoTrack</code>/<code>MicrophoneAudioTrack</code>）：当调用 <code>setEnabled(false)</code> 后，会停止采集并释放其占用的设备。如果摄像头或麦克风有指示灯，此时指示灯会熄灭。当调用 <code>setEnabled(true)</code> 后，会自动恢复采集。</li><li>通过其他方式创建的本地轨道：当调用 <code>setEnabled(false)</code> 后，会默认编码黑屏帧（视频轨道）或者静音包（音频轨道）。当调用 <code>setEnabled(true)</code> 后，会自动恢复正常编码。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> videoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时关闭摄像头采集</span></span><br><span class="line"><span class="keyword">await</span> videoTrack.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复摄像头采集</span></span><br><span class="line"><span class="keyword">await</span> videoTrack.setEnabled(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>在创建本地音视频对象的过程中，由于不同设备和浏览器之间的差异，SDK 可能在调用上述方法时抛出异常。以下是调用创建轨道的方法时可能会遇到的错误：</p><ul><li><code>NOT_SUPPORTED</code>: 使用的功能在当前浏览器上不支持。</li><li><code>MEDIA_OPTION_INVALID</code>: 指定的采集参数无法被满足，一般是因为设备不支持指定的分辨率或帧率。</li><li><code>DEVICE_NOT_FOUND</code>: 找不到指定的采集设备。</li><li><code>PERMISSION_DENIED</code>: 用户拒绝授予访问摄像头/麦克风的权限，或者屏幕共享选择共享源时，用户没有选择共享源，并关闭了选择窗口。</li><li><code>CONSTRAINT_NOT_SATISFIED</code>: 浏览器不支持指定的采集选项。</li><li><code>SHARE_AUDIO_NOT_ALLOWED</code>: 屏幕共享分享音频时用户没有勾选<strong>分享音频</strong>。</li></ul><h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。</p><p>本文详细介绍如何使用 Agora Web SDK 发布和取消发布本地音视频，以及订阅和取消订阅远端音视频。</p><h3 id="发布音视频"><a href="#发布音视频" class="headerlink" title="发布音视频"></a>发布音视频</h3><p>完成本地轨道的创建并且成功加入频道后，就可以调用 [AgoraRTCClient.publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish) 将本地的音视频数据发布到当前频道，以供频道中的其他用户订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localAudioTrack = ...;</span><br><span class="line"><span class="keyword">const</span> localVideoTrack = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以多次调用 publish 发布多个轨道</span></span><br><span class="line"><span class="keyword">await</span> client.publish(localAudioTrack);</span><br><span class="line"><span class="keyword">await</span> client.publish(localVideoTrack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次性将需要发布的轨道一起发布</span></span><br><span class="line"><span class="keyword">await</span> client.publish([localAudioTrack, localVideoTrack]);</span><br></pre></td></tr></table></figure><p>关于发布，注意事项如下：</p><ul><li><p>同一时间只能发布一个视频轨道。</p></li><li><p>可以同时发布多个音频轨道，SDK 会自动混音。</p><blockquote><p>Safari 12 之前的版本不支持混音，无法使用此特性。</p></blockquote></li><li><p>可以多次调用该方法来发布不同的轨道，但是不能重复发布同一个轨道对象。</p></li><li><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p></li></ul><h3 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h3><p>在发布过程中，可能因为网络环境或者 SDK 使用不当抛出以下错误：</p><ul><li><code>INVALID_OPERATION</code>: 非法操作，说明在加入频道成功之前就调用了 <code>publish</code> 方法。</li><li><code>OPERATION_ABORTED</code>: 发布被中止，可能是因为在发布成功之前就主动调用 <code>leave</code> 离开了频道。</li><li><code>INVALID_LOCAL_TRACK</code>: 参数错误，传入了非法的 <code>LocalTrack</code> 对象。</li><li><code>CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS</code>: 不允许同时发布多个视频轨道。</li><li><code>NOT_SUPPORTED</code>: 发布了多个音频轨道，但是浏览器不支持混音。</li><li><code>UNEXPECTED_RESPONSE</code>: 收到了 Agora 服务器异常的返回，发布轨道失败。建议保留日志，联系 Agora <a href="https://agora-ticket.agora.io/">技术支持</a>。</li><li><code>NO_ICE_CANDIDATE</code>: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 <a href="https://docs.agora.io/cn/faq/console_error_web#none-ice-candidate-not-alloweda-namecandidatea">FAQ</a>。</li></ul><h3 id="取消发布音视频"><a href="#取消发布音视频" class="headerlink" title="取消发布音视频"></a>取消发布音视频</h3><p>成功发布本地轨道后，如果想取消发布，可以调用 [AgoraRTCClient.unpublish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布音视频</span></span><br><span class="line"><span class="keyword">await</span> client.publish([localAudioTrack, localVideoTrack]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消发布视频，此时音频还在正常发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish(localVideoTrack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次将所有正在发布的轨道全部取消发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish();</span><br><span class="line"><span class="comment">// 或者批量取消发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish([localAudioTrack, localVideoTrack]);</span><br></pre></td></tr></table></figure><p>关于取消发布，注意事项如下：</p><ul><li>该方法可以多次调用。你可以使用 <code>publish</code> 和 <code>unpublish</code> 实现发布和取消发布某个本地轨道。</li><li>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</li></ul><h3 id="订阅音视频"><a href="#订阅音视频" class="headerlink" title="订阅音视频"></a>订阅音视频</h3><p>当远端用户成功发布音视频轨道之后，SDK 会触发 [user-published](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件。这个事件携带两个参数：远端用户对象（<code>user</code>）和远端发布的媒体类型（<code>mediaType</code>）。此时，你可以调用 [AgoraRTCClient.subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 发起订阅。</p><blockquote><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或者 <code>async/await</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 发起订阅</span></span><br><span class="line">  <span class="keyword">await</span> client.subscribe(user, mediaType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果订阅的是音频轨道</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> audioTrack = user.audioTrack;</span><br><span class="line">    <span class="comment">// 自动播放音频</span></span><br><span class="line">    audioTrack.play();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> videoTrack = user.videoTrack;</span><br><span class="line">    <span class="comment">// 自动播放视频</span></span><br><span class="line">    videoTrack.play(DOM_ELEMENT);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当订阅方法调用完成之后，你可以通过 <code>user.audioTrack</code> 和 <code>user.videoTrack</code> 获取相应的 [RemoteAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 和 [RemoteVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。</p><p>订阅和发布不同，每次订阅只能订阅一个音频或视频轨道。即使发布端同时发布了音频轨道和视频轨道，SDK 也会触发两次 <code>user-published</code> 事件：一次 <code>user-published(audio)</code>，一次 <code>user-published(video)</code>。按照上面的代码逻辑，会完成两次订阅。</p><h3 id="处理-Autoplay-问题"><a href="#处理-Autoplay-问题" class="headerlink" title="处理 Autoplay 问题"></a>处理 Autoplay 问题</h3><p>详见[处理浏览器的自动播放策略](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/autoplay_policy_web_ng)。</p><h3 id="错误处理-3"><a href="#错误处理-3" class="headerlink" title="错误处理"></a>错误处理</h3><p>在订阅过程中，因为网络环境等因素 SDK 可能抛出如下错误：</p><ul><li><code>INVALID_OPERATION</code>: 非法操作，可能在加入频道成功之前就调用了 <code>subscribe</code>。</li><li><code>INVALID_REMOTE_USER</code>: 传入了非法的远端用户对象，例如该用户不在频道内。</li><li><code>REMOTE_USER_IS_NOT_PUBLISHED</code>：传入的远端用户没有发布 <code>subscribe</code> 方法中传入的媒体类型。</li><li><code>UNEXPECTED_RESPONSE</code>: 收到了 Agora 服务器异常的返回，订阅失败。建议保留日志，联系 Agora <a href="https://agora-ticket.agora.io/">技术支持</a>。</li><li><code>OPERATION_ABORTED</code>: 操作中止，可能在订阅成功之前就调用 <code>leave</code> 离开了频道。</li><li><code>NO_ICE_CANDIDATE</code>: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 <a href="https://docs.agora.io/cn/faq/console_error_web#none-ice-candidate-not-alloweda-namecandidatea">FAQ</a>。</li></ul><h3 id="取消订阅音视频"><a href="#取消订阅音视频" class="headerlink" title="取消订阅音视频"></a>取消订阅音视频</h3><p>你可以通过 [AgoraRTCClient.unsubscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe) 取消订阅远端的音视频。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅目标用户的音视频</span></span><br><span class="line"><span class="keyword">await</span> client.subscribe(user, <span class="string">&quot;audio&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> client.subscribe(user, <span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅视频</span></span><br><span class="line"><span class="keyword">await</span> client.unsubscribe(user, <span class="string">&quot;video&quot;</span>);</span><br><span class="line"><span class="comment">// 也可以取消订阅当前用户的所有媒体类型</span></span><br><span class="line"><span class="keyword">await</span> client.unsubscribe(user);</span><br></pre></td></tr></table></figure><p>关于取消订阅，注意事项如下：</p><ul><li>取消订阅成功后，SDK 会释放相应的 <code>RemoteTrack</code> 对象。一旦远端轨道对象被释放，SDK 会自动移除视频的播放元素，音频播放也会停止。</li><li>如果远端用户主动取消发布，本地会收到 <code>user-unpublished</code> 回调，收到该回调时 SDK 会自动释放相应的 <code>RemoteTrack</code> 对象，你无需再调用 <code>unsubscribe</code>。</li><li>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</li></ul><h2 id="api文档参考"><a href="#api文档参考" class="headerlink" title="api文档参考"></a>api文档参考</h2><p>Agora Web SDK 是通过 HTML 网页加载的 JavaScript 和 Typescript 库。你可以使用 Agora Web SDK 在网页浏览器中调用 API 建立连接，控制音视频通话和直播服务。</p><blockquote><p>请务必使用 HTTPS 协议或者 localhost，否则 SDK 无法正常工作。</p></blockquote><p>[全局模块](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#全局模块)</p><p>[AgoraRTC](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html) 是 Agora Web SDK 中所有可调用方法的入口，主要包含以下方法。</p><p>[核心方法](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#核心方法)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient)</td><td align="left">创建本地客户端</td></tr></tbody></table><p>[本地音视频采集](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地音视频采集)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)</td><td align="left">通过麦克风创建一个音频轨道对象</td></tr><tr><td align="left">[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)</td><td align="left">通过摄像头创建一个视频轨道对象</td></tr><tr><td align="left">[createMicrophoneAndCameraTracks](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks)</td><td align="left">同时创建麦克风音频轨道和摄像头视频轨道</td></tr><tr><td align="left">[createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack)</td><td align="left">通过屏幕共享创建一个视频轨道对象</td></tr><tr><td align="left">[createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack)</td><td align="left">通过音频文件创建一个音频轨道对象</td></tr><tr><td align="left">[createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack)</td><td align="left">创建一个自定义的音频轨道对象</td></tr><tr><td align="left">[createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack)</td><td align="left">创建一个自定义的视频轨道对象</td></tr></tbody></table><p>[媒体设备查询](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#媒体设备查询)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[getDevices](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getdevices)</td><td align="left">获取媒体设备列表</td></tr><tr><td align="left">[getCameras](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getcameras)</td><td align="left">获取摄像头列表</td></tr><tr><td align="left">[getMicrophones](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getmicrophones)</td><td align="left">获取麦克风列表</td></tr><tr><td align="left">[getPlaybackDevices](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getplaybackdevices)</td><td align="left">获取音频播放设备列表</td></tr><tr><td align="left">[getElectronScreenSources](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getelectronscreensources)</td><td align="left">获取 Electron 屏幕共享源列表</td></tr></tbody></table><p>[日志管理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#日志管理)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[enableLogUpload](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#enablelogupload)</td><td align="left">打开日志上传功能</td></tr><tr><td align="left">[disableLogUpload](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#disablelogupload)</td><td align="left">关闭日志上传功能</td></tr><tr><td align="left">[setLogLevel](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#setloglevel)</td><td align="left">设置日志等级</td></tr></tbody></table><p>[全局事件回调](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#全局事件回调)</p><table><thead><tr><th align="left">回调</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[onCameraChanged](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#oncamerachanged)</td><td align="left">视频采集设备状态变化回调</td></tr><tr><td align="left">[onMicrophoneChanged](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onmicrophonechanged)</td><td align="left">音频采集设备状态变化回调</td></tr><tr><td align="left">[onAudioAutoplayFailed](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onaudioautoplayfailed)</td><td align="left">音频轨道自动播放失败回调</td></tr></tbody></table><p>[其他](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#其他)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[checkSystemRequirements](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#checksystemrequirements)</td><td align="left">检测浏览器兼容性</td></tr><tr><td align="left">[getSupportedCodec](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getsupportedcodec)</td><td align="left">获取支持的编码格式</td></tr><tr><td align="left">[createChannelMediaRelayConfiguration](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createchannelmediarelayconfiguration)</td><td align="left">创建跨频道媒体流转发的配置对象</td></tr></tbody></table><h3 id="AgoraRTCClient-类"><a href="#AgoraRTCClient-类" class="headerlink" title="AgoraRTCClient 类"></a>AgoraRTCClient 类</h3><p>调用 [createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 创建一个本地客户端对象 [AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html)，代表一个通话中的本地用户。<code>AgoraRTCClient</code> 类提供音视频通话的核心功能，主要包含以下方法。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join)</td><td align="left">加入频道</td></tr><tr><td align="left">[leave](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave)</td><td align="left">离开频道</td></tr><tr><td align="left">[publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish)</td><td align="left">发布本地音视频轨道</td></tr><tr><td align="left">[unpublish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish)</td><td align="left">取消发布本地音视频轨道</td></tr><tr><td align="left">[subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe)</td><td align="left">订阅远端用户的音视频轨道</td></tr><tr><td align="left">[unsubscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe)</td><td align="left">取消订阅远端用户的音视频轨道</td></tr></tbody></table><h3 id="LocalTrack-类"><a href="#LocalTrack-类" class="headerlink" title="LocalTrack 类"></a>LocalTrack 类</h3><p><code>LocalTrack</code> 是 Agora Web SDK 中定义本地音视频轨道的抽象类，可用于本地播放和发布。</p><p>SDK 通过不同的方式创建不同的 <code>LocalTrack</code>，返回不同的 <code>LocalTrack</code> 派生类对象。以下列举了所有的 <code>LocalTrack</code> 派生类以及所对应的创建方式。</p><p>[本地音频轨道](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地音频轨道)</p><p>根据创建方式的不同，本地音频轨道可分为以下三种。其中 <code>LocalAudioTrack</code> 派生自 <code>LocalTrack</code>，<code>MicrophoneAudioTrack</code> 和 <code>BufferSourceAudioTrack</code> 派生自 <code>LocalAudioTrack</code>。</p><table><thead><tr><th align="left">本地音频轨道</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html)</td><td align="left">最基础的本地音频轨道对象，包含了基础的本地音频控制，如播放、设置音量控制。 通过调用 [AgoraRTC.createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 创建。</td></tr><tr><td align="left">[MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html)</td><td align="left">本地麦克风音频轨道对象，比 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制麦克风的方法。 通过调用 [AgoraRTC.createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack) 创建。</td></tr><tr><td align="left">[BufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ibuffersourceaudiotrack.html)</td><td align="left">通过读取音频数据源创建的本地音频轨道，比基础的 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制音频数据源的方法。 通过调用 [AgoraRTC.createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 创建。</td></tr></tbody></table><p>[本地视频轨道](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地视频轨道)</p><p>根据创建方式的不同，本地视频可分为以下两种。其中 <code>LocalVideoTrack</code> 派生自 <code>LocalTrack</code>，<code>CameraVideoTrack</code> 派生自 <code>LocalVideoTrack</code>。</p><table><thead><tr><th align="left">本地视频轨道</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html)</td><td align="left">最基础的本地视频轨道对象，包含了基础的本地视频控制，如播放、美颜。 通过调用 [AgoraRTC.createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 或 [AgoraRTC.createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 创建。</td></tr><tr><td align="left">[CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html)</td><td align="left">本地摄像头视频轨道对象，比 [LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html) 多一些控制摄像头和编码参数的方法。 通过调用 [AgoraRTC.createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack) 创建。</td></tr></tbody></table><h3 id="RemoteTrack-类"><a href="#RemoteTrack-类" class="headerlink" title="RemoteTrack 类"></a>RemoteTrack 类</h3><p><code>RemoteTrack</code> 是 Agora Web SDK 中用于定义远端音视频轨道的抽象类。</p><p>在实际操作中，你需要先调用 [AgoraRTCClient.subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 订阅远端用户，然后从远端用户对象 [AgoraRTCRemoteUser](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcremoteuser.html) 中获取派生自 <code>RemoteTrack</code> 的 [RemoteAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 对象和 [RemoteVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。</p><p>[引入方式](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#引入方式)</p><p>如果你通过 <code>&lt;script&gt;</code> 的方式引入 Agora Web SDK，可以通过访问 [AgoraRTC.createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 来获取导出的模块。</p><p>如果你通过 <code>npm</code> 或者模块化的方式引入 Agora Web SDK，可以通过以下方式访问 <code>AgoraRTC</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(AgoraRTC.createClient);</span><br></pre></td></tr></table></figure><p>[类型模块（适用于 Typescript）](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#类型模块（适用于-typescript）)</p><p>对于 Typescript 开发者，我们提供了 <code>.d.ts</code> 文件导出详细的类型定义。你可以查看 API 文档的 [Global](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/globals.html) 页面，该页面列出了所有 SDK 导出的模块和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC, &#123; IAgoraRTCClient &#125; <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client: IAgoraRTCClient = AgoraRTC.createClient();</span><br></pre></td></tr></table></figure><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>SDK 可能以下列方式抛出错误码：</p><ul><li>对于异步方法，SDK 返回 Promise 来通知异步操作的结果，Promise 被 reject 时 SDK 会抛出相应的错误码。</li><li>同步方法调用失败时，SDK 直接抛出错误码。</li><li>SDK 内部运行过程中，也可能抛出一些网络相关的错误码。</li></ul><p>你可参考本文了解这些错误码的详细含义及处理方法。</p><p>[通用错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#通用错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>UNEXPECTED_ERROR</code></td><td align="left">无法处理的、非预期的错误，通常这个错误会有具体的错误提示。</td><td align="left">无</td></tr><tr><td align="left"><code>UNEXPECTED_RESPONSE</code></td><td align="left">服务端返回了非预期的响应。</td><td align="left">无</td></tr><tr><td align="left"><code>INVALID_PARAMS</code></td><td align="left">非法参数。</td><td align="left">根据具体提示确认操作，并根据文档传入正确的参数。</td></tr><tr><td align="left"><code>NOT_SUPPORTED</code></td><td align="left">浏览器不支持。</td><td align="left">参考<a href="https://agoraio-community.github.io/AgoraWebSDK-NG/docs/zh-CN/overview">浏览器支持情况</a>。</td></tr><tr><td align="left"><code>INVALID_OPERATION</code></td><td align="left">非法操作，通常是因为在当前状态不能进行该操作。</td><td align="left">确认操作的先后顺序，比如发布前请确认已经加入频道。</td></tr><tr><td align="left"><code>OPERATION_ABORTED</code></td><td align="left">操作中止，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。</td><td align="left">通过 [AgoraRTCClient.on(“user-joined”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。</td></tr><tr><td align="left"><code>WEB_SECURITY_RESTRICT</code></td><td align="left">浏览器安全策略限制。</td><td align="left">请确保 Web 页面运行在<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">安全环境</a>中。</td></tr><tr><td align="left"><code>NO_ACTIVE_STATUS</code></td><td align="left">Agora 项目未激活或被禁用。</td><td align="left">请前往 Agora 控制台确认项目状态是否为启用。</td></tr></tbody></table><p>[请求相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#请求相关错误码)</p><p><strong>网络连接</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>NETWORK_TIMEOUT</code></td><td align="left">请求超时，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。</td><td align="left">通过 [AgoraRTCClient.on(“user-joined”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。</td></tr><tr><td align="left"><code>NETWORK_RESPONSE_ERROR</code></td><td align="left">响应错误，一般是状态码非法。</td><td align="left">确认操作的参数是否正确，并根据文档传入正确的参数。</td></tr><tr><td align="left"><code>NETWORK_ERROR</code></td><td align="left">无法定位的网络错误。</td><td align="left">无</td></tr></tbody></table><p><strong>SDK 内部请求</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>WS_ABORT</code></td><td align="left">请求 Agora 服务器过程中 WebSocket 断开。</td><td align="left">监听 [AgoraRTCClient.on(“connection-state-change”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 <strong>CONNECTED</strong> 后重试。</td></tr><tr><td align="left"><code>WS_DISCONNECT</code></td><td align="left">请求 Agora 服务器前，WebSocket 就已经断开。</td><td align="left">监听 [AgoraRTCClient.on(“connection-state-change”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 <strong>CONNECTED</strong> 后重试。</td></tr><tr><td align="left"><code>WS_ERR</code></td><td align="left">WebSocket 连接发生错误。</td><td align="left">检查当前浏览器对 WebSocket 的支持情况。</td></tr></tbody></table><p>[设备管理相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#设备管理相关错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>ENUMERATE_DEVICES_FAILED</code></td><td align="left">枚举本地设备失败，一般是由于浏览器限制。</td><td align="left">无</td></tr><tr><td align="left"><code>DEVICE_NOT_FOUND</code></td><td align="left">无法找到指定设备。</td><td align="left">传入正确的设备 ID。</td></tr></tbody></table><p>[Track 相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#track-相关错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>TRACK_IS_DISABLED</code></td><td align="left">轨道被禁用，通常因为轨道设置了 [Track.setEnabled(false)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled)。</td><td align="left">对该轨道调用 [Track.setEnabled(true)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 后再进行操作。</td></tr><tr><td align="left"><code>SHARE_AUDIO_NOT_ALLOWED</code></td><td align="left">屏幕共享音频时终端用户没有点击<strong>分享音频</strong>。</td><td align="left">要求终端用户在弹出的屏幕共享窗口中勾选<strong>分享音频</strong>。</td></tr><tr><td align="left"><code>CHROME_PLUGIN_NO_RESPONSE</code></td><td align="left">Chrome 屏幕共享插件无响应。</td><td align="left">确认 [Chrome 屏幕共享插件](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/chrome_screensharing_plugin)的状态或重新安装屏幕共享插件。</td></tr><tr><td align="left"><code>CHROME_PLUGIN_NOT_INSTALL</code></td><td align="left">Chrome 屏幕共享插件没有安装。</td><td align="left">安装 [Chrome 屏幕共享插件](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/chrome_screensharing_plugin)。</td></tr><tr><td align="left"><code>MEDIA_OPTION_INVALID</code></td><td align="left">不支持的媒体采集的参数。</td><td align="left">修改媒体采集参数或使用 SDK 预设的配置。</td></tr><tr><td align="left"><code>CONSTRAINT_NOT_SATISFIED</code></td><td align="left">不支持的媒体采集的参数。</td><td align="left">修改媒体采集参数或使用 SDK 预设的配置。</td></tr><tr><td align="left"><code>PERMISSION_DENIED</code></td><td align="left">获取媒体设备权限被拒绝。</td><td align="left">在弹出的获取设备权限窗口中选择<strong>允许</strong>。</td></tr><tr><td align="left"><code>FETCH_AUDIO_FILE_FAILED</code></td><td align="left">下载在线音频文件失败。</td><td align="left">填入正确的在线音频地址，并确保可以正常访问。</td></tr><tr><td align="left"><code>READ_LOCAL_AUDIO_FILE_ERROR</code></td><td align="left">读取本地音频文件失败。</td><td align="left">填入正确的本地音频文件路径。</td></tr><tr><td align="left"><code>DECODE_AUDIO_FILE_FAILED</code></td><td align="left">音频文件解码失败，可能是因为音频文件的编码格式是浏览器 WebAudio 不支持的编码格式。</td><td align="left">检查浏览器 WebAudio 是否支持音频文件的编码格式。</td></tr></tbody></table><p>[Client 相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#client-相关错误码)</p><p><strong>加入频道</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>UID_CONFLICT</code></td><td align="left">同一个频道内 UID 重复。</td><td align="left">使用不同的 UID 进入频道。</td></tr><tr><td align="left"><code>INVALID_UINT_UID_FROM_STRING_UID</code></td><td align="left">String UID 分配服务返回了非法的 int UID。</td><td align="left">使用不同的 UID 进入频道。</td></tr><tr><td align="left"><code>CAN_NOT_GET_PROXY_SERVER</code></td><td align="left">无法获取云代理服务地址。</td><td align="left">无</td></tr><tr><td align="left"><code>CAN_NOT_GET_GATEWAY_SERVER</code></td><td align="left">无法获取 Agora 服务器地址。</td><td align="left">无</td></tr></tbody></table><p><strong>发布/取消发布</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>INVALID_LOCAL_TRACK</code></td><td align="left">传入了非法的 LocalTrack。</td><td align="left">检查传入的 Track，并传入正确的 LocalTrack。</td></tr><tr><td align="left"><code>CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS</code></td><td align="left">一个 Client 发布多个视频轨道。</td><td align="left">一个 Client 同一时间只能发布一个视频轨道，如果想发布多个视频轨道请创建多个 Client。</td></tr></tbody></table><p><strong>订阅/取消订阅</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>INVALID_REMOTE_USER</code></td><td align="left">非法的远端用户，可能是远端用户不在频道内或还未发布任何媒体轨道。</td><td align="left">收到 [AgoraRTCClient.on(“user-published”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件后再进行订阅操作。</td></tr><tr><td align="left"><code>REMOTE_USER_IS_NOT_PUBLISHED</code></td><td align="left">远端用户已发布了音频或视频轨道，但不是与你的订阅操作所指定的类型不符。</td><td align="left">请确保订阅操作传入的轨道类型需要与 [AgoraRTCClient.on(“user-published”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published)) 事件给出的类型一致，或者在订阅前通过 [AgoraRTCRemoteUser.hasVideo]{@link AgoraRTCRemoteUser.hasVideo} 和 [AgoraRTCRemoteUser.hasAudio]{@link AgoraRTCRemoteUser.hasAudio} 确认远端用户是否发布了该类型的轨道。</td></tr></tbody></table><p>[推流到 CDN](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#推流到-cdn)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>LIVE_STREAMING_TASK_CONFLICT</code></td><td align="left">推流任务已经存在。</td><td align="left">先调用 [Client.stopLiveStreaming](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#stoplivestreaming) 停止该推流任务再重新进行推流操作。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INVALID_ARGUMENT</code></td><td align="left">推流参数错误。</td><td align="left">参考 [Client.startLiveStreaming](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#startlivestreaming) 的 API 文档检查推流操作的参数。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INTERNAL_SERVER_ERROR</code></td><td align="left">推流服务器内部错误。</td><td align="left">重新进行推流操作，如果仍然失败，刷新页面重试。</td></tr><tr><td align="left"><code>LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED</code></td><td align="left">推流 URL 被占用。</td><td align="left">检查填入的 URL 是否被占用。</td></tr><tr><td align="left"><code>LIVE_STREAMING_CDN_ERROR</code></td><td align="left">推流的目标 CDN 出现错误导致推流失败。</td><td align="left">确认目标 CDN 的健康状况。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INVALID_RAW_STREAM</code></td><td align="left">推流超时。</td><td align="left">确认目标流是否存在。</td></tr></tbody></table><p>[跨频道连麦](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#跨频道连麦)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>CROSS_CHANNEL_WAIT_STATUS_ERROR</code></td><td align="left">等待 [AgoraRTCClient.on(“channel-media-relay-state”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_channel_media_relay_state) 回调出错。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_JOIN_SRC</code></td><td align="left">发起跨频道转发媒体流请求失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_JOIN_DEST</code></td><td align="left">接受跨频道转发媒体流请求失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST</code></td><td align="left">服务器接收跨频道转发媒体流失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_SERVER_ERROR_RESPONSE</code></td><td align="left">服务器响应出错。</td></tr></tbody></table><h2 id="官方实例"><a href="#官方实例" class="headerlink" title="官方实例"></a>官方实例</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。如果你使用的是 3.x 或之前版本，请查看以下文档：</p><p>[跑通视频直播示例项目](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_live_web?platform=Web)</p><p>[实现音频直播](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/start_live_audio_web?platform=Web)</p><p>[实现视频直播](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/start_live_web?platform=Web)</p><p>根据本文指导快速集成 Agora Web SDK 并在你自己的 app 里实现实时音视频直播。</p><blockquote><p>由于浏览器的安全策略对除 127.0.0.1 以外的 HTTP 地址作了限制，Agora Web SDK 仅支持 HTTPS 协议或者 <code>http://localhost</code>（<code>http://127.0.0.1</code>）。请勿使用 HTTP 协议在 <code>http://localhost</code>（<code>http://127.0.0.1</code>） 之外访问你的项目。</p></blockquote><h3 id="开源示例项目"><a href="#开源示例项目" class="headerlink" title="开源示例项目"></a>开源示例项目</h3><p>我们在 GitHub 上提供一个开源的<a href="https://github.com/AgoraIO/API-Examples-Web">示例项目</a>供你参考。</p><p>同时，你可以通过我们的<a href="https://webdemo.agora.io/agora-websdk-api-example-4.x/">在线 Web 应用</a>快速体验 Agora 实现的音视频相关功能。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>可以连接到互联网的 Windows 或 macOS 计算机。如果你的网络环境部署了防火墙，请参考[应用企业防火墙限制](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/firewall?platform=Web)以正常使用 Agora 服务。</li><li>计算机搭载 2.2 GHz Intel 第二代 i3/i5/i7 处理器或同等性能的其他处理器。</li><li>物理音视频采集设备，如内置摄像头和麦克风。</li><li>安装最新稳定版 <a href="https://www.google.cn/chrome/">Chrome 浏览器</a>。</li><li>有效的 Agora [开发者账号](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/sign_in_and_sign_up?platform=Web)。</li></ul><h3 id="获取-SDK"><a href="#获取-SDK" class="headerlink" title="获取 SDK"></a>获取 SDK</h3><p>选择如下任意一种方法获取 Agora Web SDK：</p><h4 id="方法-1-使用-npm-获取-SDK"><a href="#方法-1-使用-npm-获取-SDK" class="headerlink" title="方法 1. 使用 npm 获取 SDK"></a>方法 1. 使用 npm 获取 SDK</h4><p>使用该方法需要先安装 npm，详见 <a href="https://www.npmjs.com.cn/getting-started/installing-node/">npm 快速入门</a>。</p><ol><li><p>运行安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install agora-rtc-sdk-ng --save</span><br></pre></td></tr></table></figure></li><li><p>在你的项目的 JavaScript 代码中加入以下代码，引入这个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"><span class="keyword">const</span> client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>如果你使用 TypeScript, 还可以引入 SDK 中的类型对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC, &#123; IAgoraRTCClient &#125; <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"><span class="keyword">const</span> client: IAgoraRTCClient = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="方法-2-使用-CDN-方法获取-SDK"><a href="#方法-2-使用-CDN-方法获取-SDK" class="headerlink" title="方法 2. 使用 CDN 方法获取 SDK"></a>方法 2. 使用 CDN 方法获取 SDK</h4><p>该方法无需下载安装包。在项目 HTML 文件中，添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://download.agora.io/sdk/release/AgoraRTC_N-4.6.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方法-3-手动下载-SDK"><a href="#方法-3-手动下载-SDK" class="headerlink" title="方法 3. 手动下载 SDK"></a>方法 3. 手动下载 SDK</h4><ol><li><p>[下载](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/downloads?platform=Web) Agora Web SDK 4.x 版本 SDK 包。</p></li><li><p>将下载下来的 <code>.js</code> 文件保存到项目文件所在的目录下。</p></li><li><p>在项目文件中，将如下代码添加到 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./AgoraRTC_N-4.6.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>在方法 2 和方法 3 中，SDK 都会在全局导出一个 <code>AgoraRTC</code> 对象，直接访问这个对象即可操作 SDK。</li><li>在我们的示例项目中，为方便起见，我们选择第二种方法，直接使用 CDN 链接。</li></ul></blockquote><p>现在，我们已经将 Agora Web SDK 集成到项目中了。下一步我们要调用 Agora Web SDK 提供的核心 API。</p><h3 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h3><p>在使用 Agora Web SDK 时，你会经常用到以下三种对象：</p><ul><li>[AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象，代表一个本地客户端。<code>AgoraRTCClient</code> 类的方法提供了音视频通话的主要功能，例如加入频道、发布音视频轨道等。</li><li>[LocalTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 对象和 [RemoteTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotetrack.html) 对象，代表本地和远端的音视频轨道对象，用于播放等音视频相关的控制。</li></ul><blockquote><p>音视频流由音视频轨道构成。在 Agora Web SDK 中，我们通过操作音视频轨道对象来控制音视频流的行为。</p></blockquote><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>一次简单的音视频直播的步骤一般如下：</p><ol><li>根据项目的 App ID 创建一个本地客户端 <code>AgoraRTCClient</code> 对象，</li><li>调用 <code>AgoraRTCClient.setClientRole</code> 设置用户角色。</li><li>通过 <code>AgoraRTCClient.join</code> 加入到一个指定的频道中。</li><li>通过麦克风采集的音频创建一个 <code>MicrophoneAudioTrack</code> 对象（本地音频轨道对象）；通过摄像头采集的视频创建一个 <code>CameraVideoTrack</code> 对象（本地视频轨道对象）。</li><li>通过 <code>AgoraRTCClient.publish</code> 将创建的本地音视频轨道对象发布到频道中。</li></ol><p>当有其他用户加入频道并且也发布音视频轨道时：</p><ol><li>SDK 会触发 <code>client.on(&quot;user-published&quot;)</code> 事件，在这个事件回调函数的参数中你可以拿到远端用户对象 <code>AgoraRTCRemoteUser</code>，表示这个用户刚刚发布了音视频轨道。</li><li>通过 <code>AgoraRTCClient.subscribe</code> 订阅获取到的 <code>AgoraRTCRemoteUser</code>。</li><li>订阅完成后，访问 <code>AgoraRTCRemoteUser.audioTrack</code> 和 <code>AgoraRTCRemoteUser.videoTrack</code> 即可获取到 <code>RemoteAudioTrack</code>（远端音频轨道对象）和 <code>RemoteVideoTrack</code>（远端视频轨道对象）。</li></ol><p>下图展示了基础的音视频直播的 API 调用。注意图中的方法是对不同的对象调用的。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210810000548.png"></p><p>为方便起见，我们预定义了两个变量和一个函数，下面的所有示例代码都包裹在这个函数中。此步骤不是必须的，你可以根据你的项目有其他的实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rtc = &#123;</span><br><span class="line">  <span class="comment">// 用来放置本地客户端。</span></span><br><span class="line">  <span class="attr">client</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 用来放置本地音视频频轨道对象。</span></span><br><span class="line">  <span class="attr">localAudioTrack</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">localVideoTrack</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="comment">// 替换成你自己项目的 App ID。</span></span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&quot;&lt;YOUR APP ID&gt;&quot;</span>,</span><br><span class="line">  <span class="comment">// 传入目标频道名。</span></span><br><span class="line">  <span class="attr">channel</span>: <span class="string">&quot;demo_channel_name&quot;</span>,</span><br><span class="line">  <span class="comment">// 如果你的项目开启了 App 证书进行 Token 鉴权，这里填写生成的 Token 值。</span></span><br><span class="line">  <span class="attr">token</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 设置频道内的用户角色，可设为 &quot;audience&quot; 或 &quot;host&quot;</span></span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;audience&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBasicLive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接下来的代码写在这里。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startBasicLive();</span><br></pre></td></tr></table></figure><h4 id="1-创建本地客户端"><a href="#1-创建本地客户端" class="headerlink" title="1. 创建本地客户端"></a>1. 创建本地客户端</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtc.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;live&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>调用 <code>createClient</code> 方法创建本地客户端对象。需注意 <code>mode</code> 和 <code>codec</code> 这两个参数的设置：</p><ul><li><p><code>mode</code> 用于设置[频道场景](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/terms?platform=All Platforms#channel-profile)。Agora Web SDK 会根据使用场景的不同实行不同的优化策略。</p><ul><li>一对一或多人通话中，建议设为 <code>&quot;rtc&quot;</code>，使用通信场景。</li><li>互动直播中，建议设为 <code>&quot;live&quot;</code>，使用直播场景。</li></ul></li><li><p><code>codec</code> 用于设置浏览器使用的编解码格式。如果你需要使用 Safari 12.1 及之前版本，将该参数设为 <code>&quot;h264&quot;</code>；其他情况我们推荐使用 <code>&quot;vp8&quot;</code>。</p></li></ul><h4 id="2-设置用户角色"><a href="#2-设置用户角色" class="headerlink" title="2. 设置用户角色"></a>2. 设置用户角色</h4><p>直播频道有两种用户角色：主播和观众，默认的角色为观众。直播频道内的用户，只能看到主播的画面、听到主播的声音。</p><p>设置频道场景为直播后，你可以调用 <code>setClientRole</code> 方法设置用户角色。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role 的值可以是 &quot;host&quot; 或者 &quot;audience&quot;。</span></span><br><span class="line">client.setClientRole(options.role);</span><br></pre></td></tr></table></figure><p>加入频道后，如果你想切换用户角色，也可以调用 <code>setClientRole</code> 方法。</p><h4 id="3-加入目标频道"><a href="#3-加入目标频道" class="headerlink" title="3. 加入目标频道"></a>3. 加入目标频道</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uid = <span class="keyword">await</span> rtc.client.join(options.appId, options.channel, options.token, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>调用 <code>join</code> 加入目标频道。该方法返回一个 <code>Promise</code>，当返回 <code>resolve</code> 时表示加入频道成功，返回 <code>reject</code> 时表示加入频道出现错误。我们可以利用 <code>async/await</code> 极大地简化我们的代码。</p><p>调用 <code>join</code> 方法时你需要注意以下参数：</p><ul><li><p><code>appid</code>: 你的 App ID。详见[创建 Agora 项目](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_video_call_web?platform=Web##1-创建-agora-项目)和[获取 App ID](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_video_call_web?platform=Web#appid)。</p></li><li><p><code>channel</code>: 频道名，长度在 64 字节以内的字符串。在我们的示例项目中，<code>channel</code> 的值设为 <code>demo_channel_name</code>。</p></li><li><p><code>token</code>: （可选）如果你的 Agora 项目开启了 App 证书，你需要在该参数中传入一个 Token，详见[使用 Token](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/token?platform=All Platforms#使用-token)。</p><ul><li><p>在测试环境，我们推荐使用控制台生成临时 Token，详见[获取临时 Token](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/token?platform=All Platforms%23get-a-temporary-token#获取临时-token)。</p></li><li><p>在生产环境，我们推荐你在自己的服务端生成 Token，详见</p><p>生成 Token</p><blockquote><p>在我们的示例项目中，为了叙述方便，没有开启 App 证书，所以不需要校验 Token，<code>token</code> 的值为 <code>null</code>。如果你启用了 App 证书，请确保上面传入的 <code>channel</code> 值和生成 Token 时传入的 <code>channel</code> 值保持一致。</p></blockquote></li></ul></li><li><p><code>uid</code>：用户 ID，频道内每个用户的 UID 必须是唯一的。你可以填 <code>null</code>，Agora 会自动分配一个 UID 并在 <code>join</code> 的结果中返回。</p></li></ul><p>更多的 API 介绍和注意事项请参考 [AgoraRTCClient.join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 接口中的参数描述。</p><h4 id="4-创建并发布本地音视频轨道"><a href="#4-创建并发布本地音视频轨道" class="headerlink" title="4. 创建并发布本地音视频轨道"></a>4. 创建并发布本地音视频轨道</h4><p>当用户角色设为主播时，成功加入频道后，就可以创建并发布本地音视频轨道了。</p><p>如果用户角色设为观众，跳过该步骤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过麦克风采集的音频创建本地音频轨道对象。</span></span><br><span class="line">rtc.localAudioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line"><span class="comment">// 通过摄像头采集的视频创建本地视频轨道对象。</span></span><br><span class="line">rtc.localVideoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"><span class="comment">// 将这些音视频轨道对象发布到频道中。</span></span><br><span class="line"><span class="keyword">await</span> rtc.client.publish([rtc.localAudioTrack, rtc.localVideoTrack]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;publish success!&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们先调用 <code>createMicrophoneAudioTrack</code> 通过麦克风采集的音频创建本地音频轨道对象，调用 <code>createCameraVideoTrack</code> 通过摄像头采集的视频创建本地视频轨道对象；然后调用 <code>publish</code> 方法，将这些本地音视频轨道对象当作参数即可将音视频发布到频道中。</p><blockquote><ul><li>以上方法都会返回 <code>Promise</code>，<code>resolve</code> 时代表成功，<code>reject</code> 时代表失败。我们使用 <code>async/await</code> 来让代码逻辑更清晰。</li><li>由于加入频道和创建本地音视频轨道没有依赖关系，你可以利用 <code>Promise.all</code> 同时执行这些异步操作。</li></ul></blockquote><p>详细的参数设置（如采集设备和编码参数）请参考相关 API 文档：</p><ul><li>[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)</li><li>[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)</li><li>[publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish)</li></ul><h4 id="5-订阅远端用户"><a href="#5-订阅远端用户" class="headerlink" title="5. 订阅远端用户"></a>5. 订阅远端用户</h4><p>当远端用户发布音视频轨道时，SDK 会触发 <code>client.on(&quot;user-published&quot;)</code> 事件。我们需要通过 <code>client.on</code> 监听该事件并在回调中订阅新加入的远端用户。</p><blockquote><p>我们建议<strong>在创建客户端对象之后立即监听事件</strong>，以避免错过任何事件。放在这里介绍是因为叙述顺序。</p></blockquote><p>在 <code>createClient</code> 后下一行插入以下代码，监听 <code>client.on(&quot;user-published&quot;)</code> 事件，当有远端用户发布时开始订阅，并在订阅后自动播放远端音视频轨道对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">rtc.client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 开始订阅远端用户。</span></span><br><span class="line">  <span class="keyword">await</span> rtc.client.subscribe(user, mediaType);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;subscribe success&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示本次订阅的是视频。</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅完成后，从 `user` 中获取远端视频轨道对象。</span></span><br><span class="line">    <span class="keyword">const</span> remoteVideoTrack = user.videoTrack;</span><br><span class="line">    <span class="comment">// 动态插入一个 DIV 节点作为播放远端视频轨道的容器。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="comment">// 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">    playerContainer.id = user.uid.toString();</span><br><span class="line">    playerContainer.style.width = <span class="string">&quot;640px&quot;</span>;</span><br><span class="line">    playerContainer.style.height = <span class="string">&quot;480px&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.append(playerContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅完成，播放远端音视频。</span></span><br><span class="line">    <span class="comment">// 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。</span></span><br><span class="line">    remoteVideoTrack.play(playerContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以只传入该 DIV 节点的 ID。</span></span><br><span class="line">    <span class="comment">// remoteVideoTrack.play(playerContainer.id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示本次订阅的是音频。</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅完成后，从 `user` 中获取远端音频轨道对象。</span></span><br><span class="line">    <span class="keyword">const</span> remoteAudioTrack = user.audioTrack;</span><br><span class="line">    <span class="comment">// 播放音频因为不会有画面，不需要提供 DOM 元素的信息。</span></span><br><span class="line">    remoteAudioTrack.play();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你需要注意 <code>user-published</code> 事件的第二个参数 <code>mediaType</code>, 代表远端用户当前发布的媒体类型：</p><ul><li><code>audio</code>: 远端用户发布了音频轨道。</li><li><code>video</code>: 远端用户发布了视频轨道。</li></ul><p>当远端用户取消发布或离开频道时，SDK 会触发 <code>client.on(&quot;user-unpublished&quot;)</code> 事件。此时我们需要销毁刚刚动态创建的 DIV 节点。</p><p>在刚刚监听 <code>client.on(&quot;user-published&quot;)</code> 事件的代码下一行插入以下代码，监听 <code>client.on(&quot;user-unpublished&quot;)</code> 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rtc.client.on(<span class="string">&quot;user-unpublished&quot;</span>, <span class="function">(<span class="params">user, mediaType</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取刚刚动态创建的 DIV 节点。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.getElementById(user.uid.toString());</span><br><span class="line">    <span class="comment">// 销毁这个节点。</span></span><br><span class="line">    playerContainer.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-离开频道"><a href="#6-离开频道" class="headerlink" title="6. 离开频道"></a>6. 离开频道</h4><p>通过以下步骤离开频道：</p><ol><li>销毁创建的本地音视频轨道，解除网页对摄像头和麦克风的访问。</li><li>手动销毁之前动态创建的 DIV 节点。</li><li>调用 <code>leave</code> 离开频道。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">leaveCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 销毁本地音视频轨道。</span></span><br><span class="line">  rtc.localAudioTrack.close();</span><br><span class="line">  rtc.localVideoTrack.close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历远端用户。</span></span><br><span class="line">  rtc.client.remoteUsers.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 销毁动态创建的 DIV 节点。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.getElementById(user.uid);</span><br><span class="line">    playerContainer &amp;&amp; playerContainer.remove();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开频道。</span></span><br><span class="line">  <span class="keyword">await</span> rtc.client.leave();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在不同的产品设计中，离开频道可以既不销毁本地流，也不销毁动态创建的 DIV 节点。这些操作不是必须的，根据您自己的情况调整代码。</p></blockquote><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><p>AgoraRTC_Audio.vue       js核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;AgoraRTC_Audio&#x27;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="attr">uid</span>: &#123;</span><br><span class="line">                <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">Number</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">status</span>: &#123;</span><br><span class="line">                <span class="attr">default</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">Boolean</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">channel</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">token</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">appId</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">                <span class="attr">default</span>: <span class="string">&#x27;f4e2f949feaf400583aa1872ffeed2eb&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">videoContainerId</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">classroomRole</span>: <span class="built_in">Number</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">client</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">localAudioTrack</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">localVideoTrack</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">remoteUsers</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">localStream</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">publishStatus</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">checkDeviceTime</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">fun</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;audioinput&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;videoinput&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">deviceCheck</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;deviceCheck&#x27;</span>)</span><br><span class="line">                AgoraRTC.onMicrophoneChanged = <span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;microphone changed!&quot;</span>, info.state, info.device);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">let</span> res = &#123;</span><br><span class="line">                    <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">let</span> devices = <span class="keyword">await</span> <span class="built_in">this</span>.getDevices()</span><br><span class="line">                <span class="built_in">console</span>.log(devices)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">Object</span>.keys(devices).length)&#123;</span><br><span class="line">                    res.code = <span class="number">1</span></span><br><span class="line">                    res.msg = <span class="built_in">this</span>.GLOBAL.errorMsg.main[<span class="string">&#x27;mic device is not fount&#x27;</span>]</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> &#123;audioinput, videoinput&#125; = devices</span><br><span class="line">                    <span class="keyword">let</span> audioId = audioinput.deviceId;</span><br><span class="line">                    <span class="keyword">let</span> videoId = videoinput.deviceId;</span><br><span class="line">                    <span class="keyword">let</span> audioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack(&#123; <span class="attr">microphoneId</span>: audioId &#125;)</span><br><span class="line">                    <span class="keyword">let</span> videoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack(&#123;<span class="attr">cameraId</span>: videoId&#125;);</span><br><span class="line">                    <span class="keyword">let</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.deviceCheckAction(audioTrack, videoTrack)</span><br><span class="line">                    <span class="keyword">if</span>(!status)&#123;</span><br><span class="line">                        res.code = <span class="number">0</span></span><br><span class="line">                        res.msg = <span class="built_in">this</span>.GLOBAL.errorMsg.main[<span class="string">&#x27;have mic no volume&#x27;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">getDevices</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> devices = <span class="keyword">await</span> AgoraRTC.getDevices()</span><br><span class="line">                <span class="built_in">console</span>.log(devices)</span><br><span class="line">                devices = devices || []</span><br><span class="line">                <span class="keyword">let</span> &#123;fun&#125; = <span class="built_in">this</span></span><br><span class="line">                <span class="keyword">let</span> funDe = &#123;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> devices)&#123;</span><br><span class="line">                    <span class="keyword">let</span> &#123;kind&#125; = devices[i]</span><br><span class="line">                    <span class="keyword">if</span>(!fun[kind] || funDe[kind]) <span class="keyword">continue</span></span><br><span class="line">                    funDe[kind] = devices[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> funDe</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">deviceCheckAction</span>(<span class="params">audioTrack</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> t = <span class="built_in">this</span>.checkDeviceTime * <span class="number">1000</span></span><br><span class="line">                    <span class="keyword">let</span> num = t, status = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        num = num - <span class="number">1000</span></span><br><span class="line">                        <span class="keyword">const</span> level = audioTrack.getVolumeLevel();</span><br><span class="line">                        <span class="keyword">if</span>(level &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            status = <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;local stream audio level&quot;</span>, level);</span><br><span class="line">                        <span class="keyword">if</span>(t &lt;= <span class="number">0</span> || status)&#123;</span><br><span class="line">                            <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">                            success(<span class="literal">true</span>)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">1000</span>);</span><br><span class="line">                    <span class="built_in">this</span>.GLOBAL.timeoutGet(t).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!status) success(<span class="literal">false</span>)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> promise</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">pageInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.localAudioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line">                <span class="built_in">this</span>.localVideoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line">                <span class="built_in">this</span>.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;)</span><br><span class="line">                <span class="built_in">this</span>.eventInit()</span><br><span class="line">                <span class="comment">// 订阅自己的视频</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.localVideoTrack) <span class="built_in">this</span>.localVideoTrack.play(<span class="built_in">this</span>.getVideoContainerId(&#123;<span class="attr">uid</span>: <span class="built_in">this</span>.uid&#125;))</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.join()</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.publishCon();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">pageInitS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;)</span><br><span class="line">                <span class="built_in">this</span>.eventInit()</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.join()</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.publishCon();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">join</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.client.join(<span class="built_in">this</span>.appId, <span class="built_in">this</span>.channel, <span class="built_in">this</span>.token, <span class="built_in">this</span>.uid);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;join status&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">renewToken</span>(<span class="params">token</span>)</span>&#123;</span><br><span class="line">                token = token || <span class="built_in">this</span>.token</span><br><span class="line">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.client.renewToken(token)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">getVideoContainerId</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// let &#123;videoContainerId&#125; = this</span></span><br><span class="line">                <span class="comment">// if(videoContainerId) return videoContainerId</span></span><br><span class="line">                <span class="comment">// const playerContainer = document.createElement(&quot;div&quot;);</span></span><br><span class="line">                <span class="comment">// // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">                <span class="comment">// playerContainer.id = user.uid.toString();</span></span><br><span class="line">                <span class="comment">// playerContainer.style.width = &quot;640px&quot;;</span></span><br><span class="line">                <span class="comment">// playerContainer.style.height = &quot;480px&quot;;</span></span><br><span class="line">                <span class="comment">// document.body.append(playerContainer);</span></span><br><span class="line">                <span class="comment">// return playerContainer.id</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;user.uid&#125;</span>_user_video`</span></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">eventInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;user-published&#x27;</span>)</span><br><span class="line">                    <span class="comment">// 开始订阅远端用户。</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="built_in">this</span>.client.subscribe(user, mediaType);</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;subscribe success&quot;</span>);</span><br><span class="line">                    <span class="built_in">console</span>.log(mediaType)</span><br><span class="line">                    <span class="comment">// 表示本次订阅的是音频。</span></span><br><span class="line">                    <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 订阅完成后，从 `user` 中获取远端音频轨道对象。</span></span><br><span class="line">                        <span class="keyword">const</span> remoteAudioTrack = user.audioTrack;</span><br><span class="line">                        <span class="comment">// 播放音频因为不会有画面，不需要提供 DOM 元素的信息。</span></span><br><span class="line">                        remoteAudioTrack.play();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 表示本次订阅的是视频。</span></span><br><span class="line">                    <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 订阅完成后，从 `user` 中获取远端视频轨道对象。</span></span><br><span class="line">                        <span class="keyword">const</span> remoteVideoTrack = user.videoTrack;</span><br><span class="line">                        <span class="comment">// // 动态插入一个 DIV 节点作为播放远端视频轨道的容器。</span></span><br><span class="line">                        <span class="comment">// const playerContainer = document.createElement(&quot;div&quot;);</span></span><br><span class="line">                        <span class="comment">// // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">                        <span class="comment">// playerContainer.id = user.uid.toString();</span></span><br><span class="line">                        <span class="comment">// playerContainer.style.width = &quot;640px&quot;;</span></span><br><span class="line">                        <span class="comment">// playerContainer.style.height = &quot;480px&quot;;</span></span><br><span class="line">                        <span class="comment">// document.body.append(playerContainer);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// // 订阅完成，播放远端音视频。</span></span><br><span class="line">                        <span class="comment">// // 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。</span></span><br><span class="line">                        <span class="comment">// remoteVideoTrack.play(playerContainer);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// // 也可以只传入该 DIV 节点的 ID。</span></span><br><span class="line">                        <span class="keyword">let</span> id = <span class="built_in">this</span>.getVideoContainerId(user)</span><br><span class="line">                        remoteVideoTrack.play(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//远端用户或主播加入频道回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;user-joined&#x27;</span>, <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;用户加入频道&#x27;</span>)</span><br><span class="line">                    <span class="built_in">console</span>.log(user)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//远端用户离线回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;user-left&#x27;</span>, <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;用户离开频道&#x27;</span>)</span><br><span class="line">                    <span class="built_in">console</span>.log(user)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//报告频道内正在说话的远端用户及其音量的回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;volume-indicator&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(data)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//token过期回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;token-privilege-did-expire&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;token 失效&#x27;</span>)</span><br><span class="line">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;tokenInvalid&#x27;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//token 即将过期(30s)</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&quot;token-privilege-will-expire&quot;</span>, <span class="keyword">async</span> () =&gt;&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;token 即将 失效&#x27;</span>)</span><br><span class="line">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;tokenWillInvalid&#x27;</span>)</span><br><span class="line">                    <span class="comment">// await client.renewToken(token);</span></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//异常回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;exception&#x27;</span>, <span class="built_in">this</span>.handlError)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">handlError</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;agroa error&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(e)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">publishCon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.status)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.status) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">this</span>.publish()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">unpublish</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// if(!this.client || !this.publishStatus) return</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;unpublish&#x27;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.unpublish(<span class="built_in">this</span>.localAudioTrack);</span><br><span class="line">                <span class="built_in">this</span>.publishStatus = <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">publish</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// if(!this.client || this.publishStatus) return</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;publish&#x27;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.publish([<span class="built_in">this</span>.localAudioTrack, <span class="built_in">this</span>.localVideoTrack]);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;publish success!&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.publishStatus = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">leave</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client || !<span class="built_in">this</span>.client.leave || !<span class="built_in">this</span>.localAudioTrack || !<span class="built_in">this</span>.localAudioTrack.close) <span class="keyword">return</span></span><br><span class="line">                <span class="comment">// 销毁本地音频轨道。</span></span><br><span class="line">                <span class="built_in">this</span>.localAudioTrack.close();</span><br><span class="line">                <span class="built_in">this</span>.localVideoTrack.close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 离开频道。</span></span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.leave();</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">bannedVoiceSet</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">                status = status || <span class="built_in">this</span>.status</span><br><span class="line">                status ? <span class="built_in">this</span>.publish() : <span class="built_in">this</span>.unpublish()</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">watch</span>: &#123;</span><br><span class="line">            <span class="attr">status</span>: &#123;</span><br><span class="line">                <span class="function"><span class="title">handler</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.bannedVoiceSet(val)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>应用文件代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTCAudioVue <span class="keyword">from</span> <span class="string">&#x27;../../components/AgoraRTC_Audio4.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">agoraInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.agoraDisabled)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;不开启语音&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&#x27;开启语音&#x27;)</span></span><br><span class="line">    <span class="keyword">let</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.deviceCheckOpen()</span><br><span class="line">    <span class="comment">// this.agoraStatus = status</span></span><br><span class="line">    <span class="comment">// if(!status) return</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.agoraToekInit()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.agoraChannelName &amp;&amp; <span class="built_in">this</span>.agoraToken)&#123;</span><br><span class="line">        <span class="comment">// 开启视频</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.classroomRole == <span class="number">0</span>)&#123;   </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.$refs[<span class="string">&#x27;AgoraRTCAudioVue&#x27;</span>].pageInit()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.$refs[<span class="string">&#x27;AgoraRTCAudioVue&#x27;</span>].pageInitS()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.micStatusSet(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在各个文件中进行带调用完成加入，发布，订阅，销毁等主要功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;声网&quot;&gt;&lt;a href=&quot;#声网&quot; class=&quot;headerlink&quot; title=&quot;声网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.agora.io/cn&quot;&gt;声网&lt;/a&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;产品概述&quot;&gt;&lt;a href=&quot;#产品概述&quot; </summary>
      
    
    
    
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
</feed>
