<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andylin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/d2d617c7604cf8dda9f78dd0f6fa3899</icon>
  <subtitle>永无止境，奋斗不息</subtitle>
  <link href="https://andylinwenqin.github.io/atom.xml" rel="self"/>
  
  <link href="https://andylinwenqin.github.io/"/>
  <updated>2021-09-21T16:37:58.634Z</updated>
  <id>https://andylinwenqin.github.io/</id>
  
  <author>
    <name>林文钦</name>
    <email>andylin0119@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试算法题整理(持续更新)</title>
    <link href="https://andylinwenqin.github.io/2021/09/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>https://andylinwenqin.github.io/2021/09/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2021-09-21T16:34:02.000Z</published>
    <updated>2021-09-21T16:37:58.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试基础算法题整理-力扣"><a href="#面试基础算法题整理-力扣" class="headerlink" title="面试基础算法题整理(力扣)"></a>面试基础算法题整理(力扣)</h1><hr><h2 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试基础算法题整理-力扣&quot;&gt;&lt;a href=&quot;#面试基础算法题整理-力扣&quot; class=&quot;headerlink&quot; title=&quot;面试基础算法题整理(力扣)&quot;&gt;&lt;/a&gt;面试基础算法题整理(力扣)&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-斐波那契数列&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="基础算法" scheme="https://andylinwenqin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue nextTick实现原理</title>
    <link href="https://andylinwenqin.github.io/2021/09/22/Vue-nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://andylinwenqin.github.io/2021/09/22/Vue-nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-21T16:29:24.000Z</published>
    <updated>2021-09-21T16:33:14.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言#"></a>前言<a href="https://www.cnblogs.com/leiting/p/13174545.html#1525433879">#</a></h2><p>熟悉 vue 的前端，想必对 vue 里的 nextTick 也很熟悉了，用的时候就知道他是延迟回调，有时候用起来甚至和setTimeout 看起来是同样的效果。但他和setTimeout到底有什么区别？他是如何实现的？<br>本文就nextTick的实现引入，来探讨下js中的异步与同步，微任务与宏任务。</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick#"></a>nextTick<a href="https://www.cnblogs.com/leiting/p/13174545.html#1982108441">#</a></h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法#"></a>用法<a href="https://www.cnblogs.com/leiting/p/13174545.html#1819675761">#</a></h3><p>先搬运下文档 <a href="https://cn.vuejs.org/v2/api/#Vue-nextTick">Vue-nextTick</a></p><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现#"></a>源码实现<a href="https://www.cnblogs.com/leiting/p/13174545.html#686070981">#</a></h3><p>在了解原理之前先看下 <code>nextTick</code> 源码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line"><span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line"><span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line"><span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line"><span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line"><span class="comment">// Promise is available, we will use it:</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面有几个条件判断 如果支持 Promise 就用 <code>Promise</code><br>如果不支持就用 MutationObserver <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MDN-MutationObserver</a><br>MutationObserver 它会在指定的DOM发生变化时被调用<br>如果不支持 MutationObserver 的话就用 setImmediate <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">MDN-setImmediate</a><br>但是这个特性只有最新版IE和node支持，然后是最后一个条件 如果这些都不支持的话就用setTimeout。<br>看完这一段其实也很懵，为什么要这样设计呢？为什么要这样一个顺序来判断呢？说到这里就不得不讨论JavaScript 运行机制（Event Loop）&amp;微任务宏任务了。</p><h2 id="JavaScript-运行机制（Event-Loop）"><a href="#JavaScript-运行机制（Event-Loop）" class="headerlink" title="JavaScript 运行机制（Event Loop）#"></a>JavaScript 运行机制（Event Loop）<a href="https://www.cnblogs.com/leiting/p/13174545.html#2233592744">#</a></h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程#"></a>单线程<a href="https://www.cnblogs.com/leiting/p/13174545.html#1755427140">#</a></h3><p>JS是单线程，同一个时间只能做一件事。至于JS为什么是单线程？</p><blockquote><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p></blockquote><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步#"></a>同步和异步<a href="https://www.cnblogs.com/leiting/p/13174545.html#1140498455">#</a></h3><p>js里的任务分为两种：同步任务（synchronous）和异步任务（asynchronous）。同步阻塞异步非阻塞。<br>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，例如alert，会阻塞后续任务的执行，只有在点击确定之后，才会执行下一个任务。<br>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。所以会有任务队列的概念。正因为是单线程，所以所有任务都是主线程执行的，异步请求这些也不会开辟新的线程，而是放到任务队列，当这些异步操作被触发时才进入主线程执行。</p><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务#"></a>宏任务和微任务<a href="https://www.cnblogs.com/leiting/p/13174545.html#813966259">#</a></h3><p>JS任务又分为宏任务和微任务。<br>宏任务（macrotask）：setTimeout、setInterval、setImmediate、I/O、UI rendering<br>微任务（microtask）：promise.then、process.nextTick、MutationObserver、queneMicrotask(开启一个微任务)</p><p>宏任务按顺序执行，且浏览器在每个宏任务之间渲染页面<br>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;…）</p><p>微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，比如对一系列动作做出反馈，或或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。</p><p>何时使用微任务</p><blockquote><p>微任务的执行时机，晚于当前本轮事件循环的 Call Stack(调用栈)中的代码（宏任务），遭遇事件处理函数和定时器的回调函数</p></blockquote><p>使用微任务的原因</p><blockquote><p>减少操作中用户可感知到的延迟<br>确保任务顺序的一致性，即便当结果或数据是同步可用的<br>批量操作的优化</p></blockquote><p>了解了宏任务和微任务的执行顺序，就可以了解到为何nextTick 要优先使用<code>Promise</code>和<code>MutationObserver</code> 因为他俩属于微任务，会在执行栈空闲的时候立即执行，它的响应速度相比setTimeout会更快，因为无需等渲染。<br>而setImmediate和setTimeout属于宏任务，执行开始之前要等渲染，即task-&gt;渲染-&gt;task。<br><a href="https://img2020.cnblogs.com/blog/1207871/202007/1207871-20200708102740351-527702464.png"><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210922003102.png"></a></p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">阮一峰-JavaScript 运行机制详解：再谈Event Loop</a><br><a href="https://segmentfault.com/a/1190000014940904?utm_source=tag-newest">译文：JS事件循环机制（event loop）之宏任务、微任务</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">Generator 函数的含义与用法</a><br><a href="https://juejin.im/post/5dd0d73c6fb9a0203b7fc4a1">浏览器进程、JS事件循环机制、宏任务和微任务</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言#&quot;&gt;&lt;/a&gt;前言&lt;a href=&quot;https://www.cnblogs.com/leiting/p/13174545.html#1525433879&quot;&gt;#&lt;/a&gt;&lt;/h</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue slot的使用</title>
    <link href="https://andylinwenqin.github.io/2021/09/20/Vue-slot%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://andylinwenqin.github.io/2021/09/20/Vue-slot%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-20T12:04:29.000Z</published>
    <updated>2021-09-20T16:37:35.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一次性讲明白vue插槽slot"><a href="#一次性讲明白vue插槽slot" class="headerlink" title="一次性讲明白vue插槽slot"></a>一次性讲明白vue插槽slot</h1><h2 id="vue插槽slot"><a href="#vue插槽slot" class="headerlink" title="vue插槽slot"></a>vue插槽slot</h2><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>vue官方文档中在”组件基础”内容中提到组件可以通过插槽分发内容，那插槽是怎么使用的呢？它要解决什么场景的问题呢？</p><p>我们在构建页面过程中一般会把用的比较多的公共的部分抽取出来作为一个单独的组件，但是在实际使用这个组件的时候却又不能完全的满足需求，我希望在这个组件中添加一点东西，这时候我们就需要用到插槽来分发内容。</p><p>注意：以下的所有内容是基于vue版本 2.6.0 起</p><h3 id="二、插槽是什么"><a href="#二、插槽是什么" class="headerlink" title="二、插槽是什么"></a>二、插槽是什么</h3><p>下面看一个例子</p><p>写一个父组件: test.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;大家好我是父组件&lt;/div&gt;</span><br><span class="line">      &lt;myslot&gt;</span><br><span class="line">        &lt;p&gt;测试一下吧内容写在这里了能否显示&lt;/p&gt;</span><br><span class="line">      &lt;/myslot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>写一个子组件：myslot.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>运行代码，发现，最终渲染的效果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大家好我是父组件</span><br><span class="line">我是子组件</span><br></pre></td></tr></table></figure><p>那如果我想实现显示父组件中p标签的内容怎么办</p><p>修改子组件：myslot.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">      &lt;p&gt;现在测试一下slot&lt;/p&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>运行代码，可以看到以下效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大家好我是父组件</span><br><span class="line">我是子组件</span><br><span class="line">现在测试一下slot</span><br><span class="line">测试一下吧内容写在这里了能否显示</span><br></pre></td></tr></table></figure><p>官方文档对于插槽的应用场景是这样描述的:</p><p>我们经常需要向一个组件传递内容</p><p>Vue 自定义的 <code>&lt;slot&gt;</code> 元素让这变得非常简单</p><p>只要在需要的地方加入插槽就行了——就这么简单！</p><p>结合上面的例子来理解就是这样的：</p><p>1.父组件在引用子组件时希望向子组价传递模板内容<code>&lt;p&gt;测试一下吧内容写在这里了能否显示&lt;/p&gt;</code></p><p>2.子组件让父组件传过来的模板内容在所在的位置显示</p><p>3.子组件中的<code>&lt;slot&gt;</code>就是一个槽，可以接收父组件传过来的模板内容，<code>&lt;slot&gt;</code> 元素自身将被替换</p><p>4.<code>&lt;myslot&gt;&lt;/myslot&gt;</code>组件没有包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃</p><h3 id="二、插槽的作用"><a href="#二、插槽的作用" class="headerlink" title="二、插槽的作用"></a>二、插槽的作用</h3><p>让用户可以拓展组件，去更好地复用组件和对其做定制化处理</p><h3 id="三、插槽的分类"><a href="#三、插槽的分类" class="headerlink" title="三、插槽的分类"></a>三、插槽的分类</h3><h4 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="1.默认插槽"></a>1.默认插槽</h4><p>在一个 <code>&lt;submit-button&gt;</code> 组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;&gt;</span><br><span class="line">  &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”，但是有时候却希望渲染文本为别的东西，那怎么实现呢？</p><p>我们可以将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;&gt;</span><br><span class="line">  &lt;slot&gt;Submit&lt;/slot&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;submit-button&gt;&lt;/submit-button&gt;</span><br></pre></td></tr></table></figure><p>后备内容“Submit”将会被渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>但是如果我们提供内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;submit-button&gt;</span><br><span class="line">  Save</span><br><span class="line">&lt;/submit-button&gt;</span><br></pre></td></tr></table></figure><p>则这个提供的内容将会被渲染从而取代后备内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;&gt;</span><br><span class="line">  Save</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><h4 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2.具名插槽"></a>2.具名插槽</h4><p>有时我们写了一个子组件，我们希望</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;header&gt;</span><br><span class="line">        &lt;!-- 我们希望把页头放这里 --&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;!-- 我们希望把主要内容放这里 --&gt;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">      &lt;footer&gt;</span><br><span class="line">        &lt;!-- 我们希望把页脚放这里 --&gt;</span><br><span class="line">      &lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/main&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p><p>父组件在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;</span><br><span class="line">    &lt;div&gt;大家好我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;template v-slot:header&gt;</span><br><span class="line">      &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template v-slot:footer&gt;</span><br><span class="line">      &lt;p&gt;Here&#x27;s footer info&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最终的渲染结果可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Here might be a page title</span><br><span class="line">大家好我是父组件</span><br><span class="line">A paragraph for the main content.</span><br><span class="line"></span><br><span class="line">And another one.</span><br><span class="line"></span><br><span class="line">Here&#x27;s footer info</span><br></pre></td></tr></table></figure><p>父组件中会向子组件中具名传递对应的模板内容，而没有指定名字的模板内容会传递给子组件中不带 <code>name</code> 的 <code>&lt;slot&gt;</code></p><p>当然，如果父组件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-slot:default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>同样是传递给子组件中不带 <code>name</code> 的 <code>&lt;slot&gt;</code></p><p><strong>注意:</strong></p><p><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</p><p>具名插槽在书写的时候可以使用缩写,<code>v-slot</code>用#来代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;</span><br><span class="line">    &lt;div&gt;大家好我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;template #header&gt;</span><br><span class="line">      &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template #footer&gt;</span><br><span class="line">      &lt;p&gt;Here&#x27;s footer info&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3.作用域插槽"></a>3.作用域插槽</h4><p>这里主要解决的是父组件在向子组件插槽传递模板内容时存在访问子组件数据的问题</p><p>还记得默认插槽吗？如果子组件中写在 <code>&lt;slot&gt;</code> 标签内后备内容是与 该组件的data属性双向数据绑定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;slot&gt;&#123;&#123;user.firstName&#125;&#125;&lt;/slot&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        user:&#123;</span><br><span class="line">          firstName:&#x27;gerace&#x27;,</span><br><span class="line">          lastName:&#x27;haLi&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>父组件在引用子组件时，希望能够换掉备用内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;&#123;&#123; user.firstName &#125;&#125;&lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>运行代码这时你会发现提示报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Property or method &quot;user&quot; is not defined on the instance but referenced during render.</span><br><span class="line">TypeError: Cannot read property &#x27;firstName&#x27; of undefined</span><br></pre></td></tr></table></figure><p>这里为什么？vue官方文档给出了答案</p><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的</p><p>那应该怎么解决这个问题？</p><p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;slot v-bind:user=&quot;user&quot;&gt;</span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;</span><br><span class="line">      &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">      &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>上面例子，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p><p>针对上面只给默认插槽传递模板内容的例子，在写法上可以采用默认插槽的缩写语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">     &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>上面代码也可以直接改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot v-slot=&quot;slotProps&quot;&gt;</span><br><span class="line">     &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot v-slot=&quot;slotProps&quot;&gt;</span><br><span class="line">     &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">     &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt;</span><br><span class="line">   slotProps is NOT available here</span><br><span class="line">     &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>下面再看一下多个插槽的情况</p><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;slot v-bind:userData=&quot;user&quot; name=&quot;header&quot;&gt;</span><br><span class="line">        &#123;&#123; user.msg &#125;&#125;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">      &lt;slot v-bind:hobbyData=&quot;hobby&quot; name=&quot;footer&quot;&gt;</span><br><span class="line">        &#123;&#123; hobby.fruit &#125;&#125;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        user:&#123;</span><br><span class="line">          firstName: &#x27;gerace&#x27;,</span><br><span class="line">          lastName: &#x27;haLi&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        hobby:&#123;</span><br><span class="line">          fruit: &quot;apple&quot;,</span><br><span class="line">          color: &quot;blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;</span><br><span class="line">      &lt;template v-slot:header=&quot;slotProps&quot;&gt;</span><br><span class="line">        &#123;&#123; slotProps.userData.firstName &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:footer=&quot;slotProps&quot;&gt;</span><br><span class="line">        &#123;&#123; slotProps.hobbyData.fruit &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>针对多个插槽的情况，在写法上可以解构插槽prop，父组件的写法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;</span><br><span class="line">      &lt;template v-slot:header=&quot;&#123;userData&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; userData.firstName &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:footer=&quot;&#123;hobbyData&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; hobbyData.fruit &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在具名插槽的介绍部分有讲过，具名插槽可以使用缩写，<code>v-slot</code>可以使用#来代替，所以以上代码可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;</span><br><span class="line">      &lt;template #header=&quot;&#123;userData&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; userData.firstName &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template #footer=&quot;&#123;hobbyData&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; hobbyData.fruit &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myslot from &#x27;./myslot&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      myslot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>但是需要注意的是该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这样会触发警告 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;myslot&gt;</span><br><span class="line">      &lt;template #=&quot;&#123;userData&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; userData.firstName &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template #=&quot;&#123;hobbyData&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; hobbyData.fruit &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">  &lt;/myslot&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一次性讲明白vue插槽slot&quot;&gt;&lt;a href=&quot;#一次性讲明白vue插槽slot&quot; class=&quot;headerlink&quot; title=&quot;一次性讲明白vue插槽slot&quot;&gt;&lt;/a&gt;一次性讲明白vue插槽slot&lt;/h1&gt;&lt;h2 id=&quot;vue插槽slot&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Git拉取远端所有分支</title>
    <link href="https://andylinwenqin.github.io/2021/09/12/Git%E6%8B%89%E5%8F%96%E8%BF%9C%E7%AB%AF%E6%89%80%E6%9C%89%E5%88%86%E6%94%AF/"/>
    <id>https://andylinwenqin.github.io/2021/09/12/Git%E6%8B%89%E5%8F%96%E8%BF%9C%E7%AB%AF%E6%89%80%E6%9C%89%E5%88%86%E6%94%AF/</id>
    <published>2021-09-12T06:15:20.000Z</published>
    <updated>2021-09-20T10:44:56.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h1><p>git clone 默认只克隆github上面设置的默认分支，（如果没有修改，默认就是master分支），那如果需要把所有分支都克隆下来该怎么办呢？</p><p>分析<br>我们最常用的克隆命令应该是这个:<code>git clone &lt;url&gt;</code>；</p><p>按照上面的理解，这个命令其实是下面命令的简写形式：<code>git clone -b master &lt;url&gt;</code>。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>1.克隆仓库到本地，查看本地分支</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912145740.png"></p><p>2.查看远程分支</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912145759.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="对于比较少分支的仓库–方法1"><a href="#对于比较少分支的仓库–方法1" class="headerlink" title="对于比较少分支的仓库–方法1"></a>对于比较少分支的仓库–方法1</h3><p><strong>思路</strong>：先查看远程分支，然后在本地创建和远程仓库同名的分支。</p><p><strong>关键命令</strong>：git branch dev origin/dev，即新建一个本地分支来跟踪远程的某一分支，创建该分支后，远程分支内容已拉取到本地分支。（或者你可以直接用git checkout -b dev origin/dev，创建分支，并切换到该分支）<br><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912150627.png"></p><p><strong>该方法弊端</strong>：因为这方法每次只创建一个分支，如果远程有多个分支，需要多次执行命令，比较麻烦。<br><strong>该方法优点</strong>：（与下面方法进行对比）命令简单易懂。</p><p>如针对这个仓库你需要执行两次类似命令：<br>git branch readme origin/readme<br>git branch dev origin/dev</p><p><strong>流程简单演示</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span>  https://github.com/yansheng836/hello-world.git</span><br><span class="line"><span class="comment"># 要先进入仓库目录</span></span><br><span class="line">$ <span class="built_in">cd</span> hello-world</span><br><span class="line">$ git branch readme origin/readme</span><br></pre></td></tr></table></figure><h3 id="对于比较少分支的仓库–方法2"><a href="#对于比较少分支的仓库–方法2" class="headerlink" title="对于比较少分支的仓库–方法2"></a>对于比较少分支的仓库–方法2</h3><p><strong>思路</strong>：在前面的分析已经提到了git clone url是git clone -b master url的缩写（假设没有在远程仓库修改默认分支），那么我们同样可以使用该命令下载其他分支的内容。</p><p><strong>关键命令</strong>：git clone -b readme url：下载该仓库的readme分支的内容。</p><p><strong>优缺点</strong>：同方法1。<br><strong>流程简单演示</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span>  https://github.com/yansheng836/hello-world.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用先进入仓库目录</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> -b readme https://github.com/yansheng836/hello-world.</span><br></pre></td></tr></table></figure><h3 id="对于比较多分支的仓库"><a href="#对于比较多分支的仓库" class="headerlink" title="对于比较多分支的仓库"></a>对于比较多分支的仓库</h3><p><strong>思路</strong>：了解到了方法1、2的弊端，我们可能就会想到：循环可以执行重复的类似的操作，也许我们可以通过循环解决这个问题！该方法就是循环使用方法1.</p><p><strong>背景说明</strong>：使用类Unix系统的人很自然就想到了使用shell编程，使用Windows系统人都是使用git的客户端的命令行工具，虽然可能种类不一，但是都是基于Linux shell的；因为git就是Linux的创始人：林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds） 开发的（开发git的初衷是因为和之前的版本管理系统的合作伙伴SCM(源码管理工具)闹掰了，这是个有趣的故事，详情可了解：Linux为什么开发Git？）。以此可以说：Linux和Git本是一家，所以Linux 很多命令也可以在git bash中使用；git火起来也正是因为Linus把庞大的 Linux内核代码库 (目前仓库大小为：2.55GB)放到git中进行版本管理（另一个重要原因是因为分布式），以实际行动证明Git完全有能力去管理这种庞大的系统。</p><p><strong>关键命令</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for b in `git branch -r | grep -v -- &#x27;-&gt;&#x27;`; do git branch --track $&#123;b##origin/&#125; $b; done</span><br></pre></td></tr></table></figure><p><strong>该方法弊端</strong>：（相对而言）命令比较复杂。<br><strong>该方法优点</strong>：不管有多少分支都可以自动创建。</p><p>也可以这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r | grep -v &#x27;\-&gt;&#x27; | while read remote; do git branch --track &quot;$&#123;remote#origin/&#125;&quot; &quot;$remote&quot;; done</span><br></pre></td></tr></table></figure><p><strong>流程简单演示</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span>  https://github.com/yansheng836/hello-world.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要先进入仓库目录</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> hello-world</span><br><span class="line">$ <span class="keyword">for</span> b <span class="keyword">in</span> `git branch -r | grep -v -- <span class="string">&#x27;-&gt;&#x27;</span>`; <span class="keyword">do</span> git branch --track <span class="variable">$&#123;b##origin/&#125;</span> <span class="variable">$b</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景说明&quot;&gt;&lt;a href=&quot;#背景说明&quot; class=&quot;headerlink&quot; title=&quot;背景说明&quot;&gt;&lt;/a&gt;背景说明&lt;/h1&gt;&lt;p&gt;git clone 默认只克隆github上面设置的默认分支，（如果没有修改，默认就是master分支），那如果需要把所有分</summary>
      
    
    
    
    
    <category term="git" scheme="https://andylinwenqin.github.io/tags/git/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git复制已有的分支到新分支</title>
    <link href="https://andylinwenqin.github.io/2021/09/12/Git%E5%A4%8D%E5%88%B6%E5%B7%B2%E6%9C%89%E7%9A%84%E5%88%86%E6%94%AF%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF/"/>
    <id>https://andylinwenqin.github.io/2021/09/12/Git%E5%A4%8D%E5%88%B6%E5%B7%B2%E6%9C%89%E7%9A%84%E5%88%86%E6%94%AF%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF/</id>
    <published>2021-09-12T06:10:50.000Z</published>
    <updated>2021-09-12T07:29:36.361Z</updated>
    
    <content type="html"><![CDATA[<p>如果我们需要在现有分支的基础上，复制代码到新分支进行开发，并推送至远程仓库，可以进行如下操作：<br> <strong>注：old-branch为旧分支名，new-branch为新分支名</strong></p><p>1.使用git bash打开命令行界面，使用以下命令检出远程分支。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout -b old-branch origin/old-branch</span><br></pre></td></tr></table></figure><p>2.从当前分支复制出新的分支</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="keyword">new</span>-branch</span><br></pre></td></tr></table></figure><p>3.把新建的分支push到远程库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin <span class="keyword">new</span>-branch:<span class="keyword">new</span>-branch</span><br></pre></td></tr></table></figure><p>4.拉取远程分支</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull <span class="comment"># 经过验证，当前的分支并没有和本地分支关联，根据提示进行下一步</span></span><br></pre></td></tr></table></figure><p>5.关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/<span class="keyword">new</span>-branch <span class="keyword">new</span>-branch</span><br></pre></td></tr></table></figure><p>6.再次拉取，成功</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果我们需要在现有分支的基础上，复制代码到新分支进行开发，并推送至远程仓库，可以进行如下操作：&lt;br&gt; &lt;strong&gt;注：old-branch为旧分支名，new-branch为新分支名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.使用git bash打开命令行界面，使用以下命令检</summary>
      
    
    
    
    
    <category term="git" scheme="https://andylinwenqin.github.io/tags/git/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git删除分支</title>
    <link href="https://andylinwenqin.github.io/2021/09/12/Git%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF/"/>
    <id>https://andylinwenqin.github.io/2021/09/12/Git%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF/</id>
    <published>2021-09-12T06:05:58.000Z</published>
    <updated>2021-09-12T06:10:18.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-删除分支——如何删除本地或远程分支"><a href="#Git-删除分支——如何删除本地或远程分支" class="headerlink" title="Git 删除分支——如何删除本地或远程分支"></a>Git 删除分支——如何删除本地或远程分支</h1><hr><h2 id="为什么要删除-Git-中的分支？"><a href="#为什么要删除-Git-中的分支？" class="headerlink" title="为什么要删除 Git 中的分支？"></a>为什么要删除 Git 中的分支？</h2><p>因此，您已经创建了一个分支来保存要在项目中进行的更改的代码。</p><p>然后，您将该更改或新功能合并到项目的原始版本中。</p><p>这意味着您不再需要保留和使用该分支，因此删除它是一种常见的最佳做法，以免它弄乱您的代码。</p><h2 id="如何在-Git-中删除本地分支"><a href="#如何在-Git-中删除本地分支" class="headerlink" title="如何在 Git 中删除本地分支"></a>如何在 Git 中删除本地分支</h2><p>本地分支是您本地机器上的分支，不会影响任何远程分支。</p><p>在 Git 中删除本地分支的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d  local_branch_name</span><br></pre></td></tr></table></figure><ul><li>git branch 是在本地删除分支的命令。</li><li>-d是一个标志，是命令的一个选项，它是–delete. 顾名思义，它表示您要删除某些内容。-local_branch_name是要删除的分支的名称。</li><li>个别时候-d 需要大写 -D</li></ul><h2 id="如何在-Git-中删除远程分支"><a href="#如何在-Git-中删除远程分支" class="headerlink" title="如何在 Git 中删除远程分支"></a>如何在 Git 中删除远程分支</h2><p>远程分支与本地分支是分开的。</p><p>它们是托管在远程服务器上的存储库，可以在那里访问。这与本地分支相比，本地分支是本地系统上的存储库。</p><p>删除远程分支的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote_name -d remote_branch_name</span><br></pre></td></tr></table></figure><ul><li>git branch您可以使用该命令删除远程分支，而不是使用用于本地分支的git push命令。</li><li>然后您指定遥控器的名称，在大多数情况下是origin.</li><li>-d是删除标志，是–delete.</li><li>remote_branch_name 是要删除的远程分支。</li></ul><p>现在，让我们看一个如何删除远程分支的示例。</p><p>要查看任何远程分支，请使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>该-a标志（一个别名–all）显示所有分支机构-本地和远程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git-删除分支——如何删除本地或远程分支&quot;&gt;&lt;a href=&quot;#Git-删除分支——如何删除本地或远程分支&quot; class=&quot;headerlink&quot; title=&quot;Git 删除分支——如何删除本地或远程分支&quot;&gt;&lt;/a&gt;Git 删除分支——如何删除本地或远程分支&lt;/</summary>
      
    
    
    
    
    <category term="git" scheme="https://andylinwenqin.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="https://andylinwenqin.github.io/2021/09/07/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://andylinwenqin.github.io/2021/09/07/%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2021-09-07T13:15:29.000Z</published>
    <updated>2021-09-12T16:29:44.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端模块化详解-来源-浪里行舟"><a href="#前端模块化详解-来源-浪里行舟" class="headerlink" title="前端模块化详解(来源 浪里行舟)"></a><a href="https://segmentfault.com/a/1190000017466120">前端模块化详解</a>(来源 浪里行舟)</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。<br>本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的CommonJS, AMD, ES6、CMD规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！</p><p><strong>建议下载本文源代码，自己动手敲一遍，请猛戳<a href="https://link.segmentfault.com/?url=https://github.com/ljianshu/Blog">GitHub个人博客</a></strong></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912235124.webp"></p><h2 id="一、模块化的理解"><a href="#一、模块化的理解" class="headerlink" title="一、模块化的理解"></a>一、模块化的理解</h2><h3 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1.什么是模块?"></a>1.什么是模块?</h3><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul><h3 id="2-模块化的进化过程"><a href="#2-模块化的进化过程" class="headerlink" title="2.模块化的进化过程"></a>2.模块化的进化过程</h3><ul><li><strong>全局function模式 : 将不同的功能封装成不同的全局函数</strong><ul><li>编码: 将不同的功能封装成不同的全局函数</li><li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li></ul></li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>namespace模式 : 简单对象封装</strong><ul><li>作用: 减少了全局变量，解决命名冲突</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.data = <span class="string">&#x27;other data&#x27;</span> <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.foo() <span class="comment">// foo() other data</span></span><br></pre></td></tr></table></figure><p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p><ul><li><strong>IIFE模式：匿名函数自调用(闭包)</strong><ul><li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>问题: 如果当前这个模块依赖另一个模块怎么办?</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    myModule.foo()</span></span><br><span class="line"><span class="javascript">    myModule.bar()</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span></span><br><span class="line"><span class="javascript">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span><br><span class="line"><span class="javascript">    myModule.foo() <span class="comment">//没有改变</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>最后得到的结果：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210912235435.webp"></p><ul><li><strong>IIFE模式增强 : 引入依赖</strong></li></ul><p>这就是现代模块实现的基石</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"> <span class="comment">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">   myModule.foo()</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p><h3 id="3-模块化的好处"><a href="#3-模块化的好处" class="headerlink" title="3. 模块化的好处"></a>3. 模块化的好处</h3><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h3 id="4-引入多个-lt-script-gt-后出现出现问题"><a href="#4-引入多个-lt-script-gt-后出现出现问题" class="headerlink" title="4. 引入多个&lt;script&gt;后出现出现问题"></a>4. 引入多个<code>&lt;script&gt;</code>后出现出现问题</h3><ul><li>请求过多</li></ul><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p><ul><li>依赖模糊</li></ul><p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p><ul><li>难以维护</li></ul><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。<br>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。</p><h2 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h2><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h4><ul><li>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li></ul><p>此处我们有个疑问：<strong>CommonJS暴露的模块到底是什么?</strong> CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = function (value) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span>.x = x;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span>.addX = addX;</span><br></pre></td></tr></table></figure><p>上面代码通过module.exports输出变量x和函数addX。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);<span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错</strong>。</p><h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h4><p><strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function">function <span class="title">incCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p><h4 id="5-服务器端实现"><a href="#5-服务器端实现" class="headerlink" title="(5)服务器端实现"></a>(5)服务器端实现</h4><h4 id="①下载安装node-js"><a href="#①下载安装node-js" class="headerlink" title="①下载安装node.js"></a>①下载安装node.js</h4><h4 id="②创建项目结构"><a href="#②创建项目结构" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><p><strong>注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-modules</span></span><br><span class="line">  <span class="string">|-module1.js</span></span><br><span class="line">  <span class="string">|-module2.js</span></span><br><span class="line">  <span class="string">|-module3.js</span></span><br><span class="line"><span class="string">|-app.js</span></span><br><span class="line"><span class="string">|-package.json</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;commonJS-node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="③下载第三方模块"><a href="#③下载第三方模块" class="headerlink" title="③下载第三方模块"></a>③下载第三方模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uniq --save // 用于数组去重</span><br></pre></td></tr></table></figure><h4 id="④定义模块代码"><a href="#④定义模块代码" class="headerlink" title="④定义模块代码"></a>④定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;module1&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;module2&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js</span></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo() module3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="comment">// 引入第三方库，应该放置在最前面</span></span><br><span class="line"><span class="keyword">let</span> uniq = <span class="built_in">require</span>(<span class="string">&#x27;uniq&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module2&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> module3 = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">module1.foo() <span class="comment">//module1</span></span><br><span class="line">module2() <span class="comment">//module2</span></span><br><span class="line">module3.foo() <span class="comment">//foo() module3</span></span><br><span class="line"><span class="built_in">console</span>.log(uniq(module3.arr)) <span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h4 id="⑤通过node运行app-js"><a href="#⑤通过node运行app-js" class="headerlink" title="⑤通过node运行app.js"></a>⑤通过node运行app.js</h4><p>命令行输入<code>node app.js</code>，运行JS文件</p><h4 id="6-浏览器端实现-借助Browserify"><a href="#6-浏览器端实现-借助Browserify" class="headerlink" title="(6)浏览器端实现(借助Browserify)"></a>(6)浏览器端实现(借助Browserify)</h4><h4 id="①创建项目结构"><a href="#①创建项目结构" class="headerlink" title="①创建项目结构"></a>①创建项目结构</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-js</span></span><br><span class="line">  <span class="string">|-dist //打包生成文件的目录</span></span><br><span class="line">  <span class="string">|-src //源码所在的目录</span></span><br><span class="line">    <span class="string">|-module1.js</span></span><br><span class="line">    <span class="string">|-module2.js</span></span><br><span class="line">    <span class="string">|-module3.js</span></span><br><span class="line">    <span class="string">|-app.js //应用主源文件</span></span><br><span class="line"><span class="string">|-index.html //运行于浏览器上</span></span><br><span class="line"><span class="string">|-package.json</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;browserify-test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="②下载browserify"><a href="#②下载browserify" class="headerlink" title="②下载browserify"></a>②下载browserify</h4><ul><li>全局: npm install browserify -g</li><li>局部: npm install browserify –save-dev</li></ul><h4 id="③定义模块代码-同服务器端"><a href="#③定义模块代码-同服务器端" class="headerlink" title="③定义模块代码(同服务器端)"></a>③定义模块代码(同服务器端)</h4><p>注意：<code>index.html</code>文件要运行在浏览器上，需要借助browserify将<code>app.js</code>文件打包编译，如果直接在<code>index.html</code>引入<code>app.js</code>就会报错！</p><h4 id="④打包处理js"><a href="#④打包处理js" class="headerlink" title="④打包处理js"></a>④打包处理js</h4><p>根目录下运行<code>browserify js/src/app.js -o js/dist/bundle.js</code></p><h4 id="⑤页面使用引入"><a href="#⑤页面使用引入" class="headerlink" title="⑤页面使用引入"></a>⑤页面使用引入</h4><p>在index.html文件中引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</strong>。此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p><h4 id="1-AMD规范基本语法"><a href="#1-AMD规范基本语法" class="headerlink" title="(1)AMD规范基本语法"></a>(1)AMD规范基本语法</h4><p><strong>定义暴露模块</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>引入使用模块</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>)</span>&#123;</span><br><span class="line">   使用m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-未使用AMD规范与使用require-js"><a href="#2-未使用AMD规范与使用require-js" class="headerlink" title="(2)未使用AMD规范与使用require.js"></a>(2)未使用AMD规范与使用require.js</h4><p>通过比较两者的实现方法，来说明使用AMD规范的好处。</p><ul><li>未使用AMD规范</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.dataService = &#123;getMsg&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&#x27;, &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.alerter = &#123;showMsg&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, dataService)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">  alerter.showMsg()</span><br><span class="line">&#125;)(alerter)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Modular Demo 1: 未使用AMD(require.js)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/dataService.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/alerter.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>最后得到如下结果：<br><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210913002029.webp"></p><p>这种方式缺点很明显：<strong>首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！</strong></p><ul><li>使用require.js</li></ul><p>RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<strong>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</strong>。<br>接下来介绍AMD规范在浏览器实现的步骤：</p><h4 id="①下载require-js-并引入"><a href="#①下载require-js-并引入" class="headerlink" title="①下载require.js, 并引入"></a>①下载require.js, 并引入</h4><ul><li>官网: <code>http://www.requirejs.cn/</code></li><li>github : <code>https://github.com/requirejs/requirejs</code></li></ul><p>然后将require.js导入项目: js/libs/require.js</p><h4 id="②创建项目结构-1"><a href="#②创建项目结构-1" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-js</span></span><br><span class="line">  <span class="string">|-libs</span></span><br><span class="line">    <span class="string">|-require.js</span></span><br><span class="line">  <span class="string">|-modules</span></span><br><span class="line">    <span class="string">|-alerter.js</span></span><br><span class="line">    <span class="string">|-dataService.js</span></span><br><span class="line">  <span class="string">|-main.js</span></span><br><span class="line"><span class="string">|-index.html</span></span><br></pre></td></tr></table></figure><h4 id="③定义require-js的模块代码"><a href="#③定义require-js的模块代码" class="headerlink" title="③定义require.js的模块代码"></a>③定义require.js的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件 </span></span><br><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125; <span class="comment">// 暴露模块</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alerter.js文件</span></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&#x27;dataService&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&#x27;, &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    <span class="attr">baseUrl</span>: <span class="string">&#x27;js/&#x27;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">      <span class="comment">//映射: 模块标识名: 路径</span></span><br><span class="line">      <span class="attr">alerter</span>: <span class="string">&#x27;./modules/alerter&#x27;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      <span class="attr">dataService</span>: <span class="string">&#x27;./modules/dataService&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;alerter&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Modular Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">&quot;js/main&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="④页面引入require-js模块"><a href="#④页面引入require-js模块" class="headerlink" title="④页面引入require.js模块:"></a>④页面引入require.js模块:</h4><p>在index.html引入 <code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</code></p><p><strong>此外在项目中如何引入第三方库？</strong>只需在上面代码的基础稍作修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">define([<span class="string">&#x27;dataService&#x27;</span>, <span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&#x27;, &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    <span class="attr">baseUrl</span>: <span class="string">&#x27;js/&#x27;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">      <span class="comment">//自定义模块</span></span><br><span class="line">      <span class="attr">alerter</span>: <span class="string">&#x27;./modules/alerter&#x27;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      <span class="attr">dataService</span>: <span class="string">&#x27;./modules/dataService&#x27;</span>,</span><br><span class="line">      <span class="comment">// 第三方库模块</span></span><br><span class="line">      <span class="attr">jquery</span>: <span class="string">&#x27;./libs/jquery-1.10.1&#x27;</span> <span class="comment">//注意：写成jQuery会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;alerter&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。<br><strong>小结</strong>：通过两者的比较，可以得出<strong>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p><h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h4 id="1-CMD规范基本语法"><a href="#1-CMD规范基本语法" class="headerlink" title="(1)CMD规范基本语法"></a>(1)CMD规范基本语法</h4><p><strong>定义暴露模块：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">  <span class="built_in">module</span>.exports = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">&#x27;./module3&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>引入使用模块：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-sea-js简单使用教程"><a href="#2-sea-js简单使用教程" class="headerlink" title="(2)sea.js简单使用教程"></a>(2)sea.js简单使用教程</h4><h4 id="①下载sea-js-并引入"><a href="#①下载sea-js-并引入" class="headerlink" title="①下载sea.js, 并引入"></a>①下载sea.js, 并引入</h4><ul><li>官网: <a href="https://link.segmentfault.com/?url=http://seajs.org/">http://seajs.org/</a></li><li>github : <a href="https://link.segmentfault.com/?url=https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li></ul><p>然后将sea.js导入项目: js/libs/sea.js</p><h4 id="②创建项目结构-2"><a href="#②创建项目结构-2" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-js</span></span><br><span class="line">  <span class="string">|-libs</span></span><br><span class="line">    <span class="string">|-sea.js</span></span><br><span class="line">  <span class="string">|-modules</span></span><br><span class="line">    <span class="string">|-module1.js</span></span><br><span class="line">    <span class="string">|-module2.js</span></span><br><span class="line">    <span class="string">|-module3.js</span></span><br><span class="line">    <span class="string">|-module4.js</span></span><br><span class="line">    <span class="string">|-main.js</span></span><br><span class="line"><span class="string">|-index.html</span></span><br></pre></td></tr></table></figure><h4 id="③定义sea-js的模块代码"><a href="#③定义sea-js的模块代码" class="headerlink" title="③定义sea.js的模块代码"></a>③定义sea.js的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//内部变量数据</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&#x27;atguigu.com&#x27;</span></span><br><span class="line">  <span class="comment">//内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;module1 show() &#x27;</span> + data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露</span></span><br><span class="line">  <span class="built_in">exports</span>.show = show</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module2.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;I Will Back&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module3.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">&#x27;abc123&#x27;</span></span><br><span class="line">  <span class="built_in">exports</span>.API_KEY = API_KEY</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module4.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;module4 show() &#x27;</span> + module2.msg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.show = show</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&#x27;./module3&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;异步引入依赖模块3  &#x27;</span> + m3.API_KEY)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="④在index-html中引入"><a href="#④在index-html中引入" class="headerlink" title="④在index.html中引入"></a>④在index.html中引入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&#x27;./js/modules/main&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后得到结果如下：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210913002422.webp"></p><h3 id="4-ES6模块化"><a href="#4-ES6模块化" class="headerlink" title="4.ES6模块化"></a>4.ES6模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><h4 id="1-ES6模块化语法"><a href="#1-ES6模块化语法" class="headerlink" title="(1)ES6模块化语法"></a>(1)ES6模块化语法</h4><p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">add</span> = function (a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, <span class="keyword">add</span> &#125;;</span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line">import &#123; basicNum, <span class="keyword">add</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function">function <span class="title">test</span>(<span class="params">ele</span>)</span> &#123;</span><br><span class="line">    ele.textContent = <span class="keyword">add</span>(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><p>模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p><h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(2)ES6 模块与 CommonJS 模块的差异"></a>(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：</p><p><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。</p><p><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。</p><p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p><h4 id="3-ES6-Babel-Browserify使用教程"><a href="#3-ES6-Babel-Browserify使用教程" class="headerlink" title="(3) ES6-Babel-Browserify使用教程"></a>(3) ES6-Babel-Browserify使用教程</h4><p>简单来说就一句话：<strong>使用Babel将ES6编译为ES5代码，使用Browserify编译打包js</strong>。</p><h4 id="①定义package-json文件"><a href="#①定义package-json文件" class="headerlink" title="①定义package.json文件"></a>①定义package.json文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;es6-babel-browserify&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②安装babel-cli-babel-preset-es2015和browserify"><a href="#②安装babel-cli-babel-preset-es2015和browserify" class="headerlink" title="②安装babel-cli, babel-preset-es2015和browserify"></a>②安装babel-cli, babel-preset-es2015和browserify</h4><ul><li><p>npm install babel-cli browserify -g</p></li><li><p>npm install babel-preset-es2015 –save-dev</p></li><li><p>preset 预设(将es6转换成es5的所有插件打包)</p></li></ul><h4 id="③定义-babelrc文件"><a href="#③定义-babelrc文件" class="headerlink" title="③定义.babelrc文件"></a>③定义.babelrc文件</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④定义模块代码-1"><a href="#④定义模块代码-1" class="headerlink" title="④定义模块代码"></a>④定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js文件</span></span><br><span class="line"><span class="comment">// 分别暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo() module1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar() module1&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js文件</span></span><br><span class="line"><span class="comment">// 统一暴露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fun1() module2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fun2() module2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; fun1, fun2 &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js文件</span></span><br><span class="line"><span class="comment">// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;默认暴露&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./module1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; fun1, fun2 &#125; <span class="keyword">from</span> <span class="string">&#x27;./module2&#x27;</span></span><br><span class="line"><span class="keyword">import</span> module3 <span class="keyword">from</span> <span class="string">&#x27;./module3&#x27;</span></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br><span class="line">module3()</span><br></pre></td></tr></table></figure><h4 id="⑤-编译并在index-html中引入"><a href="#⑤-编译并在index-html中引入" class="headerlink" title="⑤ 编译并在index.html中引入"></a>⑤ 编译并在index.html中引入</h4><ul><li>使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : <code>babel js/src -d js/lib</code></li><li>使用Browserify编译js : <code>browserify js/lib/app.js -o js/lib/bundle.js</code></li></ul><p>然后在index.html文件中引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/lib/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后得到如下结果：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210913002613.webp"></p><p><strong>此外第三方库(以jQuery为例)如何引入呢</strong>？<br>首先安装依赖<code>npm install jquery@1</code><br>然后在app.js文件中引入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js文件</span></span><br><span class="line">import &#123; foo, bar &#125; from <span class="string">&#x27;./module1&#x27;</span></span><br><span class="line">import &#123; fun1, fun2 &#125; from <span class="string">&#x27;./module2&#x27;</span></span><br><span class="line">import module3 from <span class="string">&#x27;./module3&#x27;</span></span><br><span class="line">import $ from <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">module3</span><span class="params">()</span></span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>)<span class="selector-class">.css</span>(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>花了很长时间(&gt;10h)终于把”JS模块化”讲清楚，自己对模块化的认识又加深了一步，事实上，理解一件事并不难，难的是如何将一件事通俗分享给别人，并让别人也有所收获，一直以来我也是这样要求自己！文章如有错误和不正之处，欢迎指正和批评，同时也希望大家多多支持，我会有更大的创作动力!</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>即使走在前人的肩膀上学习这些内容也是非常的有深度，需要多次学习巩固知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端模块化详解-来源-浪里行舟&quot;&gt;&lt;a href=&quot;#前端模块化详解-来源-浪里行舟&quot; class=&quot;headerlink&quot; title=&quot;前端模块化详解(来源 浪里行舟)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://segmentfault.com/a/1190</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="NodeJS" scheme="https://andylinwenqin.github.io/tags/NodeJS/"/>
    
    <category term="模块化" scheme="https://andylinwenqin.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>webpack（未完成）</title>
    <link href="https://andylinwenqin.github.io/2021/09/07/webpack/"/>
    <id>https://andylinwenqin.github.io/2021/09/07/webpack/</id>
    <published>2021-09-07T13:15:02.000Z</published>
    <updated>2021-09-20T12:02:29.639Z</updated>
    
    <content type="html"><![CDATA[<p>了解太浅薄后期补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;了解太浅薄后期补充&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工程化" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Vue点击触发事件和组件传值(实例)</title>
    <link href="https://andylinwenqin.github.io/2021/09/07/Vue%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC-%E5%AE%9E%E4%BE%8B/"/>
    <id>https://andylinwenqin.github.io/2021/09/07/Vue%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC-%E5%AE%9E%E4%BE%8B/</id>
    <published>2021-09-07T02:40:37.000Z</published>
    <updated>2021-09-12T12:23:33.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-组件间传值及事件触发"><a href="#Vue-组件间传值及事件触发" class="headerlink" title="Vue 组件间传值及事件触发"></a>Vue 组件间传值及事件触发</h1><hr><p><strong>父组件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Counter v-bind:numb=&quot;num&quot; v-on:incre=&quot;parIncrement&quot; v-on:decre=&quot;parDecrement&quot;&gt;&lt;/Counter&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Counter from &#x27;./Counter&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">      name: &#x27;&#x27;,</span><br><span class="line">      data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          num: 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components:&#123;</span><br><span class="line">        Counter</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        parIncrement(e)&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        parDecrement()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>1.声明子组件Counter并用v-bind绑定numb，numb是向子组件传值字段；<br>2.用v-on来绑定incre和decre自定义事件，为子组件做回调触发；<br>3.在子组件回调事件parIncrement（e）中，e是可以接收子组件回传值（如果接收对象，必须将json格式字符串转成对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="built_in">JSON</span>.parse(userfoString)；</span><br></pre></td></tr></table></figure><p>）；</p><p><strong>子组件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    props: [&quot;numb&quot;],</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      increment()&#123;</span><br><span class="line">        this.$emit(&quot;incre&quot;,&quot;1&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      decrement()&#123;</span><br><span class="line">        this.$emit(&quot;decre&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>1.通过props数组形式接收父组件传递numb值；<br>2.通过$emit方法触发父组件方法，做回调操作；<br>3.还是通过$emit方法可以向父组件传递“1”值（如果传递对象，需要先转化成json格式字符串：<br>var users = {name: “my”}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = &#123;<span class="attr">name</span>: <span class="string">&quot;my&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&quot;incre&quot;</span>,<span class="built_in">JSON</span>.stringify(users));</span><br></pre></td></tr></table></figure><p>）；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-组件间传值及事件触发&quot;&gt;&lt;a href=&quot;#Vue-组件间传值及事件触发&quot; class=&quot;headerlink&quot; title=&quot;Vue 组件间传值及事件触发&quot;&gt;&lt;/a&gt;Vue 组件间传值及事件触发&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;父组件&lt;/stro</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝</title>
    <link href="https://andylinwenqin.github.io/2021/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://andylinwenqin.github.io/2021/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-09-05T15:50:57.000Z</published>
    <updated>2021-09-05T16:18:23.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js深拷贝的三种实现方式"><a href="#js深拷贝的三种实现方式" class="headerlink" title="js深拷贝的三种实现方式"></a><strong>js深拷贝的三种实现方式</strong></h1><h2 id="1-使用递归的方式实现深拷贝"><a href="#1-使用递归的方式实现深拷贝" class="headerlink" title="1. 使用递归的方式实现深拷贝"></a><strong>1. 使用递归的方式实现深拷贝</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归的方式实现数组、对象的深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone1</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝</span></span><br><span class="line">  <span class="keyword">var</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">//进行深拷贝的不能为空，并且是对象或者是</span></span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">          objClone[key] = deepClone1(obj[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          objClone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-通过-JSON-对象实现深拷贝"><a href="#2-通过-JSON-对象实现深拷贝" class="headerlink" title="2. 通过 JSON 对象实现深拷贝"></a><strong>2. 通过 JSON 对象实现深拷贝</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过js的内置对象JSON来进行数组对象的深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone2</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">    objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON对象实现深拷贝的一些问题 </span></span><br><span class="line"><span class="comment">//无法实现对对象中方法的深拷贝</span></span><br></pre></td></tr></table></figure><h2 id="3-通过jQuery的extend方法实现深拷贝"><a href="#3-通过jQuery的extend方法实现深拷贝" class="headerlink" title="3. 通过jQuery的extend方法实现深拷贝"></a><strong>3. 通过jQuery的extend方法实现深拷贝</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> newArray = $.extend(<span class="literal">true</span>,[],array);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js深拷贝的三种实现方式&quot;&gt;&lt;a href=&quot;#js深拷贝的三种实现方式&quot; class=&quot;headerlink&quot; title=&quot;js深拷贝的三种实现方式&quot;&gt;&lt;/a&gt;&lt;strong&gt;js深拷贝的三种实现方式&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-使用递归的方</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://andylinwenqin.github.io/tags/JS/"/>
    
    <category term="基础算法" scheme="https://andylinwenqin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>安全知识总结</title>
    <link href="https://andylinwenqin.github.io/2021/09/05/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://andylinwenqin.github.io/2021/09/05/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-05T15:46:52.000Z</published>
    <updated>2021-09-05T16:18:23.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CIA三元组"><a href="#CIA三元组" class="headerlink" title="CIA三元组"></a>CIA三元组</h2><p>(1). 机密性;<br>(2). 完整性;<br>(3). 可用性;</p><h2 id="XSS攻击是如何产生的"><a href="#XSS攻击是如何产生的" class="headerlink" title="XSS攻击是如何产生的"></a>XSS攻击是如何产生的</h2><p>黑客在你的浏览器中插入一段恶意的JavaScript脚本，窃取你的隐私信息，冒充你的身份进行操作，这就是XSS(Cross-Site Scripting, 跨站攻击)</p><p>因为浏览器无法区分脚本是恶意注入的还是正常的内容，它都会执行</p><h2 id="XSS有哪几种类型"><a href="#XSS有哪几种类型" class="headerlink" title="XSS有哪几种类型"></a>XSS有哪几种类型</h2><h3 id="1-反射型XSS-非持久型"><a href="#1-反射型XSS-非持久型" class="headerlink" title="(1). 反射型XSS(非持久型);"></a>(1). 反射型XSS(非持久型);</h3><p>顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。</p><h3 id="2-基于DOM的XSS"><a href="#2-基于DOM的XSS" class="headerlink" title="(2). 基于DOM的XSS;"></a>(2). 基于DOM的XSS;</h3><p>目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。</p><h3 id="3-存储型XSS-持久型"><a href="#3-存储型XSS-持久型" class="headerlink" title="(3). 存储型XSS(持久型);"></a>(3). 存储型XSS(持久型);</h3><p>又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>反射型的 XSS 的恶意脚本存在 URL 里，存储型 XSS 的恶意代码存在数据库里。</p><p>而基于DOM型的XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，其他两种 XSS 都属于服务端的安全漏洞。</p><h3 id="如何防护"><a href="#如何防护" class="headerlink" title="如何防护"></a>如何防护</h3><p>(1). 一切用户输入皆不可信: 在输出时进行验证;<br>(2). 将HTML元素内容，属性以及URL请求参数，CSS值进行编码;<br>(3). 当编码影响业务时，使用白名单规则进行检测和过滤;<br>(4). 使用W3C提出的CSP(Content Security Policy, 内容安全策略),定义域名白名单;<br>(5). 设置Cookie的HTTpOnly属性;</p><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>CSRF 英文全称是 Cross-site request forgery，又称为“跨站请求伪造”。<br>顾名思义，CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求。<br>降维解释：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。<br>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证， 达到冒充用户对被攻击的网站执行某项操作的目的。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>(1). 最容易实现的是Get请求，一般进入黑客网站后，可以通过设置img的src属性来自动发起请求<br>(2). 在黑客网站中，构造隐藏表单来自动发起post请求<br>(3). 通过引诱链接诱惑用户点击触发请求，利用a标签的href</p><h3 id="与XSS区别"><a href="#与XSS区别" class="headerlink" title="与XSS区别"></a>与XSS区别</h3><p>CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击</p><p>CSRF 攻击成本也比 XSS 低，用户每天都要访问大量网页，无法确认每一个网页的合法性， 从用户角度来说，无法彻底防止 CSRF 攻击。</p><h3 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h3><p>针对实际情况，设置关键 Cookie 的 SameSite 属性为 Strict 或 Lax服务端验证请求来源站点(Referer、Origin)使用 CSRF Token，服务端随机生成返回给浏览器的 Token，每一次请求都会携带不同的 CSRF Token加入二次验证(独立的支付密码)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CIA三元组&quot;&gt;&lt;a href=&quot;#CIA三元组&quot; class=&quot;headerlink&quot; title=&quot;CIA三元组&quot;&gt;&lt;/a&gt;CIA三元组&lt;/h2&gt;&lt;p&gt;(1). 机密性;&lt;br&gt;(2). 完整性;&lt;br&gt;(3). 可用性;&lt;/p&gt;
&lt;h2 id=&quot;XSS攻击是</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="协议" scheme="https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="安全" scheme="https://andylinwenqin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络知识总结</title>
    <link href="https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://andylinwenqin.github.io/2021/09/05/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-05T14:32:36.000Z</published>
    <updated>2021-09-05T16:18:23.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位</p><p>线程: 是进程的一部分，一个没有线程的进程可以被看作是单线程的，线程有时又被称为轻权进程或轻量级进程，也是CPU调度的一个基本单位</p><p>区别: </p><p>(1). 进程是资源分配的最小单位，线程是程序执行的最小单位(资源调度的最小单位);</p><p>(2). 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段，这种操作非常昂贵，而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多;</p><p>(3). 线程之间的通信更方便，同一进程下的线程恭喜全局变量，静态变量等数据，而进程之间的通信要以通信的方式(IPC)进行;</p><p>(4). 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间;</p><h2 id="session-cookie-sessionsotrage-localstorage"><a href="#session-cookie-sessionsotrage-localstorage" class="headerlink" title="session, cookie, sessionsotrage, localstorage"></a>session, cookie, sessionsotrage, localstorage</h2><p>cookie中domain属性<br>为了保证安全性，cookie无法设置除当前域名或者其父域名之外的其他domain。<br>在此，分为两种情况：<br>1.一种是前端范围内的是指cookie，如果网站的域名为，i.xiaohan.com,那么前端cookie的domain只能设置，i.xiaohan.com和其父域名xiaohan.com，如果设置成同级域名如api.xiaohan.com或者子域名api.i.xiaohan.com 那么cookie设置将无效。<br>2.同样在服务端上，如果制定你的server服务的域名为server.xiaohan.com那么在服务端生成的cookie的domain只能指定为server.xiaohan.com或者xiaohan.com 其他domain都无法成功设置cookie。</p><p>(1). cookie和session的区别</p><p>1.cookie数据存放在客户端，session数据存放在服务器端;</p><p>2.cookie安全性一般，他人可以通过分析存放在本地的cookie并进行cookie欺骗，在安全性第一的前提下，选择session更优，重要交互信息比如权限等就要放在session中，一般的信息记录放在cookie中;</p><p>3.单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie而session原则上没有限制;</p><p>4.session会在一定的时间内保存在服务器上，当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie</p><p>5.session运行以来Session ID,而Session ID是存在Cookie中，也就是说，如果浏览器禁用了Cookie，Session也会失效(但是可以通过其他方式实现，比如在url中传递Session ID，也就是地址重写)</p><p>(2). localStorage和sessionStorage的区别</p><p>localStorage和sessionStorage存储数据大小一般为5MB,并且仅在客户端(即浏览器)中保存，不参与和服务器的通信</p><p>其实，localStorage最大容量5M的意思是每一个域名下的localStorage容量是5M，假如现在a.com域名下localstorage存不下了，我们可以使用iframe创建b.com域框架（子页面）用于存储a.com剩下的数据。然后使用postMessage读写数据。</p><p>localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除</p><p>set-cookie: 开始状态管理所使用的Cookie信息    响应首部字段<br>Cookie  服务器接收到的 Cookie 信息   请求首部字段</p><p>cookie属性</p><pre><code>name: cookie名称value: cookie值domain: 即可访问此cookie的域名(不同级有不同限制)path: 可访问此cookie的页面路径expires/Max-Age: cookie超时时间, 默认为SessionSize: cookie大小http: 即httponly属性, true时只有http请求头会带有此信息, 而不能通过document.cookie来访问, 加以限制，使 Cookie 不能被 JavaScript 脚本访问secure: 设置是否只可通过https来传递此条cookie</code></pre><p>怎么避免localstorage存满了怎么办</p><p>(1). 划分域名。各域名下的存储空间由各业务组统一规划使用</p><p>(2). 跨页面传数据：考虑单页应用、优先采用 url 传数据</p><p>(3). 最后的兜底方案：清掉别人的存储</p><p>给每个文件设置时间，当存满后，对localstorage里面的文件进行排序，删除时间最久的插入最新的</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p><strong>指一个域下的文档或脚本试图去请求另一个域下的资源，由于浏览器同源策略限制而产生</strong></p><p><strong>同源策略: 协议+域名+端口三者相同且必须相同</strong></p><h3 id="1-JSONP实现跨域"><a href="#1-JSONP实现跨域" class="headerlink" title="(1). JSONP实现跨域"></a>(1). JSONP实现跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;http://example.com/jsonp/getSomething?uid=123&amp;callback=hadleResponse&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br><span class="line"><span class="comment">/*handleResponse(&#123;&quot;data&quot;: &quot;hey&quot;&#125;)*/</span></span><br></pre></td></tr></table></figure><p>动态添加<code>script</code>的标签，可控的去请求远端js并执行，这种跨域方式只能进行GET请求</p><p>当我们通过新建一个script标签请求时，后台会根据相应的参数来生成相应的JSON数据。比如说上面这个链接，传递了handleResponse给后台，然后后台根据这个参数再结合数据生成了handleResponse({“data”: “hey”})。</p><p>紧接着，这个返回的JSON数据其实就可以被当成一个js脚本，就是对一个函数的调用。<br>由于我们事先已经声明了这么一个回调函数，于是当资源加载进来的时候，直接就对函数进行调用，于是数据当然就能获取到了。</p><h3 id="2-CORS跨域"><a href="#2-CORS跨域" class="headerlink" title="(2). CORS跨域"></a>(2). CORS跨域</h3><pre><code>只要同时满足以下两大条件，就属于简单请求。</code></pre><p>（1) 请求方法是以下三种方法之一：</p><p><strong>HEAD GET POST</strong></p><p>（2）HTTP的头信息不超出以下几种字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><h4 id="a-Access-Control-Allow-Origin"><a href="#a-Access-Control-Allow-Origin" class="headerlink" title="a. Access-Control-Allow-Origin"></a>a. Access-Control-Allow-Origin</h4><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><h4 id="b-Access-Control-Allow-Credentials"><a href="#b-Access-Control-Allow-Credentials" class="headerlink" title="b. Access-Control-Allow-Credentials"></a>b. Access-Control-Allow-Credentials</h4><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性</p><h4 id="c-Access-Control-Expose-Headers"><a href="#c-Access-Control-Expose-Headers" class="headerlink" title="c. Access-Control-Expose-Headers"></a>c. Access-Control-Expose-Headers</h4><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><p>总的来说，CORS实现跨域的方法就是根据请求头的Origin值和响应头的Access-Control-Request-Headers和Access-Control-Request-Method的值进行比对，通过了就可以请求成功，没通过就请求失败。</p><h3 id="3-Nginx反向代理接口跨域"><a href="#3-Nginx反向代理接口跨域" class="headerlink" title="(3). Nginx反向代理接口跨域"></a>(3). Nginx反向代理接口跨域</h3><p>实现思路：通过Nginx配置一个代理服务器（域名与example1相同，端口不同）做跳板机，反向代理访问example2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h2 id="用户输入url到页面展示的流程"><a href="#用户输入url到页面展示的流程" class="headerlink" title="用户输入url到页面展示的流程"></a>用户输入url到页面展示的流程</h2><p>(1). 输入地址: 浏览器会自动在书签和浏览历史中搜寻，如果匹配则自动补全，在chrome中如果地址命中了缓存，会直接调用缓存展示页面;</p><p>(2). 浏览器查询域名的IP地址(发送请求至DNS服务器): 浏览器会在本地寻找是否有匹配的映射，如果有直接使用映射的IP地址，如果没有，浏览器会发送DNS请求DNS服务器，DNS服务器的作用在于根据请求中的域名返回与之对应IP地址;</p><p>DNS查找顺序: 浏览器缓存–&gt; 操作系统缓存–&gt; 本地host文件 –&gt; 路由器缓存–&gt; ISP DNS缓存 –&gt; 顶级DNS服务器/根DNS服务器</p><p>本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问</p><p>(3). 浏览器获取IP地址请求TCP/IP连接，客户端和服务器之间进行三次握手的链接，随后发送HTTP请求:</p><p>浏览器获取IP地址后会使用一个随机端口发送TCP连接请求，经过层层路由设备进入服务端，建立TCP/IP连接，随后浏览器会发送一个http请求;</p><p>(4). 服务器解析TCP连接解析HTTP请求;</p><p>(5). 服务器返回一个http响应: http响应由三个部分构成: 状态行，响应头，响应正文;</p><p>(6). 浏览器解析html: 构建dom树 =&gt; 构建render树 =&gt; 布局render树 =&gt; 绘制render树;</p><p>(7). 浏览器解析外联js css: 在解析html的过程中如果碰到外联的js脚本,会中断html的解析,等待js脚本下载解析完成后再恢复html的解析流程,构建完dom树,dom样式树,执行脚本后,页面就正确的展示出来了 </p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说同一时间内只能做一件事情，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。这就涉及到事件循环的问题</p><p>(8). 连接结束四次挥手</p><h2 id="OSI网络分层模型，五层协议，-TCP-IP网络分层模型"><a href="#OSI网络分层模型，五层协议，-TCP-IP网络分层模型" class="headerlink" title="OSI网络分层模型，五层协议， TCP/IP网络分层模型"></a>OSI网络分层模型，五层协议， TCP/IP网络分层模型</h2><h3 id="OSI网络分层模型"><a href="#OSI网络分层模型" class="headerlink" title="OSI网络分层模型"></a>OSI网络分层模型</h3><p>(1). 应用层: 文件传输，常用协议http, snmp, ftp; 报文</p><p>(2). 表示层: 数据格式化，代码转换，数据加密;</p><p>(3). 会话层: 建立，解除会话; </p><p>(4). 传输层: 提供端对端的接口， tcp，udp; 报文段/用户数据报</p><p>(5). 网络层: 为数据包选择路由， ip, icmp; 数据报</p><p>(6). 数据链路层: 传输有地址的帧; （Ethernet, FDDI）帧</p><p>(7). 物理层: 二进制的数据形式在物理媒体上传输数据; 比特</p><h3 id="五层"><a href="#五层" class="headerlink" title="五层:"></a>五层:</h3><p>(1). 物理层<br>(2). 数据链路层<br>(3). 网络层<br>(4). 运输层<br>(5). 应用层</p><h3 id="TCP-IP网络分层模型"><a href="#TCP-IP网络分层模型" class="headerlink" title="TCP/IP网络分层模型"></a>TCP/IP网络分层模型</h3><p>(1). 网络接口层<br>(2). 网际层IP<br>(3). 运输层(TCP或UDP)<br>(4). 应用层(Telnet, FTP, SMTP)</p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>(1). UDP: 无连接; 面向报文，只是报文的搬运工; 不可靠，没有拥塞控制; 高效，头部开销只有8字节; 支持一对一，一对多，多对多，多对一; 适合直播，视频，语音，会议等实时性要求高的</p><p>(2). TCP: 面向连接: 传输前需要先连接; 可靠的传输; 流量控制: 发送方不会发送速度过快，超过接收方的处理能力; 拥塞控制: 当网络负载过多时能限制发送方的发送速率; 不能提供延时保障; 不提供最小带宽保障</p><h3 id="TCP协议保证可靠传输的手段"><a href="#TCP协议保证可靠传输的手段" class="headerlink" title="TCP协议保证可靠传输的手段"></a>TCP协议保证可靠传输的手段</h3><p>(1). 应用数据块分割成TCP认为合适发送的数据块;<br>(2). TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层;<br>(3). 校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。TCP的接收端会丢弃重复的数据.;<br>(4). TCP 的接收端会丢弃重复的数据。;<br>(5). 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）;<br>(6). 当网络拥塞时，减少数据的发送。;<br>(7). ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。;<br>(8). 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 </p><h3 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因:"></a>三次握手的原因:</h3><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p><p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p><p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p><p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放</p><p>四次挥手的原因: TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送，之后就会中断这次TCP连接。</p><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p> HTTP是一个在计算机世界里专门在两点之间传输文字，图片，音频等超文本数据的约定和规范</p><h2 id="常见HTTP请求方法"><a href="#常见HTTP请求方法" class="headerlink" title="常见HTTP请求方法"></a>常见HTTP请求方法</h2><p> 在HTTP1.0中有三种方法分别是<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>GET</code>是从指定资源中请求数据，<code>POST</code>向指定的资源提交要被处理的数据，<code>HEAD</code>类似于<code>GET</code>请求但不返回具体内容，只有头部，可检查超链接的有效性和检查网页是否被修改</p><p>HTTP1.1中加入了<code>PUT</code>替换或创建指定资源，<code>DELETE</code>对指定资源进行删除</p><p>HTTP1.1在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content)</p><p>HTTP2.0中加入了<code>OPTION</code>用于获取目的资源所支持的通信选项，比如服务器支持的请求方式, <code>TRACE</code>: 实现沿通向目标资源的路径的消息环回(loop-back)测试，提供一种实用的debug机制，<code>connect</code>为代理服务器准备的</p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a><code>GET</code>和<code>POST</code>的区别</h2><p>(1). get参数通过url传递，post放在request body中；</p><p>(2). get请求在url中传递的参数是有长度限制的，而post没有；</p><p>(3). get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息；</p><p>(4). get只能进行url编码，而post支持多种编码方式</p><h2 id="HTTP2-0与HTTP1-1区别"><a href="#HTTP2-0与HTTP1-1区别" class="headerlink" title="HTTP2.0与HTTP1.1区别"></a>HTTP2.0与HTTP1.1区别</h2><p>(1). HTTP2.0允许多路复用 (通过二进制分帧层实现);</p><p>(2). 首部压缩，在HTTP1中HTTP请求和响应都是由状态行，请求/响应头部，消息主题三部分组成;</p><p>(3). 设置请求的优先级，可以设置让某些重要的数据优先被服务器处理并返回。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="(1). 对称加密"></a>(1). 对称加密</h4><p>对称加密就是通信的双方都持有同一个密钥，加密和解密都是使用这一个密钥进行的</p><p>优点: 加密和解密的速度快，不会造成性能上太大的损失，尤其是在加密大量数据的情况下</p><p>缺点: 商定加密规则的时候不安全</p><h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="(2). 非对称加密"></a>(2). 非对称加密</h4><p>非对称加密存在两个密钥，一个称为公钥一个称为私钥，既可以使用公钥加密，也可以使用私钥加密，但是使用公钥加密那么就只有私钥才能解密，使用私钥加密就只能使用公钥解密</p><p>优点: 公钥是任何人都可以获取的，经过公钥加密的内容，只有私钥才可以解开</p><p>缺点: 必须保证私钥不能泄露，否则将无加密可言; 非对称加密相对于对称加密而言性能损耗较大，非对称加密还有一个最大的漏洞，中间人攻击</p><p>https = http + tls/ssl</p><h3 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h3><p>(1). 客户端发送’client hello’ 包含密码信息和随机字符串’client random’等;<br>(2). 服务器响应’server hello’包含密码组合和数字证书以及随机字符串’server random等’;<br>(3). 客户端验证数字证书并从证书种获取公钥，生成下一个随机字符串’premaster secret’并用公钥将其加密;<br>(4). 客户端发送加密后的premaster secret给服务器;<br>(5). 服务器使用私钥解密获取premaster secret;<br>(6). 客户端和服务器双方使用相同的算法，并使用client random, server random和premaster secret生产相同的密钥key，用于后面的对称加密;<br>(7). 客户端发送finished;<br>(8). 服务器发送finished;;<br>(9). 成功简历安全连接，双方使用共同的密钥key对称加密进行安全通信;</p><p>使用数字签名，我们能够鉴别信息的发送者，(私钥加密签名)</p><h2 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h2><p>(1). HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费;</p><p>(2). HTTP协议运行在TCP之上，所有的传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都是经过加密的;</p><p>(3). HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不太一样，前者是80，后者是443;</p><p>(4). HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题;</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>解析顺序首先从浏览器缓存，操作系统缓存和本地DNS缓存逐级查找，然后从本地DNS服务器，根DNS，顶级DNS以及权威DNS层层递归查询</p><p>不过传统的 DNS 有很多问题(解析慢、更新不及时)，HTTPDNS 通过客户端 SDK 和服务端配合，直接通过 HTTP 调用解析 DNS 的方式，可以绕过传统 DNS 这些缺点，实现智能调度。</p><h3 id="DNS查询的两种方式"><a href="#DNS查询的两种方式" class="headerlink" title="DNS查询的两种方式"></a>DNS查询的两种方式</h3><h4 id="1-递归解析"><a href="#1-递归解析" class="headerlink" title="(1). 递归解析;"></a>(1). 递归解析;</h4><p>局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端</p><h4 id="2-迭代解析"><a href="#2-迭代解析" class="headerlink" title="(2). 迭代解析;"></a>(2). 迭代解析;</h4><p>局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>浏览器缓存是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者子啊次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览</p><h3 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h3><p>浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；</p><p>下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；</p><p>服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；</p><p>如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>通常浏览器缓存策略分为两种：强缓存（Expires，cache-control）和协商缓存（Last-modified ，Etag），并且缓存策略都是通过设置 HTTP Header 来实现的。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强制缓存。</p><p>Cache-Control<br>当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Expires和Cache-Control的区别<br>Expires 是http1.0的产物，Cache-Control是http1.1的产物</p><p>两者同时存在的话，Cache-Control优先级高于Expires；</p><p>在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法</p><p>Expires是一个具体的服务器时间，这就导致一个问题，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control是一个时间段，控制就比较容易</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>ETag和If-None-Match</p><p>这两个要一起说。Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存</p><p>Last-Modified和If-Modified-Since</p><p>这两个也要一起说。Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。</p><p>ETag和Last-Modified区别</p><p>在方式上，Etag是对资源的一种唯一标识，而Last-Modified是该资源文件最后一次更改时间</p><p>在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p><p>在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p><p>在优先级上，服务器校验优先考虑Etag。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h3 id="1-1xx-Informational-收到请求，正在处理"><a href="#1-1xx-Informational-收到请求，正在处理" class="headerlink" title="(1). 1xx (Informational): 收到请求，正在处理"></a>(1). 1xx (Informational): 收到请求，正在处理</h3><p>100 (继续): 请求者应当继续提出请求，服务器返回此代码表示已经收到请求的第一部分，正在等待其余部分;</p><p>101 (切换协议): 请求者已要求服务器切换协议，服务器确认并准备切换;</p><h3 id="2-2xx-Successful-该请求已成功收到，理解并接受"><a href="#2-2xx-Successful-该请求已成功收到，理解并接受" class="headerlink" title="(2). 2xx (Successful): 该请求已成功收到，理解并接受"></a>(2). 2xx (Successful): 该请求已成功收到，理解并接受</h3><p>200 (成功): 服务器完成已成功处理了请求，通常，这表示服务器提供了请求的网页;</p><p>201 (已创建): 请求成功并且服务器创建了新的资源;</p><p>202 (已接受): 服务器已接收请求，但尚未处理;</p><p>203 (非授权信息): 服务器已成功处理了请求，但返回的信息可能来自另一来源;</p><p>204 (无内容): 服务器成功处理了请求，但没有返回任何内容;</p><p>205 (重置内容): 响应执行成功，重置页面(Form表单)，方便用户下次输入;</p><p>206 (部分内容): 服务器成功处理了部分<code>get</code>请求;</p><h3 id="3-3xx-Redirection-重定向"><a href="#3-3xx-Redirection-重定向" class="headerlink" title="(3). 3xx (Redirection): 重定向"></a>(3). 3xx (Redirection): 重定向</h3><p>300 (多种选择): 针对请求，服务器可执行多种操作，服务器可根据请求者(user agent)选择一项操作，或提供操作列表供请求者选;</p><p>301 (永久移动): 请求的网页已永久移动到新位置，服务器返回此响应(对<code>GET</code>或<code>HEAD</code>请求的响应)时，会自动将请求者转到新位置;</p><p>302 (临时移动): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;</p><p>303 (查看其他位置): 请求者应当对不同的位置使用单独的<code>GET</code>请求来检索响应时，服务器返回此代码;</p><p>304 (未修改): 自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容;</p><p>305 (使用代理): 请求者只能使用代理访问请求的网页，如果服务器返回此响应，还表示请求者应使用代理;</p><p>307 (临时重定向): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;</p><h3 id="4-4xx-Client-Error-该请求包含错误的语法或不能为完成"><a href="#4-4xx-Client-Error-该请求包含错误的语法或不能为完成" class="headerlink" title="(4). 4xx (Client Error): 该请求包含错误的语法或不能为完成"></a>(4). 4xx (Client Error): 该请求包含错误的语法或不能为完成</h3><p>400 (错误请求): 服务器不理解请求的语法;</p><p>401 (未授权): 请求要求身份验证，对于需要登陆的网页，服务器可可能返回此响应;</p><p>403 (禁止): 服务器拒绝请求;</p><p>404 (未找到): 服务器找不到请求的网页;</p><p>405 (方法禁用): 禁用请求中指定的方法;</p><p>406 (不接受): 无法使用请求的内容特性响应请求的网页;</p><p>407 (需要代理授权): 此状态码与401(未授权)类似，但指定请求者应当授权使用代理;</p><p>408 (请求超时): 服务器等候请求时发生超时;</p><p>409 (冲突): 服务器在完成请求时发生冲突，服务器必须在响应中包含有关冲突的信息;</p><p>410 (已删除): 如果请求的资源已永久删除，服务器就会返回此响应;</p><p>411 (需要有效长度): 服务器不接受不含有效内容长度标头字段的请求;</p><p>412 (未满足前提条件): 服务器未满足请求者在请求中设置的其中一个前提条件;</p><p>413 (请求实体过大): 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力;</p><p>414 (请求URL过长): 请求的URL(通常为网址)过长，服务器无法处理;</p><p>415 (不支持的媒体类型): 请求的格式不接受请求页面的支持;</p><p>416 (请求范围不符合要求): 如果页面无法提供请求的范围，则服务器会返回此状态状态码;</p><p>417 (未满足期望值): 服务器未满足”期望”请求标头字段的要求;</p><h3 id="5-5xx-Server-Error-服务器错误-504-网关超时"><a href="#5-5xx-Server-Error-服务器错误-504-网关超时" class="headerlink" title="(5). 5xx (Server Error): 服务器错误 504 - 网关超时"></a>(5). 5xx (Server Error): 服务器错误 504 - 网关超时</h3><p>500 (服务器内部错误): 服务器遇到错误，无法完成请求;</p><p>501 (尚未实施): 服务器不具备完成请求的功能。例如服务器无法识别请求方法时可能会返回此代码;</p><p>502 (错误网关): 服务器作为网关或代理，从上游服务器收到无效响应;</p><p>503 (服务不可用): 服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态;</p><p>504 (网关超时): 服务器作为网关或代理，但是没有及时从上游服务器收到请求;</p><p>505 (HTTP版本不受支持): 服务器不支持请求中所用的HTTP版本协议;</p><h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><p>请求报文: 请求行 (方法字段，URL字段，HTTP协议版本字段)，请求头，空行，请求数据</p><p>响应报文: 响应行(协议版本，状态码以及描述)，响应头，空行，响应体</p><h2 id="HTTP常用的首部字段"><a href="#HTTP常用的首部字段" class="headerlink" title="HTTP常用的首部字段"></a>HTTP常用的首部字段</h2><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>Cache-Control 控制缓存<br>Connection 连接管理<br>Transfor-Encoding 报文主体的传输编码格式<br>Date 创建报文的时间<br>Upgrade 升级为其他协议</p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>Host 请求资源所在的服务器 (唯一一个HTTP/1.1规范里要求必须出现的字段)Accept 客户端或者代理能够处理的媒体类型If-Match 比较实体标记 (ETag)If-None-Match 比较实体标记 (ETag)，与 If-Match 相反If-Modified-Since 比较资源更新时间 (Last-Modified)If-Unmodified-Since 比较资源更新时间 (Last-Modified)， 与 If-Modified-Since 相反Range 实体的字节范围请求User-Agent 客户端信息</p><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>Accept-Ranges 能接受的字节范围<br>Location 命令客户端重定向的 URI<br>ETag 能够表示资源唯一资源的字符串<br>Server 服务器的信息</p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>Allow 资源可支持 HTTP 请求方法Last-Modified 资源最后修改时间Expires 实体主体过期时间Content-Language 实体资源语言Content-Encoding 实体编码格式Content-Length 实体大小Content-Type 实体媒体类型</p><h2 id="URL包含哪几个部分"><a href="#URL包含哪几个部分" class="headerlink" title="URL包含哪几个部分"></a>URL包含哪几个部分</h2><p>(1). 协议类型;<br>(2). 主机名;<br>(3). 端口号;<br>(4). 路径;<br>(5). 参数(:parameters);<br>(6). 查询(?query);<br>(7). 信息片段(fragment);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程与线程的区别&quot;&gt;&lt;a href=&quot;#进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的区别&quot;&gt;&lt;/a&gt;进程与线程的区别&lt;/h2&gt;&lt;p&gt;进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="网络" scheme="https://andylinwenqin.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架面试总结</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-04T15:39:19.000Z</published>
    <updated>2021-09-12T12:41:42.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="真实DOM和其解析流程"><a href="#真实DOM和其解析流程" class="headerlink" title="真实DOM和其解析流程"></a>真实DOM和其解析流程</h2><p>(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵DOM树;</p><p>(2). 生成样式表，用css分析器，分析css文件和元素上的inline样式，生成页面的样式表;</p><p>(3). 构建Render树: 将DOM树和样式表关联起来，构建一颗Render树(Attachment) 每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)，这些render对象最终会构建成一颗render树;</p><p>(4). 确定节点坐标: 根据Render树结构，为每个Render树上的节点确定一个在显示屏上出现的精确坐标;</p><p>(5). 绘制页面: 根据Render树和节点显示坐标，然后调用每个节点的paint方法，将它门绘制出来;</p><p>注意点:</p><p>(1). 构建DOM树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个HTML文档解析完成之后才开始构建render树和布局;</p><p>(2). Render树DOM树和CSS样式表这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析以及一边渲染;</p><p>(3). CSS的解析是从右往左逆向解析的，嵌套标签越多，解析越慢;</p><p>(4). 用我们传统的开发模式，原声JS操作DOM时，浏览器会从构建DOM树开始从头到尾执行一边流程，在一次操作中，我们需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会立即马上执行流程，最终执行10次，这样会导致页面卡顿并且影响用户体验;</p><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>虚拟DOM的好处：</p><p>虚拟DOM就是为了解决浏览器性能问题而被设计出来的，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attach到DOM树上，再进行后续操作，避免大量无谓的计算量，所以用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制</p><p>比较两颗虚拟DOM树的差异 - diff算法</p><p>diff算法用来比较virtual dom树的差异，如果两颗树完全比较，那么diff算法的时间复杂度位O(n^3)，但是在前端当中，会很少跨越层级地移动DOM元素，所以virtual dom只会对同一层级的元素进行对比，这样算法复杂度就可以达到O(n)</p><p>(1).深度优先遍历记录差异;</p><p>(2). 差异类型;</p><ol><li><p>节点替换：节点改变了，例如将上面的 div 换成 h1;</p></li><li><p>顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；</p></li><li><p>属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；</p></li><li><p>文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”;</p></li></ol><p>(3). 列表对比算法</p><p>子节点的对比算法，例如:p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动</p><h2 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h2><p>(1). Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能而React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染;</p><p>(2). Vue支持双向绑定，而React的数据流一直提倡单向数据流，他称之为 onChange/setState()模式。;</p><p>(3). 模版渲染方式不同 React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现;</p><h2 id="SPA单页面应用"><a href="#SPA单页面应用" class="headerlink" title="SPA单页面应用"></a>SPA单页面应用</h2><p>其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。</p><p>优 点: 减轻服务端的压力，可维护性高</p><p>缺点: 首次加载速度慢，搜索引擎优化效果不好</p><p>为什么首屏时间慢，SEO 差？<br>单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。</p><p>SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。</p><p>多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。</p><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的contorller演变成ViewModel,Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p><h2 id="介绍下Vue的响应式数据"><a href="#介绍下Vue的响应式数据" class="headerlink" title="介绍下Vue的响应式数据"></a>介绍下Vue的响应式数据</h2><p>Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)</p><p><strong>Vue3.x响应式数据原理</strong><br>    Vue3.x该用proxy代替Object.defineProperty. 因为Proxy可以直接监听对象和数组的变化<br>    <strong>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</strong><br>        判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>    <strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong><br>        我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h2 id="Vue2-x中如何监测数组变化"><a href="#Vue2-x中如何监测数组变化" class="headerlink" title="Vue2.x中如何监测数组变化"></a>Vue2.x中如何监测数组变化</h2><p>​    使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控，这样就实现了监测数组变化。</p><h2 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理"></a>nextTick实现原理</h2><p>在下次DOM更新循环结束之后执行延迟回调，nextTick主要使用了宏任务和微任务，根据执行环境分别尝试采用(1).promise;(2).MutationObserver;(3).setImmediate;(4).如果以上都不行采用setTimeout定义一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p> Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模版，挂载Dom,渲染, 更新 再渲染， 销毁等一系列过程，我们称这个为vue的生命周期。</p><p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段: 初始化，运行中，销毁</p><p>(1). 实例，组件通过new Vue()创建出来之后会初始化事件和生命周期，然后就会执行<code>beforeCreate</code>钩子函数，这个时候数据还没有挂载，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</p><p>(2). 挂载数据，绑定事件等，然后执行<code>created</code>函数，这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发update函数，在这里可以再渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以再这里初始数据的获取</p><p>(3). 接下里开始实例或者组件对应的模版，编译模版为虚拟dom放入到render函数中准备渲染，然后执行<code>beforeMount</code>钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染，在这里也可以更改数据，不会触发update，这里是渲染前最后一次更改数据的机会，不会触发其他钩子函数，一般可以在这里做初始数据的获取</p><p>(4). 接下来开始render，渲染出真实dom，然后执行<code>mounted</code>钩子函数，此时，组件已经出现在页面中，数据，真实dom都已经处理好了，事件已经挂载好了，可以在这里操作真实dom等事情；</p><p>(5). 当组件或实例的数据更改之后，会立即执行<code>beforeUpdate</code>,然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用<code>diff</code>算法进行对比之后重新渲染，一般不做什么事</p><p>(6). 当更新完成后，执行<code>updated</code>，数据已经更新完成，dom也重新render完成，可以操作更新后的虚拟dom</p><p>(7). 当经过某种途径调用$destory方法之后，立即执行<code>beforeDestroy</code>,一般在这里做一些善后工作，例如清除计时器，清除非指令绑定的事件等</p><p>(8). 组件的数据绑定，监听去掉后只剩下dom空壳，这个时候执行<code>destoryed</code>,在这里做善后工作也可以</p><p> 嵌套组件的生命周期的执行顺序：</p><pre><code>vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted</code></pre><p>更改组件数据　　修改子组件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted ——&gt; son.beforeUpdate ——&gt; son.updated</span><br></pre></td></tr></table></figure><p> Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。</p><p>当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它</p><h2 id="Vue的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue的父组件和子组件生命周期钩子函数执行顺序"></a>Vue的父组件和子组件生命周期钩子函数执行顺序</h2><p><strong>加载渲染过程</strong></p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><p><strong>子组件更新过程</strong></p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><p><strong>父组件更新过程</strong></p><p>父 beforeUpdate -&gt; 父 updated</p><p><strong>销毁过程</strong></p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p><p><strong>在哪个生命周期内调用异步请求</strong></p><p>可以在钩子函数created，beforeMount, mounted中进行调用，因为在这三个钩子函数中，data已经创建，可以将服务端返回的数据进行赋值，</p><p><strong>在什么阶段才能访问操作</strong>DOM</p><p>在钩子函数mounted被调用前，Vue已经将编译号的模版挂载到页面上，所以在mounted中可以访问操作DOM</p><h2 id="created和mounted的区别"><a href="#created和mounted的区别" class="headerlink" title="created和mounted的区别"></a>created和mounted的区别</h2><p><code>created</code>: 在模版渲染成html前调用，即挂载数据和绑定事件等等，此时是无法对html的dom节点进行操作的，此时更改数据不会触发<code>update</code>函数</p><p><code>mounted</code>: 在模版渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作，此时更改数据会触发<code>update</code>函数</p><h2 id="Vue双向绑定的原理"><a href="#Vue双向绑定的原理" class="headerlink" title="Vue双向绑定的原理"></a>Vue双向绑定的原理</h2><p>vue数据双向绑定事通过数据劫持结合发布者-订阅者模式的方式来实现的。<br>vue通过<code>Object.defineProperty()</code>这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p><p><code>Object.defineProperty()</code>的第一个缺陷，无法监听数组变化，第二个缺陷是只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历</p><ol><li><p>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p></li><li><p>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对 应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></li><li><p>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p></li></ol><p>在自身实例化时往属性订阅器(dep)里面添加自己 ，自身必须有一个 update() 方法，待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</p><ol start="4"><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听<br>自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变 更的双向绑定效果。</li></ol><p><strong>v-model本质上是一个父子通信组件的语法糖，通过props和$emit实现</strong></p><h2 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h2><p>v-if: 是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块</p><p>v-show: 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的‘display’属性进行切换</p><p>所以v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景</p><h2 id="v-for中-key-值的作用"><a href="#v-for中-key-值的作用" class="headerlink" title="v-for中 key 值的作用"></a>v-for中 key 值的作用</h2><p>在列表渲染过程中，key可以提高列表渲染的效率，提高页面的性能，因为<code>v-for</code>更新已渲染的元素列表时，默认用就地复用的原则对列表进行修改，他会根据key的值去判断某个值是否修改，如果修改了key，则重新渲染这一项，否则复用之前的元素。</p><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><p>父传子: 通过<code>v-on</code>绑定一个变量名称，在子组件中用props进行接收</p><p>子传父: 在子组件中绑定一个方法，将参数传入之后通过<code>$emit()</code>传递出去， <code>$emit()</code>里的参数是父组件中定义的方法名称以及参数</p><h2 id="为什么组件里的data必须是函数而不是对象？"><a href="#为什么组件里的data必须是函数而不是对象？" class="headerlink" title="为什么组件里的data必须是函数而不是对象？"></a>为什么组件里的<code>data</code>必须是函数而不是对象？</h2><p> 因为组件在Vue中是可以重复调用的，那么如果这个组件被多次调用并且<code>data</code>是对象的话，所有这个组件的实例会共同share一份<code>data</code>这样就会造成数据的泄漏，并且组件中的数据会对不上号，可能实例a的数据应用在了实例b上， 所以如果<code>data</code>是函数，就能确保每一个实例都有一份自己的<code>data</code>,使得统一组件的不同实例间的<code>data</code>不会互相影响。</p><h2 id="怎样理解Vue的单向数据流"><a href="#怎样理解Vue的单向数据流" class="headerlink" title="怎样理解Vue的单向数据流"></a>怎样理解Vue的单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h2 id="Vue中key的作用"><a href="#Vue中key的作用" class="headerlink" title="Vue中key的作用"></a>Vue中key的作用</h2><p> key是为Vue中vnode的唯一标记，通过key，我们的diff操作可以更加准确，更快速，Vue的diff过程可以概括为: oldCh和newCh各有两个头尾的变量oldStartIndex, oldEndIndex和newStartIndex, newEndIndex，新旧节点会两两对比，即一共有四种比较方式, 如果以上4种都没有匹配，如果设置了key，就会用key再进行比较，在比较的过程中，遍历会往中间靠，一旦StartIndex &gt; EndIndex表明oldCh和newCh至少一个已经遍历完了，就会结束比较(如果没有key,4种都没有匹配成功就会将newStartIndex所在的节点直接生成新的节点且插入到原有的root的子节点中)</p><p>VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。</p><p>所以key是Vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确，更快速</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。<br>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p><h2 id="Vue2-x和Vue3-x渲染器的diff不同处"><a href="#Vue2-x和Vue3-x渲染器的diff不同处" class="headerlink" title="Vue2.x和Vue3.x渲染器的diff不同处"></a>Vue2.x和Vue3.x渲染器的diff不同处</h2><p>简单来说，diff算法的过程</p><p>(1). 同级比较，再比较子节点;<br>(2). 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除);<br>(3). 比较都有子节点的情况;<br>(4). 递归比较子节点;</p><p>正常Diff两个树的时间复杂度时O(N ^ 3),但实际情况下我们很少会进行跨层级的移动DOM,所以Vue将Diff进行优化，从O(N^3) -&gt; O(N)只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较</p><h3 id="vue2-vu3算法区别"><a href="#vue2-vu3算法区别" class="headerlink" title="vue2 vu3算法区别"></a>vue2 vu3算法区别</h3><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。</p><p>Vue3的diff算法在创建VNode时就确定其类型1，以及在mounted/patch的过程中采用位运算来判断一个VNode的类型，在这个基础上再配合核心的Diff算法</p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点：</p><p>首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；</p><p>在vnode没有文本节点的情况下，进入子节点的 diff；</p><ul><li>当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；</li></ul><ul><li>若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中；</li></ul><ul><li>若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；</li></ul><ul><li>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。</li></ul><h2 id="Vue事件绑定原理"><a href="#Vue事件绑定原理" class="headerlink" title="Vue事件绑定原理"></a>Vue事件绑定原理</h2><p>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p><h2 id="watch中deep和immediate的作用？"><a href="#watch中deep和immediate的作用？" class="headerlink" title="watch中deep和immediate的作用？"></a>watch中deep和immediate的作用？</h2><p>deep，默认值是 false，代表是否深度监听。<br>immediate:true代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。</p><h2 id="Vue模版编译原理"><a href="#Vue模版编译原理" class="headerlink" title="Vue模版编译原理"></a>Vue模版编译原理</h2><p>简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：</p><ol><li>生成AST树</li><li>优化</li><li>codegen</li></ol><p>首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。</p><p>使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p><p>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的AST树转换为可执行的代码。</p><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><ul><li>Vue-router是什么？有哪些组件？</li></ul><p>Vue-router是<code>Vue.js</code>官方的路由管理器，它和<code>Vue.js</code>的核心深度集成，让构建单页面应用变得易如反掌</p><p>共有三个组件分别是<code>&lt;router-link&gt;, &lt;router-view&gt;和&lt;keep-alive&gt;(vue2.0提供)</code></p><ul><li>Vue-router有几种钩子函数？具体时什么以及参数</li></ul><p>(1). 前置守卫 在进入这个路由之前;<br>(2). 全局解析守卫;<br>(3). 后置钩子 ;<br>(4). 路由独享的钩子;<br>(5). 组件内的导航钩子</p><ul><li>导航解析流程</li></ul><p>(1). 导航被触发;</p><p>(2). 在失活的组件里调用<code>beforeRouteLeave</code>守卫;</p><p>(3). 调用全局的<code>beforeEach</code>守卫;</p><p>(4). 在重用的组件里调用<code>beforeRouteUpdate</code>守卫;</p><p>(5). 在路由配置里调用<code>beforeEnter</code>;</p><p>(6). 解析异步路由组件;</p><p>(7). 在被激活的组件里调用<code>beforeRouterEnter</code>;</p><p>(8). 调用全局的<code>beforeResolve</code>守卫;</p><p>(9). 导航被确认;</p><p>(10). 调用全局的<code>afterEach</code>钩子;</p><p>(11). 触发DOM更新;</p><p>(12). 调用<code>beforeRouterEnter</code>守卫中传给<code>next</code>的回调函数，创建好的组件实例会作为回调函数的参数传入;</p><h2 id="route和-router的区别是什么？"><a href="#route和-router的区别是什么？" class="headerlink" title="$route和$router的区别是什么？"></a>$route<code>和</code>$router的区别是什么？</h2><p><code>router</code>为vue-router的实例，是一个全局路由对象，包含了路由跳转的方法，钩子函数等</p><p><code>route</code>是路由信息对象和跳转的路由对象，每一个路由都一个route对象，是一个局部对象，包含<code>path, params, hash, query, fullpath, matched, name</code>等路由信息参数</p><h2 id="Vue-router传参方式"><a href="#Vue-router传参方式" class="headerlink" title="Vue-router传参方式"></a>Vue-router传参方式</h2><p>(1). 直接调用<code>$router.push</code>实现携带参数的跳转;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;path: `/describe/$&#123;id&#125;`&#125;)</span><br><span class="line"></span><br><span class="line">// 对应的路由配置</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/describe/:id&#x27;,</span><br><span class="line">    name: &#x27;Describe&#x27;,</span><br><span class="line">    component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure><p>(2).父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。</p><pre><code>this.$router.push(&#123;    name: &#39;Describe&#39;,    params: &#123;        id: id    &#125;&#125;)&#123;    path: &#39;/describe/:id&#39;,    name: &#39;Describe&#39;,    component: Describe&#125;this.$route.params.id</code></pre><p>(3). 父组件：使用path来匹配路由，然后通过query来传递参数;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">  path: &#x27;/describe&#x27;,</span><br><span class="line">  query: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> path: &#x27;/describe&#x27;,</span><br><span class="line"> name: &#x27;Describe&#x27;,</span><br><span class="line"> component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$route.query.id</span><br></pre></td></tr></table></figure><h2 id="Vue-router的跳转方式"><a href="#Vue-router的跳转方式" class="headerlink" title="Vue-router的跳转方式"></a>Vue-router的跳转方式</h2><p>(1). router-link;<br>(2). this.$router.push();<br>(3). this.$router.replace();<br>(4). this.$router.go();<br>(5). this.$router.forward();<br>(6). this.$router.back();</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取新的state的值，重新渲染Vue componments,界面随之更新</p><p><strong>vuex为什么需要用 mutation 这些来修改 state 数据，而不是直接更改</strong></p><p>Vuex 单向数据流有关，因为需要知道数据修改的来源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;真实DOM和其解析流程&quot;&gt;&lt;a href=&quot;#真实DOM和其解析流程&quot; class=&quot;headerlink&quot; title=&quot;真实DOM和其解析流程&quot;&gt;&lt;/a&gt;真实DOM和其解析流程&lt;/h2&gt;&lt;p&gt;(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>v-bind</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/v-bind/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/v-bind/</id>
    <published>2021-09-04T12:04:21.000Z</published>
    <updated>2021-09-05T16:18:23.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><hr><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A-HTML-Class">绑定 HTML Class</a></h2><p><a href="https://learning.dcloud.io/#/?vid=7">观看本节视频讲解</a></p><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95">对象语法</a></h3><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据 property <code>isActive</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthiness</a>。</p><p>你可以在对象中传入更多字段来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class attribute 共存。当有如下模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p><p>绑定的数据对象不必内联定义在模板里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#x27;text-danger&#x27;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<a href="https://cn.vuejs.org/v2/guide/computed.html">计算属性</a>。这是一个常用且强大的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95">数组语法</a></h3><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#x27;active&#x27;,</span><br><span class="line">  errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 是 truthy[<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1">1]</a> 时才添加 <code>activeClass</code>。</p><p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A">用在组件上</a></h3><blockquote><p>这个章节假设你已经对 <a href="https://cn.vuejs.org/v2/guide/components.html">Vue 组件</a>有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p></blockquote><p>当在一个自定义组件上使用 <code>class</code> property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。</p><p>例如，如果你声明了这个组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在使用它的时候添加一些 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>HTML 将被渲染为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>对于带数据绑定 class 也同样适用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 为 truthy[<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1">1]</a> 时，HTML 将被渲染成为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F">绑定内联样式</a></h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-1">对象语法</a></h3><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &#x27;red&#x27;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &#x27;red&#x27;,</span><br><span class="line">    fontSize: &#x27;13px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对象语法常常结合返回对象的计算属性使用。</p><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-1">数组语法</a></h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80">自动添加前缀</a></h3><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix">浏览器引擎前缀</a>的 CSS property 时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%A4%9A%E9%87%8D%E5%80%BC">多重值</a></h3><blockquote><p>2.3.0+</p></blockquote><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p><p><strong>译者注</strong><br>[1] truthy 不是 <code>true</code>，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">MDN</a> 的解释。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Class-与-Style-绑定&quot;&gt;&lt;a href=&quot;#Class-与-Style-绑定&quot; class=&quot;headerlink&quot; title=&quot;Class 与 Style 绑定&quot;&gt;&lt;/a&gt;Class 与 Style 绑定&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;操作元素的 cla</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS动画</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/CSS%E5%8A%A8%E7%94%BB/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/CSS%E5%8A%A8%E7%94%BB/</id>
    <published>2021-09-04T08:42:38.000Z</published>
    <updated>2021-09-05T16:18:23.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS动画和实现方法"><a href="#CSS动画和实现方法" class="headerlink" title="CSS动画和实现方法"></a>CSS动画和实现方法</h1><hr><h2 id="css3颜色渐变"><a href="#css3颜色渐变" class="headerlink" title="css3颜色渐变"></a>css3颜色渐变</h2><p>CSS 渐变使您可以显示两种或多种指定颜色之间的平滑过渡。</p><p>CSS 定义了两种渐变类型：</p><ul><li><em>线性渐变</em>（向下/向上/向左/向右/对角线）</li><li><em>径向渐变</em>（由其中心定义）</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom right, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904164739.png"></p><h3 id="使用角度"><a href="#使用角度" class="headerlink" title="使用角度"></a>使用角度</h3><p>如果希望对渐变角度做更多的控制，您可以定义一个角度，来取代预定义的方向（向下、向上、向右、向左、向右下等等）。值 0deg 等于向上（to top）。值 90deg 等于向右（to right）。值 180deg 等于向下（to bottom）。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(-<span class="number">90deg</span>, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用透明度"><a href="#使用透明度" class="headerlink" title="使用透明度"></a>使用透明度</h3><p>CSS 渐变还支持透明度，也可用于创建渐变效果。</p><p>如需添加透明度，我们使用 rgba() 函数来定义色标。 rgba() 函数中的最后一个参数可以是 0 到 1 的值，它定义颜色的透明度：0 表示全透明，1 表示全彩色（无透明）。</p><p>下面的例子展示了从左开始的线性渐变。它开始完全透明，然后过渡为全色红色：</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background-image: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css3使用animation属性实现背景颜色动态渐变的效果"><a href="#css3使用animation属性实现背景颜色动态渐变的效果" class="headerlink" title="css3使用animation属性实现背景颜色动态渐变的效果"></a>css3使用animation属性实现背景颜色动态渐变的效果</h2><p>首先我们来看一下CSS3关键帧动画的基础知识</p><p>让我们先了解逐渐改变元素的动画！在CSS 3 animation属性中，您可以设置关键帧并绘制详细的运动。关于动画的时间和时机、无限的循环，只有CSS就可以指定了！</p><h3 id="什么是关键帧？"><a href="#什么是关键帧？" class="headerlink" title="什么是关键帧？"></a>什么是关键帧？</h3><p>关键帧（传递点）是在动画中定义更改的帧。我们@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，您需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。</p><p>@keyframes规则的名称声明为“ @keyframes +任意名称 ”。我将写入0％到100％的关键帧信息。0％表示开始动画，100％表示结束时间。0％from，100％可以用to替换。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> name &#123;</span><br><span class="line"> <span class="number">0%</span> &#123; <span class="attribute">background</span>: red; &#125;</span><br><span class="line"> <span class="number">50%</span> &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line"> <span class="number">100%</span> &#123; <span class="attribute">background</span>: pink; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="animation相关属性"><a href="#animation相关属性" class="headerlink" title="animation相关属性"></a>animation相关属性</h3><p><strong>animation-name（动画名）</strong></p><p>@keyframes指定中定义的名称。如果未指定此项，则不会执行动画。此外，如果指定的动画名称与任何关键帧都不匹配，则不会执行该关键帧。</p><p><strong>animation-duration（动画持续时间）</strong></p><p>通过“秒+ s”指定执行一个动画的时间长度。例如，“5秒”持续5秒。如果为0，则不会执行。即使指定了负值，也会将其视为0。</p><p><strong>animation-timing-function（动画定时功能）</strong></p><p>指定动画的时间以及如何继续。您可以通过调整动画进度速度的比例来表达平滑运动。</p><p><strong>ease（初期値）</strong></p><p>ease-in</p><p>ease-out</p><p>ease-in-out</p><p>linear</p><p><strong>animation-delay（动画延迟）</strong></p><p>读取元素时，从“元素编号+ s”指定“动画开始”的时间。例如，“5秒”持续5秒。初始值0将立即执行。</p><p><strong>animation-iteration-count（动画迭代计数）</strong></p><p>指定使用数字重复动画的次数。infinite要指定无限循环，请指定。</p><p><strong>animation-direction（动画方向）</strong></p><p>指定重复动画的方向。</p><p><strong>normal …正常方向播放（初始值）</strong></p><p>alternate …在正常和偶数时间以相反方向重新生成奇数次（返回并返回…）</p><p>reverse…向后播放</p><p>alternate-reverse…反向播放</p><p><strong>animation-play-state（动画播放状态）</strong></p><p>指定动画暂停（paused）和播放（running）。但是，似乎没有太多使用。</p><p>animation-fill-mode（动画填充模式）</p><p>指定播放动画之前和之后的状态。</p><p>none（默认值）</p><p>forwards..播放后保持最后一个关键帧的状态</p><p>backwards…在播放前应用第一个关键帧的状态</p><p>both … forwards ……向前和向后都应用</p><h3 id="属性总结"><a href="#属性总结" class="headerlink" title="属性总结"></a>属性总结</h3><p>animation属性允许您分别指定每个属性的值，用空格分隔。项目可以省略，但动画名称必须在执行前写入。建议按以下顺序列出。</p><p>animation-name（动画名）</p><p>animation-duration（动画持续时间）</p><p>animation-timing-function（动画定时功能）</p><p>animation-delay（动画延迟）</p><p>animation-iteration-count（动画迭代计数）</p><p>animation-direction（动画方向）</p><p>animation-fill-mode（动画填充模式）</p><p>animation-play-state（动画播放状态）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: test <span class="number">5s</span> ease <span class="number">1s</span> infinite forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面我们来看看背景颜色改变的具体内容</strong></p><p>在了解了基础的知识之后，我们来详细看看具体的实现方法。首先，将关键帧的名称设置为“bg - color”，并将背景颜色设置为从0到100％的过渡。如果将相同的颜色设置为0％和100％，则在循环动画时它会平滑移动。我们还将描述您为基于Webkit的浏览器启用的版本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@-webkit-keyframes</span> bg-color &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">  <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span><br><span class="line">  <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span><br><span class="line">  <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span><br><span class="line">  <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> bg-color &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">  <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span><br><span class="line">  <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span><br><span class="line">  <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span><br><span class="line">  <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于此时指定整个网页的背景颜色，body以animation指定属性。值为“关键帧名称”，bg-color“更改”在10秒内添加，“，10s”指定无限循环infinite。不要忘记webkit的版本。background-color让我们指定基本背景颜色作为背景色，为动画不起作用的情况做准备。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">              <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line"><span class="css">              <span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="css">              -webkit-<span class="attribute">animation</span>: bg-color <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="keyword">@-webkit-keyframes</span> bg-color &#123;</span></span><br><span class="line"><span class="css">                <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="keyword">@keyframes</span> bg-color &#123;</span></span><br><span class="line"><span class="css">                <span class="number">0%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">20%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#f1c40f</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">40%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">60%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#3498db</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">80%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#9b59b6</span>; &#125;</span></span><br><span class="line"><span class="css">                <span class="number">100%</span> &#123; <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>; &#125;</span></span><br><span class="line"><span class="css">            &#125; </span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>andyLin博客<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904170016.gif"></p><h2 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h2><h2 id="实现一个简单的三角形"><a href="#实现一个简单的三角形" class="headerlink" title="实现一个简单的三角形"></a>实现一个简单的三角形</h2><p>使用CSS盒模型中的border（边框）即可实现如下所示的三角形：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904170941.webp"></p><p>CSS实现简单三角形</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>首先来看在为元素添加border时，border的样子；假设有如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    border: 2px solid orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171004.webp"></p><p>border的一般使用</p><p>这是我们平常使用border最普遍的情况——往往只给border一个较小的宽度（通常为1-2px）；然而这样的日常用法就会容易让大家对border的形成方式产生<strong>误解</strong>，即认为元素的border是由四个矩形边框拼接而成。</p><p>然而事实并不是这样。实际上，元素的border是由<strong>三角形</strong>组合而成，为了说明这个问题，我们可以增大border的宽度，并为各border边设置不同的颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171017.webp"></p><p>border的形成方式</p><p>既然如此，那么更进一步，把元素的内容尺寸设置为0会发生什么情况呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171026.webp"></p><p>元素内容尺寸为0</p><p>我们将惊奇地发现，此时元素由上下左右4个三角形“拼接”而成；那么，为了实现最终的效果，即保留最下方的三角形，还应该怎么做？很简单，我们只需要把其它border边的颜色设置为<strong>白色</strong>或<strong>透明色</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">40px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904171041.webp"></p><p>Duang~ 最终的简单三角形就绘制出来了。同理，如果想要得到其它边上的三角形，只需要将剩余的border边颜色设置为白色或透明色即可。</p><p>不过，被“隐藏”的上border仍然占据着空间，要想使得绘制出的三角形尺寸最小化，还需要将上border的宽度设置为0（其它情况同理）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">40px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出自-CSS绘制三角形—border法"><a href="#出自-CSS绘制三角形—border法" class="headerlink" title="出自 CSS绘制三角形—border法"></a>出自 <a href="https://www.jianshu.com/p/9a463d50e441">CSS绘制三角形—border法</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS动画和实现方法&quot;&gt;&lt;a href=&quot;#CSS动画和实现方法&quot; class=&quot;headerlink&quot; title=&quot;CSS动画和实现方法&quot;&gt;&lt;/a&gt;CSS动画和实现方法&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;css3颜色渐变&quot;&gt;&lt;a href=&quot;#css3颜色渐变</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>watch和computed</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/watch%E5%92%8Ccomputed/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/watch%E5%92%8Ccomputed/</id>
    <published>2021-09-04T07:31:54.000Z</published>
    <updated>2021-09-05T16:18:23.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算属性computed："><a href="#计算属性computed：" class="headerlink" title="计算属性computed："></a>计算属性computed：</h1><ul><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li><li>如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li></ul><h1 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a>侦听属性watch：</h1><ul><li>不支持缓存，数据变，直接会触发相应的操作；</li><li>watch支持异步；</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li></ul><h1 id="watch和computed的区别和应用场景（面试版）"><a href="#watch和computed的区别和应用场景（面试版）" class="headerlink" title="watch和computed的区别和应用场景（面试版）"></a>watch和computed的区别和应用场景（面试版）</h1><pre><code>计算属性`computed`和监听器`watch`都可以观察属性的变化从而做出响应，不同的是: 计算属性`computed`更多是作为缓存功能的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，`computed`不会立即重新计算生成新的值，而是先标记为脏数据，当下次`computed`被获取的时候，才会进行重新计算并返回;而监听器`watch`并不具备缓存性，监听器`watch`提供一个监听函数，当监听的属性发生变化时，会立即执行该函数异步请求就用`watch`computed: 是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时，才会重新计算computed的值watch: 更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续的操作应用场景:    (1).当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可利用computed的缓存特性，避免每次获取值时，都要重新计算;    (2). 当我们需要在数据变化时执行异步或者开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的;</code></pre><p><strong>immediate</strong>：<strong>组件加载立即触发回调函数执行</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = newName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 代表在wacth里声明了firstName这个方法之后立即执行handler方法</span></span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    <span class="built_in">handler</span>(newName, oldName) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&#x27;obj.a changed&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h1><table><thead><tr><th></th><th>watch</th><th align="right">computed</th></tr></thead><tbody><tr><td>定义格式</td><td>必须监听存在的属性(data、props、computed)</td><td align="right">不能和data定义的变量相同</td></tr><tr><td>异步</td><td>支持异步操作</td><td align="right">不支持异步</td></tr><tr><td>开销</td><td>适合一些开销较大的操作</td><td align="right">适合做一些简单依赖的计算</td></tr></tbody></table><p>对于computed能做的 watch都可以做，至于选择哪个去做，都应该去看使用场景</p><h2 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h2><p>第一个输入框+第二个输入框 进行拼接</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904153613.png"></p><pre><code>&lt;input type=&quot;text&quot; v-model=&quot;num1&quot; name=&quot;&quot; id=&quot;&quot;&gt;+&lt;input type=&quot;text&quot; v-model=&quot;num2&quot; name=&quot;&quot; id=&quot;&quot;&gt;=&#123;&#123;num3&#125;&#125;&#123;&#123;res&#125;&#125;</code></pre><h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">      res()&#123;</span><br><span class="line">      this.num3= this.num1+this.num2</span><br><span class="line">      &#125;,</span><br><span class="line">      num2()&#123;</span><br><span class="line">      this.num3= this.num1+this.num2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  res() &#123;</span><br><span class="line">    return this.num1+this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><p>从代码量来看 显然更适合 用计算属性去做，而使用watch 就要检测两个值的变化 稍微繁琐了些</p></li><li><p>但是 watch 可以做一些异步的事情 并且可以设置改变多个值   这是计算属性做不到的</p></li></ul><h2 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h2><p>关于缓存问题 个人感觉 这两个并不能比，可以用computed和methods去比</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre><code>&#123;&#123;res()&#125;&#125;&#123;&#123;res()&#125;&#125; methods: &#123;  res() &#123;    console.log(&#39;方法被执行了&#39;);   return this.num1+this.num2  &#125;&#125;,</code></pre><p> 如果视图上多个使用这个方法 每个调用都会执行 </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210904153529.png"></p><h3 id="计算属性-1"><a href="#计算属性-1" class="headerlink" title="计算属性"></a>计算属性</h3><p> 而计算属性不同，只有当值发生改变的时候他才会执行，如果上次没有改变他会取从缓存拿值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;res&#125;&#125;</span><br><span class="line">&#123;&#123;res&#125;&#125;</span><br><span class="line"> </span><br><span class="line">computed: &#123;</span><br><span class="line">  res() &#123;</span><br><span class="line">    console.log(&#x27;计算属性执行了&#x27;);</span><br><span class="line">    return this.num1+this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算属性computed：&quot;&gt;&lt;a href=&quot;#计算属性computed：&quot; class=&quot;headerlink&quot; title=&quot;计算属性computed：&quot;&gt;&lt;/a&gt;计算属性computed：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;支持缓存，只有依赖数据发生改变，才会重新</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>属性选择器</title>
    <link href="https://andylinwenqin.github.io/2021/09/04/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://andylinwenqin.github.io/2021/09/04/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2021-09-04T06:36:46.000Z</published>
    <updated>2021-09-05T16:18:23.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><hr><p>CSS <strong>属性选择器</strong>通过已经存在的属性名或属性值匹配元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存在title属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在class属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">&quot;logo&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p><code>[attr]</code></p><p>表示带有以 attr 命名的属性的元素。</p></li><li><p><code>[attr=value]</code></p><p>表示带有以 attr 命名的属性，且属性值为 value 的元素。</p></li><li><p><code>[attr~=value]</code></p><p>表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 value。</p></li><li><p><code>[attr|=value]</code></p><p>表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（”<code>-</code>“为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。</p></li><li><p><code>[attr^=value]</code></p><p>表示带有以 attr 命名的属性，且属性值是以 value 开头的元素。</p></li><li><p><code>[attr$=value]</code></p><p>表示带有以 attr 命名的属性，且属性值是以 value 结尾的元素。</p></li><li><p><code>[attr*=value]</code></p><p>表示带有以 attr 命名的属性，且属性值至少包含一个 value 值的元素。</p></li><li><p><code>[*attr* *operator* *value* i]</code></p><p>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>i</code>（或 <code>I</code>），可以在匹配属性值时忽略大小写（支持 ASCII 字符范围之内的字母）。</p></li><li><p><code>[*attr* *operator* *value* s]</code> </p><p>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>s</code>（或 <code>S</code>），可以在匹配属性值时区分大小写（支持 ASCII 字符范围之内的字母）。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以 &quot;#&quot; 开头的页面本地链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;#&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;example&quot; 的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: silver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;insensitive&quot; 的链接,不区分大小写 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;insensitive&quot;</span> i]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: cyan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含 &quot;cAsE&quot; 的链接，区分大小写 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;cAsE&quot;</span> s]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以 &quot;.org&quot; 结尾的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;属性选择器&quot;&gt;&lt;a href=&quot;#属性选择器&quot; class=&quot;headerlink&quot; title=&quot;属性选择器&quot;&gt;&lt;/a&gt;属性选择器&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;CSS &lt;strong&gt;属性选择器&lt;/strong&gt;通过已经存在的属性名或属性值匹配元素。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误</title>
    <link href="https://andylinwenqin.github.io/2021/08/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux-centos7%E7%B3%BB%E7%BB%9F-%E5%8F%8A-mysql8%EF%BC%88%E8%80%81%E7%89%88%E6%9C%AC%EF%BC%89%E9%85%8D%E7%BD%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://andylinwenqin.github.io/2021/08/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux-centos7%E7%B3%BB%E7%BB%9F-%E5%8F%8A-mysql8%EF%BC%88%E8%80%81%E7%89%88%E6%9C%AC%EF%BC%89%E9%85%8D%E7%BD%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/</id>
    <published>2021-08-23T07:11:19.000Z</published>
    <updated>2021-09-05T16:18:23.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误"><a href="#虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误" class="headerlink" title="虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误"></a>虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误</h1><hr><h2 id="VMware安装虚拟机centos7的步骤，截图讲解"><a href="#VMware安装虚拟机centos7的步骤，截图讲解" class="headerlink" title="VMware安装虚拟机centos7的步骤，截图讲解"></a><a href="https://zhuanlan.zhihu.com/p/87740022">VMware安装虚拟机centos7的步骤，截图讲解</a></h2><p>安装前准备以下路径下载centOS7镜像：<a href="https://link.zhihu.com/?target=https://mirrors.aliyun.com/centos/7/isos/x86_64/">https://mirrors.aliyun.com/cent</a></p><h3 id="安装虚拟机的步骤"><a href="#安装虚拟机的步骤" class="headerlink" title="安装虚拟机的步骤"></a>安装虚拟机的步骤</h3><p>1.点击“创建虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153337.jpg"></p><p>2.点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153405.jpg"></p><p>3.点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153416.jpg"></p><p>4.选择“稍后安装操作系统”，然后“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153430.jpg"></p><p>5.选择Linux—&gt;&gt;版本号CentOS–&gt;&gt;下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153442.jpg"></p><p>6.填写“虚拟机名称”以及选择存放路径 ，然后点击下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153451.jpg"></p><p>7.选择处理器数显 默认是1 我这里选项2，然后“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153936.jpg"></p><p>8.选择内存，我这里选着2，默认是1 然后下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153513.jpg"></p><p>9.选择网络类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153525.jpg"></p><p>10.控制器类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153538.jpg"></p><p>11.磁盘类型</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153548.jpg"></p><p>12.选着“创建新虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153559.jpg"></p><p>13.这里磁盘大小，随便多少都行，5GB也行，磁盘存储单文件或者多文件都行，然后点击下一步</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153606.jpg"></p><p>14。点击“下一步”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154107.jpg"></p><p>15。选自定义，然后选择刚才下载的镜像，然后点击“关闭”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153704.jpg"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823153716.jpg"></p><p>16.点击“完成”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154256.jpg"></p><p>17.点击“开始此虚拟机”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154400.jpg"></p><p>18.等待安装中</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154423.jpg"></p><p>19.选择键盘操作语言，我选择“中文简体”，然后点击“继续”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154513.jpg"></p><p>然后选择“软件选择”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154551.jpg"></p><p>然后顺便你选择 我闲着图形界面，点击“完成”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154611.jpg"></p><p>20 点击 选择时间</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154629.jpg"></p><p>然后选择亚洲–上海时间，———》点击完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823154723.jpg"></p><p>21.选分区</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155241.jpg"></p><p>22.选着网络配置</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155256.jpg"></p><p>首先要打开网卡，然后查看是否能获取到IP地址</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823155508.jpg"></p><p>23.点击“开始安装”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160228.jpg"></p><p>24.点击设置“密码”</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160243.jpg"></p><p>填写密码，点击完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160256.jpg"></p><p>这里也可以创建用户，但是我创建用户，然后<strong>等待安装中</strong></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160307.jpg"></p><p>25.安装完成，点击重启</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160323.jpg"></p><p>26.点击重启后，点击然后接受–完成</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160350.jpg"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160413.jpg"></p><p>然后完成配置</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160423.jpg"></p><p>设置用户名</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160433.jpg"></p><p>安装成功</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160458.jpg"></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>1.在终端中切换目录 ：cd /etc/sysconfig/network-scripts/</p><p>2.在查看当前目录的文件：ls -a</p><p>3.输入su 切换到根目录root中，输入根目录的密码，点击Enter键</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160630.jpg"></p><p>4.输入vi ifcfg-ens33 打开网络配置文件点击“i”进入可编辑文件</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160842.jpg"></p><p>将ONBOOT=no改为ONBOOT=yes，即可配置开机自启动。多增加这几行</p><p>IPADDR=192.168.117.128(ip地址)</p><p>NETMASK=255.255.255.0(子网掩码)</p><p>GATEWAY=192.168.117.13(默认路由)</p><p>DNS1=114.114.114.114(dns)</p><p>按ESC后，再输入:wq，按Enter键，即可保存并退出编辑。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823161006.png"></p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823160938.jpg"></p><p>退出到命令行界面，然后输入重启命令reboot，重启一下系统即可。</p><p>测试外网成功</p><p>ping baidu.com</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823161204.jpg"></p><h2 id="Linux环境-Centos-7-安装MySQL数据库"><a href="#Linux环境-Centos-7-安装MySQL数据库" class="headerlink" title="Linux环境(Centos 7)安装MySQL数据库"></a><a href="https://www.cnblogs.com/guoxiangyue/p/12768560.html">Linux环境(Centos 7)安装MySQL数据库</a></h2><h3 id="1-卸载mariadb"><a href="#1-卸载mariadb" class="headerlink" title="1.卸载mariadb"></a>1.卸载mariadb</h3><p>查看是否已安装mariadb</p><p># yum list installed mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164227.png"></p><p>系统中已经安装mariadb，进行卸载。</p><p># yum remove mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164237.png"></p><p>查看是否卸载成功</p><p># yum list installed mariadb* </p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823164251.png"></p><p>删除mariadb配置文件</p><p># rm -f /etc/my.cnf </p><p>删除mariadb数据目录</p><p># rm -rf /var/lib/mysql/  </p><h3 id="2-下载MySQL-使用rpm来安装MySQL"><a href="#2-下载MySQL-使用rpm来安装MySQL" class="headerlink" title="2.下载MySQL 使用rpm来安装MySQL"></a>2.下载MySQL 使用rpm来安装MySQL</h3><p>因为CentOS 7默认安装的数据库是Mariadb,所以使用YUM命令是无法安装MySQL的，只会更新Mariadb。使用rpm来进行安装。可以在<a href="https://links.jianshu.com/go?to=http://repo.mysql.com/">mysql的repo源仓库</a>右键复制指定版本的数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># wget http:<span class="comment">//repo.mysql.com/mysql80-community-release-el7-1.noarch.rpm</span></span></span><br></pre></td></tr></table></figure><p>安装mysql80-community-release-el7-1.noarch.rpm包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo rpm -ivh mysql80-community-release-el7-<span class="number">1</span><span class="selector-class">.noarch</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><p>安装完成后会在 /etc/yum.repos.d文件夹里面获得两个文件：mysql-community.repo &amp;&amp; mysql-community-source.repo</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165019.webp"><br> 使用yum安装mysql服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo yum install mysql-server</span></span><br></pre></td></tr></table></figure><p>如果显示以下内容说明安装成功<br> <strong>Complete!</strong><br> 检查是否已经设置为开机启动MySQL服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl list-unit-files|grep mysqld</span></span><br></pre></td></tr></table></figure><p>如果显示</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165122.webp"></p><p> 则表示已经设置为开机启动，如果没有设置为开机启动则执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl enable mysqld.service</span></span><br></pre></td></tr></table></figure><p>查看MySQL是否启动未启动则执行启动服务命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看是否启动MySQL服务</span><br><span class="line"><span class="comment"># ps -ef|grep mysql</span></span><br><span class="line"></span><br><span class="line">启动服务</span><br><span class="line"><span class="comment"># systemctl start mysqld.service</span></span><br></pre></td></tr></table></figure><p>初始化MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld --initialize</span></span><br></pre></td></tr></table></figure><p>查看MySQL初始默认密码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grep <span class="string">&#x27;temporary password&#x27;</span> /<span class="keyword">var</span>/log/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210823165150.webp"> 复制 root@localhost: 后面的密码。登录mysql，并粘贴默认密码<br> 因为MySQL8.0的更改，导致必须要重置密码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;12345678&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果设置密码时候出现提示</p><blockquote><p>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</p></blockquote><p>代表需要降低policy的等级后在执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>开启MySQL远程连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="comment">#修改root账户权限</span></span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="comment">#刷新权限</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>到此完成mysql基本安装和配置  快拍一个虚拟机快照啊</p><h2 id="登录mysql和退出mysql"><a href="#登录mysql和退出mysql" class="headerlink" title="登录mysql和退出mysql"></a>登录mysql和退出mysql</h2><p>linux中登录mysql的方式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 127.0.0.1 -p；</span><br></pre></td></tr></table></figure><p>退出MySQL  输入 exit    摁enter</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><p>1.通过yum -y install python-pip命令进行安装提示没有可用软件包 python-pip</p><p>2、接着执行：yum -y install epel-release python-pip命令</p><p>3、最后在次执行：yum -y install python-pip即可成功</p><p>4、然后可通过pip -V查看版本</p><p>5、然后通过：pip install –upgrade pip –user进行升级</p><p>6、然后在执行：pip install –upgrade pip</p><p>7、此时在pip -V看版本即可升级成功</p><h2 id="mysql-老版本-配置问题及解决方法"><a href="#mysql-老版本-配置问题及解决方法" class="headerlink" title="mysql(老版本)配置问题及解决方法"></a>mysql(老版本)配置问题及解决方法</h2><h3 id="1、缺少libmysqlclient-so-18"><a href="#1、缺少libmysqlclient-so-18" class="headerlink" title="1、缺少libmysqlclient.so.18"></a>1、缺少libmysqlclient.so.18</h3><p> 发生服务器错误： Error loading MySQLdb module: libmysqlclient.so.18: cannot open shared object file: No such file or directory</p><h4 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h4><p>这个错误出现的原因是找不到 libmysqlclient.so.18 这个文件，根本原因是，一般我们使用的mysql都是自己从新安装的，不是系统自带的，所以在我们安装我们自己的mysql的时候，会把删除原来的mysql，此时会连带这删掉这个文件，32的目录是 /usr/lib/mysql/，64位的为 /usr/lib64/mysql/下面有这个文件。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>　　1、解决问题的关键是，在找一台未装过mysql的服务器，然后把此文件夹下面的 libmysqlclient.so.18.0.0 文件拷贝到此服务器的这个目录中，然后做软连接。</p><p>​        我选择更好的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/lib/libmysqlclient.so.18 http://files.directadmin.com/services/es_7.0_64/libmysqlclient.so.18</span><br></pre></td></tr></table></figure><p>直接下载缺失文件到对应位置</p><p>　　2、然后 vi /etc/ld.so.conf 后面增加一条记录：/usr/lib64/mysql （libmysqlclient.so.18 和libmysqlclient.so.18.0.0所在目录）</p><p>　　3、运行 ldconfig 命令，让其生效。</p><p>　　ok,完美解决。</p><h3 id="2-Django启动服务器时，报错mysql的2059错误的解决办法。"><a href="#2-Django启动服务器时，报错mysql的2059错误的解决办法。" class="headerlink" title="2.Django启动服务器时，报错mysql的2059错误的解决办法。"></a>2.Django启动服务器时，报错mysql的2059错误的解决办法。</h3><p>启动方式为如下：</p><blockquote><p>python manage.py runserver 0.0.0.0:8000</p></blockquote><p>经过一番查询，调试，最终发现了问题所在。主要就是mysql8.0的问题。<br>目前最新的mysql8.0对用户密码的加密方式为caching_sha2_password, django暂时还不支持这种新增的加密方式。只需要将用户加密方式改为老的加密方式即可。</p><p>解决步骤：<br>1.登录mysql，连接用户为root。</p><blockquote><p>mysql -u root -p</p></blockquote><p>2.执行命令查看加密方式</p><blockquote><p>use mysql;<br>select user,plugin from user where user=’root’;</p></blockquote><p>3.执行命令修改加密方式</p><blockquote><p>alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘yourpassword’</p></blockquote><p>4.属性权限使配置生效</p><blockquote><p>flush privileges</p></blockquote><p>其中遇到两个小问题</p><h4 id="1-Your-password-does-not-satisfy-the-current-policy-requirements"><a href="#1-Your-password-does-not-satisfy-the-current-policy-requirements" class="headerlink" title="1.Your password does not satisfy the current policy requirements"></a>1.Your password does not satisfy the current policy requirements</h4><p>密码策略问题异常信息</p><p>不符合正确密码规范</p><p>解决办法：</p><p>1、查看 mysql 初始的密码策略，<br>输入语句 “ SHOW VARIABLES LIKE ‘validate_password%’; ” 进行查看</p><p>2、首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，<br>输入设值语句 “ set global validate_password_policy=LOW; ” 进行设值，</p><p>3、当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，<br>输入设值语句 “ set global validate_password_length=6; ” 进行设值，</p><p>4、现在可以为 mysql 设置简单密码了，只要满足六位的长度即可，<br>输入修改语句 “ ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; ” 可以看到修改成功，表示密码策略修改成功了！！！</p><p>关于 mysql 密码策略相关参数；<br>1）、validate_password_length  固定密码的总长度；<br>2）、validate_password_dictionary_file 指定密码验证的文件路径；<br>3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；<br>4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；<br>5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；<br>关于 validate_password_policy 的取值：<br>0/LOW：只验证长度；<br>1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；<br>6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</p><h4 id="2-Operation-ALTER-USER-failed-for-‘root‘-’localhost’"><a href="#2-Operation-ALTER-USER-failed-for-‘root‘-’localhost’" class="headerlink" title="2.Operation ALTER USER failed for ‘root‘@’localhost’"></a>2.Operation ALTER USER failed for ‘root‘@’localhost’</h4><p>先登录mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select user,host from user;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| root             | %         |</span><br><span class="line">| admin            | localhost |</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| zhangj           | localhost |</span><br><span class="line">+------------------+-----------+</span><br></pre></td></tr></table></figure><p>注意root，host是’%’</p><p>你可能执行的是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p>改成:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">针对github开源项目wechat-spider的部署</summary>
    
    
    
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Linux" scheme="https://andylinwenqin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件传值</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2021-08-19T15:31:21.000Z</published>
    <updated>2021-09-05T16:18:23.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue组件传值"><a href="#Vue组件传值" class="headerlink" title="Vue组件传值"></a>Vue组件传值</h1><hr><p>先看一张总结图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210820002412.png"></p><h2 id="方法一-父组件向子组件传值-（props传参）"><a href="#方法一-父组件向子组件传值-（props传参）" class="headerlink" title="方法一 父组件向子组件传值 （props传参）"></a>方法一 父组件向子组件传值 （props传参）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son</span><br><span class="line">      str=&quot;字符串&quot;</span><br><span class="line">      :num=&quot;5&quot;</span><br><span class="line">      :obj=&quot;&#123; name: &#x27;对象信息&#x27; &#125;&quot;</span><br><span class="line">      :func=&quot;() =&gt; &#123;this.list()&#125;&quot;</span><br><span class="line">      :arr=&quot;arr&quot;</span><br><span class="line">    &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        arr: [1, 2, 3],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      list() &#123;</span><br><span class="line">        console.log(&#x27;list&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      arr: Array, //定义参数类型</span><br><span class="line">      num: Number,</span><br><span class="line">      str: String,</span><br><span class="line">      str2: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;默认是字符串&#x27;, //定义默认值</span><br><span class="line">      &#125;,</span><br><span class="line">      func: &#123;</span><br><span class="line">        type: Function,</span><br><span class="line">        require: false, // 定义参数是否必须值</span><br><span class="line">      &#125;,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        require: false,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(this.str) //字符串</span><br><span class="line">      console.log(this.str2) //默认字符串</span><br><span class="line">      console.log(this.num) //5</span><br><span class="line">      console.log(this.arr) //[1,2,3]</span><br><span class="line">      console.log(this.func()) // list</span><br><span class="line">      console.log(this.obj) // name:&#x27;对象信息&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法二-子组件向父组件传值-（事件传递）"><a href="#方法二-子组件向父组件传值-（事件传递）" class="headerlink" title="方法二 子组件向父组件传值 （事件传递）"></a>方法二 子组件向父组件传值 （事件传递）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son @func=&quot;speak&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">    methods: &#123;</span><br><span class="line">      speak(msg) &#123;</span><br><span class="line">        console.log(msg) //我是子组件发送的消息</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      this.$emit(&#x27;func&#x27;, &#x27;我是子组件发送的消息！&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法三-事件监听"><a href="#方法三-事件监听" class="headerlink" title="方法三 事件监听"></a>方法三 事件监听</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son ref=&quot;son&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">   mounted() &#123;</span><br><span class="line">     this.$refs[&#x27;son&#x27;].$on(&#x27;func&#x27;,(msg)=&gt;&#123;</span><br><span class="line">         console.log(msg);  //我是子组件传递的消息</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$emit(&#x27;func&#x27;, &#x27;我是子组件传递的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法四-消息发布与订阅"><a href="#方法四-消息发布与订阅" class="headerlink" title="方法四 消息发布与订阅"></a>方法四 消息发布与订阅</h2><p>安装pubsub-js插件:  npm install pubsub-js -s //可实现全局参数传递</p><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        pubsub.publishSync(&#x27;sendMsg&#x27;, &#x27;这是A组件发布的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是B组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;B&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      pubsub.subscribe(&#x27;sendMsg&#x27;, (e, msg) =&gt; &#123;</span><br><span class="line">        console.log(e, msg) //sendMsg 这是A组件发布的消息！</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>publishSync 同步发送消息</li><li>publish  同步发送消息</li><li>subscribe 订阅消息</li><li>unsubscribe 卸载特定订阅消息</li><li>clearAllSubscriptions 清除所有订阅消息</li></ul><h2 id="方法五-非父子组件传值-（EventBus传参）"><a href="#方法五-非父子组件传值-（EventBus传参）" class="headerlink" title="方法五 非父子组件传值 （EventBus传参）"></a>方法五 非父子组件传值 （EventBus传参）</h2><p>在main.js中挂载全局EventBus</p><blockquote><p>1.Vue.prototype.$EventBus = new Vue()</p></blockquote><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$EventBus.$emit(&#x27;sendMsg&#x27;,&#x27;这是A组件发送的消息！&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件</strong>B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是组件B&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;B&quot;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            this.$EventBus.$on(&#x27;sendMsg&#x27;,(msg)=&gt;&#123;</span><br><span class="line">                console.log(msg);//这是组件A发送的消息！</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过挂载全局Vue对象传递参数</p><h2 id="方法六-路由间传值"><a href="#方法六-路由间传值" class="headerlink" title="方法六 路由间传值"></a>方法六 路由间传值</h2><h3 id="i-使用问号传值"><a href="#i-使用问号传值" class="headerlink" title="i.使用问号传值"></a>i.使用问号传值</h3><p>A页面跳转B页面时使用 this.$router.push(’/B?name=danseek’)</p><p>B页面可以使用 this.$route.query.name 来获取A页面传过来的值</p><p>上面要注意router和route的区别</p><h3 id="ii-使用冒号传值"><a href="#ii-使用冒号传值" class="headerlink" title="ii.使用冒号传值"></a>ii.使用冒号传值</h3><p>配置如下路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/b/:name&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;../views/B.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>在B页面可以通过 this.$route.params.name 来获取路由传入的name的值</p><h3 id="iii-使用父子组件传值"><a href="#iii-使用父子组件传值" class="headerlink" title="iii.使用父子组件传值"></a>iii.使用父子组件传值</h3><p>由于router-view本身也是一个组件，所以我们也可以使用父子组件传值方式传值，然后在对应的子页面里加上props，因为type更新后没有刷新路由，所以不能直接在子页面的mounted钩子里直接获取最新type的值，而要使用watch。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :type=&quot;type&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 子页面</span><br><span class="line">......</span><br><span class="line">props: [&#x27;type&#x27;]</span><br><span class="line">......</span><br><span class="line">watch: &#123;</span><br><span class="line">    type()&#123;</span><br><span class="line">    // console.log(&quot;在这个方法可以时刻获取最新的数据:type=&quot;,this.type)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法七-Vuex"><a href="#方法七-Vuex" class="headerlink" title="方法七 Vuex"></a>方法七 Vuex</h2><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://blog.csdn.net/dan_seek/article/details/102641761">vue组件传值的11种方式</a></p>]]></content>
    
    
    <summary type="html">Vue组件传值的多种传值方式</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>文本换行省略</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/</id>
    <published>2021-08-19T15:28:19.000Z</published>
    <updated>2021-09-05T16:18:23.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-将一大串文字分两行显示，超出用省略号表示"><a href="#vue-将一大串文字分两行显示，超出用省略号表示" class="headerlink" title="vue 将一大串文字分两行显示，超出用省略号表示"></a>vue 将一大串文字分两行显示，超出用省略号表示</h1><hr><p>众所周知，通过css设置文字强制不换行超出用省略号表示很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: nowrap; 文本强制不换行；</span><br><span class="line"><span class="attribute">text-overflow</span>:ellipsis; 文本溢出显示省略号；</span><br><span class="line"><span class="attribute">overflow</span>:hidden; 溢出的部分隐藏；</span><br></pre></td></tr></table></figure><p>但是如果要想显示两行，超出用省略号表示要怎么写呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure><p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。<br>常见结合属性：<br>1，display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。<br>2，-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。<br>3，text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;a href=&quot;#vue-将一大串文字分两行显示，超出用省略号表示&quot; class=&quot;headerlink&quot; title=&quot;vue 将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;/a&gt;vue 将一大串文字分两行显</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
</feed>
