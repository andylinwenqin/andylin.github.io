<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andylin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/d2d617c7604cf8dda9f78dd0f6fa3899</icon>
  <subtitle>永无止境，奋斗不息</subtitle>
  <link href="https://andylinwenqin.github.io/atom.xml" rel="self"/>
  
  <link href="https://andylinwenqin.github.io/"/>
  <updated>2021-08-19T16:24:26.881Z</updated>
  <id>https://andylinwenqin.github.io/</id>
  
  <author>
    <name>林文钦</name>
    <email>andylin0119@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue组件传值</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2021-08-19T15:31:21.000Z</published>
    <updated>2021-08-19T16:24:26.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue组件传值"><a href="#Vue组件传值" class="headerlink" title="Vue组件传值"></a>Vue组件传值</h1><hr><p>先看一张总结图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210820002412.png"></p><h2 id="方法一-父组件向子组件传值-（props传参）"><a href="#方法一-父组件向子组件传值-（props传参）" class="headerlink" title="方法一 父组件向子组件传值 （props传参）"></a>方法一 父组件向子组件传值 （props传参）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son</span><br><span class="line">      str=&quot;字符串&quot;</span><br><span class="line">      :num=&quot;5&quot;</span><br><span class="line">      :obj=&quot;&#123; name: &#x27;对象信息&#x27; &#125;&quot;</span><br><span class="line">      :func=&quot;() =&gt; &#123;this.list()&#125;&quot;</span><br><span class="line">      :arr=&quot;arr&quot;</span><br><span class="line">    &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        arr: [1, 2, 3],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      list() &#123;</span><br><span class="line">        console.log(&#x27;list&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      arr: Array, //定义参数类型</span><br><span class="line">      num: Number,</span><br><span class="line">      str: String,</span><br><span class="line">      str2: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;默认是字符串&#x27;, //定义默认值</span><br><span class="line">      &#125;,</span><br><span class="line">      func: &#123;</span><br><span class="line">        type: Function,</span><br><span class="line">        require: false, // 定义参数是否必须值</span><br><span class="line">      &#125;,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        require: false,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(this.str) //字符串</span><br><span class="line">      console.log(this.str2) //默认字符串</span><br><span class="line">      console.log(this.num) //5</span><br><span class="line">      console.log(this.arr) //[1,2,3]</span><br><span class="line">      console.log(this.func()) // list</span><br><span class="line">      console.log(this.obj) // name:&#x27;对象信息&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法二-子组件向父组件传值-（事件传递）"><a href="#方法二-子组件向父组件传值-（事件传递）" class="headerlink" title="方法二 子组件向父组件传值 （事件传递）"></a>方法二 子组件向父组件传值 （事件传递）</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son @func=&quot;speak&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">    methods: &#123;</span><br><span class="line">      speak(msg) &#123;</span><br><span class="line">        console.log(msg) //我是子组件发送的消息</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      this.$emit(&#x27;func&#x27;, &#x27;我是子组件发送的消息！&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法三-事件监听"><a href="#方法三-事件监听" class="headerlink" title="方法三 事件监听"></a>方法三 事件监听</h2><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Son ref=&quot;son&quot; &gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Father&#x27;,</span><br><span class="line">    components: &#123; Son &#125;,</span><br><span class="line">   </span><br><span class="line">   mounted() &#123;</span><br><span class="line">     this.$refs[&#x27;son&#x27;].$on(&#x27;func&#x27;,(msg)=&gt;&#123;</span><br><span class="line">         console.log(msg);  //我是子组件传递的消息</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是子组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Son&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$emit(&#x27;func&#x27;, &#x27;我是子组件传递的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法四-消息发布与订阅"><a href="#方法四-消息发布与订阅" class="headerlink" title="方法四 消息发布与订阅"></a>方法四 消息发布与订阅</h2><p>安装pubsub-js插件:  npm install pubsub-js -s //可实现全局参数传递</p><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        pubsub.publishSync(&#x27;sendMsg&#x27;, &#x27;这是A组件发布的消息！&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是B组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;B&#x27;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      pubsub.subscribe(&#x27;sendMsg&#x27;, (e, msg) =&gt; &#123;</span><br><span class="line">        console.log(e, msg) //sendMsg 这是A组件发布的消息！</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>publishSync 同步发送消息</li><li>publish  同步发送消息</li><li>subscribe 订阅消息</li><li>unsubscribe 卸载特定订阅消息</li><li>clearAllSubscriptions 清除所有订阅消息</li></ul><h2 id="方法五-非父子组件传值-（EventBus传参）"><a href="#方法五-非父子组件传值-（EventBus传参）" class="headerlink" title="方法五 非父子组件传值 （EventBus传参）"></a>方法五 非父子组件传值 （EventBus传参）</h2><p>在main.js中挂载全局EventBus</p><blockquote><p>1.Vue.prototype.$EventBus = new Vue()</p></blockquote><p><strong>组件A</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是A组件&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg&quot;&gt;send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Son from &#x27;./son&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsg() &#123;</span><br><span class="line">        this.$EventBus.$emit(&#x27;sendMsg&#x27;,&#x27;这是A组件发送的消息！&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件</strong>B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是组件B&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;B&quot;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            this.$EventBus.$on(&#x27;sendMsg&#x27;,(msg)=&gt;&#123;</span><br><span class="line">                console.log(msg);//这是组件A发送的消息！</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过挂载全局Vue对象传递参数</p><h2 id="方法六-路由间传值"><a href="#方法六-路由间传值" class="headerlink" title="方法六 路由间传值"></a>方法六 路由间传值</h2><h3 id="i-使用问号传值"><a href="#i-使用问号传值" class="headerlink" title="i.使用问号传值"></a>i.使用问号传值</h3><p>A页面跳转B页面时使用 this.$router.push(’/B?name=danseek’)</p><p>B页面可以使用 this.$route.query.name 来获取A页面传过来的值</p><p>上面要注意router和route的区别</p><h3 id="ii-使用冒号传值"><a href="#ii-使用冒号传值" class="headerlink" title="ii.使用冒号传值"></a>ii.使用冒号传值</h3><p>配置如下路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/b/:name&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;../views/B.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>在B页面可以通过 this.$route.params.name 来获取路由传入的name的值</p><h3 id="iii-使用父子组件传值"><a href="#iii-使用父子组件传值" class="headerlink" title="iii.使用父子组件传值"></a>iii.使用父子组件传值</h3><p>由于router-view本身也是一个组件，所以我们也可以使用父子组件传值方式传值，然后在对应的子页面里加上props，因为type更新后没有刷新路由，所以不能直接在子页面的mounted钩子里直接获取最新type的值，而要使用watch。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :type=&quot;type&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 子页面</span><br><span class="line">......</span><br><span class="line">props: [&#x27;type&#x27;]</span><br><span class="line">......</span><br><span class="line">watch: &#123;</span><br><span class="line">    type()&#123;</span><br><span class="line">    // console.log(&quot;在这个方法可以时刻获取最新的数据:type=&quot;,this.type)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法七-Vuex"><a href="#方法七-Vuex" class="headerlink" title="方法七 Vuex"></a>方法七 Vuex</h2><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://blog.csdn.net/dan_seek/article/details/102641761">vue组件传值的11种方式</a></p>]]></content>
    
    
    <summary type="html">Vue组件传值的多种传值方式</summary>
    
    
    
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>文本换行省略</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/</id>
    <published>2021-08-19T15:28:19.000Z</published>
    <updated>2021-08-19T15:30:57.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-将一大串文字分两行显示，超出用省略号表示"><a href="#vue-将一大串文字分两行显示，超出用省略号表示" class="headerlink" title="vue 将一大串文字分两行显示，超出用省略号表示"></a>vue 将一大串文字分两行显示，超出用省略号表示</h1><hr><p>众所周知，通过css设置文字强制不换行超出用省略号表示很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: nowrap; 文本强制不换行；</span><br><span class="line"><span class="attribute">text-overflow</span>:ellipsis; 文本溢出显示省略号；</span><br><span class="line"><span class="attribute">overflow</span>:hidden; 溢出的部分隐藏；</span><br></pre></td></tr></table></figure><p>但是如果要想显示两行，超出用省略号表示要怎么写呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure><p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。<br>常见结合属性：<br>1，display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。<br>2，-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。<br>3，text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;a href=&quot;#vue-将一大串文字分两行显示，超出用省略号表示&quot; class=&quot;headerlink&quot; title=&quot;vue 将一大串文字分两行显示，超出用省略号表示&quot;&gt;&lt;/a&gt;vue 将一大串文字分两行显</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>flex布局设置单个元素靠右</title>
    <link href="https://andylinwenqin.github.io/2021/08/19/flex%E5%B8%83%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9D%A0%E5%8F%B3/"/>
    <id>https://andylinwenqin.github.io/2021/08/19/flex%E5%B8%83%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9D%A0%E5%8F%B3/</id>
    <published>2021-08-19T12:45:02.000Z</published>
    <updated>2021-08-19T15:26:40.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flex布局设置单个元素靠右"><a href="#flex布局设置单个元素靠右" class="headerlink" title="flex布局设置单个元素靠右"></a>flex布局设置单个元素靠右</h1><h2 id="父元素布局"><a href="#父元素布局" class="headerlink" title="父元素布局"></a>父元素布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br></pre></td></tr></table></figure><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: auto;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flex布局设置单个元素靠右&quot;&gt;&lt;a href=&quot;#flex布局设置单个元素靠右&quot; class=&quot;headerlink&quot; title=&quot;flex布局设置单个元素靠右&quot;&gt;&lt;/a&gt;flex布局设置单个元素靠右&lt;/h1&gt;&lt;h2 id=&quot;父元素布局&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>下拉刷新 触底刷新</title>
    <link href="https://andylinwenqin.github.io/2021/08/10/Vue%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%20%E8%A7%A6%E5%BA%95%E5%88%B7%E6%96%B0/"/>
    <id>https://andylinwenqin.github.io/2021/08/10/Vue%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%20%E8%A7%A6%E5%BA%95%E5%88%B7%E6%96%B0/</id>
    <published>2021-08-10T13:34:26.000Z</published>
    <updated>2021-08-19T15:25:02.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下拉刷新-触底刷新"><a href="#下拉刷新-触底刷新" class="headerlink" title="下拉刷新 触底刷新"></a>下拉刷新 触底刷新</h1><hr><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>下拉刷新和上拉加载这两种交互方式通常出现在移动端中</p><p>本质上等同于PC网页中的分页，只是交互形式不同</p><p>开源社区也有很多优秀的解决方案，如<code>iscroll</code>、<code>better-scroll</code>、<code>pulltorefresh.js</code>库等等</p><p>这些第三方库使用起来非常便捷</p><p>我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>上拉加载及下拉刷新都依赖于用户交互</p><p>最重要的是要理解在什么场景，什么时机下触发交互动作</p><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>首先可以看一张图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210819203252.png"></p><p>上拉加载的本质是页面触底，或者快要触底时的动作</p><p>判断页面触底我们需要先了解一下下面几个属性</p><ul><li><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</li><li><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</li><li><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</li></ul><p>综上我们得出一个触底公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollTop + clientHeight &gt;= scrollHeight</span><br></pre></td></tr></table></figure><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clientHeight  = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">//浏览器高度</span></span><br><span class="line"><span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line"><span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">50</span>;  <span class="comment">//距离视窗还用50的时候，开始触发；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始加载数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p><p>关于下拉刷新的原生实现，主要分成三步：</p><ul><li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li><li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li><li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li></ul><p>举个例子：</p><p><code>Html</code>结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refreshText&quot;</span>&gt;</span>&lt;/p &gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;refreshContainer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>555<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ...</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>监听<code>touchstart</code>事件，记录初始的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refreshContainer&#x27;</span>),</span><br><span class="line">    _refreshText = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.refreshText&#x27;</span>),</span><br><span class="line">    _startPos = <span class="number">0</span>,  <span class="comment">// 初始的值</span></span><br><span class="line">    _transitionHeight = <span class="number">0</span>; <span class="comment">// 移动的距离</span></span><br><span class="line"></span><br><span class="line">_element.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    _startPos = e.touches[<span class="number">0</span>].pageY; <span class="comment">// 记录初始位置</span></span><br><span class="line">    _element.style.position = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">    _element.style.transition = <span class="string">&#x27;transform 0s&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>监听<code>touchmove</code>移动事件，记录滑动差值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_element.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// e.touches[0].pageY 当前位置</span></span><br><span class="line">    _transitionHeight = e.touches[<span class="number">0</span>].pageY - _startPos; <span class="comment">// 记录差值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">0</span> &amp;&amp; _transitionHeight &lt; <span class="number">60</span>) &#123; </span><br><span class="line">        _refreshText.innerText = <span class="string">&#x27;下拉刷新&#x27;</span>; </span><br><span class="line">        _element.style.transform = <span class="string">&#x27;translateY(&#x27;</span>+_transitionHeight+<span class="string">&#x27;px)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">55</span>) &#123;</span><br><span class="line">            _refreshText.innerText = <span class="string">&#x27;释放更新&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>最后，就是监听<code>touchend</code>离开的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_element.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    _element.style.transition = <span class="string">&#x27;transform 0.5s ease 1s&#x27;</span>;</span><br><span class="line">    _element.style.transform = <span class="string">&#x27;translateY(0px)&#x27;</span>;</span><br><span class="line">    _refreshText.innerText = <span class="string">&#x27;更新中...&#x27;</span>;</span><br><span class="line">    <span class="comment">// todo...</span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p><ul><li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</li><li>下拉到一定值时，显示松手释放后的操作提示</li><li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</li></ul><h3 id="触底刷新"><a href="#触底刷新" class="headerlink" title="触底刷新"></a>触底刷新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">containerHeight</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">innerHeight</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">scrollBottom</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.innerHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">        <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">        <span class="comment">// console.log(&quot;触发&quot;,scrollTop,this.containerHeight,this.innerHeight)</span></span><br><span class="line">        <span class="keyword">if</span> (scrollTop + <span class="built_in">this</span>.containerHeight &gt;= <span class="built_in">this</span>.innerHeight - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;触底了&#x27;);</span></span><br><span class="line">            <span class="built_in">this</span>.heightListInit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.containerHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="built_in">this</span>.innerHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="built_in">this</span>.scrollBottom);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下拉刷新-触底刷新&quot;&gt;&lt;a href=&quot;#下拉刷新-触底刷新&quot; class=&quot;headerlink&quot; title=&quot;下拉刷新 触底刷新&quot;&gt;&lt;/a&gt;下拉刷新 触底刷新&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>声网视频和音频的学习</title>
    <link href="https://andylinwenqin.github.io/2021/08/09/%E5%A3%B0%E7%BD%91%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://andylinwenqin.github.io/2021/08/09/%E5%A3%B0%E7%BD%91%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-09T15:20:23.000Z</published>
    <updated>2021-08-09T16:23:08.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="声网"><a href="#声网" class="headerlink" title="声网"></a><a href="https://www.agora.io/cn">声网</a></h1><hr><h2 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h2><p>Agora 互动直播（Interactive Live Streaming Premium）可以实现一对多，多对多的音视频互动直播。</p><p>Agora 互动直播不同于视频通话。视频通话不区分主播和观众，所有用户都可以发言并看见彼此；互动直播的用户分为主播和观众，只有主播可以自由发言，且被其他用户看见。详见<a href="https://docs.agora.io/cn/faq/profile_difference">通信和直播场景有什么区别</a>。</p><h2 id="加入和离开频道"><a href="#加入和离开频道" class="headerlink" title="加入和离开频道"></a>加入和离开频道</h2><p>Agora Web SDK 使用 [AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象来管理一个本地用户在目标频道内的行为。在加入目标频道之前，你需要先创建一个 <code>AgoraRTCClient</code> 对象。</p><h3 id="创建-AgoraRTCClient-对象"><a href="#创建-AgoraRTCClient-对象" class="headerlink" title="创建 AgoraRTCClient 对象"></a>创建 AgoraRTCClient 对象</h3><p>调用 [AgoraRTC.createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 即可创建 <code>AgoraRTCClient</code> 对象。在创建 <code>AgoraRTCClient</code> 时，你需要指定使用的编码格式（<code>codec</code>）以及频道场景（<code>mode</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = AgoraRTC.createClient(&#123;</span><br><span class="line">  <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="选择视频编码格式"><a href="#选择视频编码格式" class="headerlink" title="选择视频编码格式"></a>选择视频编码格式</h3><p><code>codec</code> 设置支持 <code>&quot;vp8&quot;</code>（VP8）和 <code>&quot;h264&quot;</code>（H.264）两种视频编码格式。该设置只会影响发布端的视频编码格式，对于订阅端来说只要其支持该格式的解码，都能正常完成订阅。</p><p>举例来说，桌面端 Chrome 58 及以上版本既支持 VP8 也支持 H.264，而 Safari 12.1 以下版本不支持 VP8 编解码；如果频道中有两个主播分别发布了 VP8 和 H.264 的视频流，使用桌面端 Chrome 58 的观众可以解码这两个主播的视频，使用 Safari 12.1 以下版本浏览器的观众只能解码 H.264 的视频流。</p><p>不同浏览器和不同设备对这两种编解码格式支持都不同。下表列出不同浏览器所支持的编解码格式作为参考：</p><table><thead><tr><th align="left">浏览器</th><th align="left">VP8</th><th align="left">H.264</th></tr></thead><tbody><tr><td align="left">桌面端 Chrome 58+</td><td align="left">✔</td><td align="left">✔</td></tr><tr><td align="left">Firefox 56+</td><td align="left">✔</td><td align="left">✔*</td></tr><tr><td align="left">Safari 12.1+</td><td align="left">✔</td><td align="left">✔</td></tr><tr><td align="left">Safari &lt; 12.1</td><td align="left">✘</td><td align="left">✔</td></tr><tr><td align="left">Android Chrome 58+</td><td align="left">✔</td><td align="left">?*</td></tr></tbody></table><h3 id="选择频道场景"><a href="#选择频道场景" class="headerlink" title="选择频道场景"></a>选择频道场景</h3><p>频道场景（<code>mode</code>）是 Agora 为了对不同的实时音视频场景进行针对性算法优化而提供的一种设置选项。SDK 支持两种频道场景：<code>&quot;rtc&quot;</code>（通信场景） 和 <code>&quot;live&quot;</code>（直播场景）。</p><p><strong>通信场景</strong></p><p><code>&quot;rtc&quot;</code>（通信场景）适用于频道内所有用户需要相互交流且用户总数不太多的场景，如多人会议和在线聊天。</p><p><strong>直播场景</strong></p><p><code>&quot;live&quot;</code>（直播场景）适用于发布端很少但是订阅端很多的场景，这种场景下 SDK 定义了两种用户角色：观众（默认）和主播。主播能够发送和接收音视频，观众不能发送、只能接收音视频。你可以通过设置 <code>createClient</code> 的 [role](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/clientconfig.html#role) 参数来指定用户角色，也可以调用 [setClientRole](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#setclientrole) 来动态修改用户角色。</p><h3 id="加入频道"><a href="#加入频道" class="headerlink" title="加入频道"></a>加入频道</h3><p>创建 <code>AgoraRTCClient</code> 对象后，就可以调用 [AgoraRTCClient.join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 加入频道。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>注意 <code>join</code> 方法的第四个参数 <code>uid</code> 的设置。不传入任何值时，Agora 会为这个加入的本地用户自动分配一个 Number 型的用户 ID 作为其唯一的身份标识。你也可以通过该参数自行指定一个 Number 型的用户 ID。</p><p>请确保频道内用户 ID 的唯一性。Agora 建议你在业务层面避免用户使用相同的 ID 加入一个频道。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动分配数字 UID</span></span><br><span class="line"><span class="keyword">const</span> uid = <span class="keyword">await</span> client.join(<span class="string">&quot;APPID&quot;</span>, <span class="string">&quot;CHANNEL&quot;</span>, <span class="string">&quot;TOKEN&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数字 UID</span></span><br><span class="line"><span class="keyword">await</span> client.join(<span class="string">&quot;APPID&quot;</span>, <span class="string">&quot;CHANNEL&quot;</span>, <span class="string">&quot;TOKEN&quot;</span>, <span class="number">393939</span>);</span><br></pre></td></tr></table></figure><h3 id="离开频道"><a href="#离开频道" class="headerlink" title="离开频道"></a>离开频道</h3><p>调用 [AgoraRTCClient.leave](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave) 可以离开当前频道。该方法可以在任何时候调用，包括正在加入频道时或者正在重连时。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>调用 <code>leave</code> 后，SDK 会立刻销毁与当前频道相关的对象，包括订阅的远端用户对象、远端轨道对象、记录连接状态的对象等。如果需要再次加入频道，在调用 <code>leave</code> 后再调用 <code>join</code> 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> client.leave();</span><br></pre></td></tr></table></figure><h3 id="频道内的连接状态"><a href="#频道内的连接状态" class="headerlink" title="频道内的连接状态"></a>频道内的连接状态</h3><p>详见[频道连接状态管理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/channel_connection_web_ng?platform=Web)。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在加入频道的过程中，因为 SDK 使用不当或者网络异常等原因，可能会抛出以下错误：</p><ul><li><code>INVALID_PARAMS</code>: 提供的参数错误，比如提供了格式非法的 Token。</li><li><code>INVALID_OPERATION</code>: 非法操作。该错误通常是重复加入频道引起的，请确保重复加入时先调用 <code>leave</code>。</li><li><code>OPERATION_ABORTED</code>: 加入被中止，表示在 <code>join</code> 方法成功之前就调用了 <code>leave</code> 方法。</li><li><code>UNEXPECTED_RESPONSE</code>: Agora 服务器返回了非预期的响应，通常是因为 App ID 或 Token 鉴权失败，例如开启了 App 证书却未传入 Token。</li><li><code>UID_CONFLICT</code>: 创建了多个 <code>AgoraRTCClient</code> 对象，且重复使用了同一个用户 ID。</li></ul><h2 id="创建本地轨道对象"><a href="#创建本地轨道对象" class="headerlink" title="创建本地轨道对象"></a>创建本地轨道对象</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。</p><p>本文详细介绍如何使用 Agora Web SDK 创建本地的音视频轨道对象。</p><p>在介绍具体的 API 之前，你需要了解本地轨道对象的一些设计细节。Agora Web SDK 使用了面向对象的设计模式，使用 [LocalTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html) 这一个基础的抽象类来描述所有的本地轨道对象，它定义了本地轨道对象的公共方法和行为，所有的本地轨道对象都继承于 <code>LocalTrack</code>。</p><p><code>publish</code> 方法只要求发布的对象是 <code>LocalTrack</code> ，所以无论通过什么方式创建的本地轨道对象，都满足 <code>publish</code> 方法的参数要求。</p><p>基于 <code>LocalTrack</code>，SDK 定义了 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 和 [LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html)，分别代表本地音频轨道对象和本地视频轨道对象。这两个类分别针对音视频不同的特性增加了不同的方法，比如 <code>LocalAudioTrack</code> 增加了获取和控制音量的方法、<code>LocalVideoTrack</code> 增加了设置美颜功能的方法。</p><p>最后，根据不同的应用场景和创建方式， SDK 基于 <code>LocalAudioTrack</code> 和 <code>LocalVideoTrack</code> 提供了更上层的本地轨道类。比如继承自 <code>LocalVideoTrack</code> 的 <code>CameraVideoTrack</code>，这个类表明这个本地视频轨道是来自于摄像头采集的视频，所以这个类增加了控制摄像头、调整分辨率等方法。</p><p>下图展示了这几个类之间的关系：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210809235859.png"></p><h3 id="创建轨道"><a href="#创建轨道" class="headerlink" title="创建轨道"></a>创建轨道</h3><p>SDK 支持通过以下方式创建本地轨道对象。</p><h3 id="使用麦克风和摄像头"><a href="#使用麦克风和摄像头" class="headerlink" title="使用麦克风和摄像头"></a>使用麦克风和摄像头</h3><p>最常用的方法是直接通过麦克风或者摄像头采集的音视频来创建本地轨道对象，SDK 提供了三种方法：</p><ul><li>[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)：使用摄像头采集的视频来创建本地视频轨道，返回一个 [CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 对象。</li><li>[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)：使用麦克风采集的音频来创建本地音频轨道，返回一个 [MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 对象。</li><li>[createMicrophoneAndCameraTracks](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks)：同时使用麦克风和摄像头采集的音视频创建本地轨道，返回一个包含 [CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 和 [MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 的列表。</li></ul><p>如果使用 <code>createMicrophoneAndCameraTracks</code> 创建本地轨道，因为音频和视频采集是一次完成的，所以只要摄像头和麦克风其中一个无法完成采集就会导致整个采集的失败，SDK 会抛出错误，详见[错误处理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/create_local_track_web_ng?platform=Web#error)。如果分别调用 <code>createCameraVideoTrack</code> 和 <code>createMicrophoneAudioTrack</code> ，其中一个采集失败不会影响另外一个。请根据你的实际需求选用合适的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采集摄像头</span></span><br><span class="line"><span class="keyword">const</span> cameraTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采集麦克风</span></span><br><span class="line"><span class="keyword">const</span> microphoneTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时采集摄像头和麦克风</span></span><br><span class="line"><span class="keyword">const</span> [microphoneTrack, cameraTrack] = <span class="keyword">await</span> AgoraRTC.createMicrophoneAndCameraTracks();</span><br></pre></td></tr></table></figure><p>调用以上方法时你可以传入一个配置参数来控制采集的行为，详细的参数定义可以参考 [CameraVideoTrackInitConfig](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/cameravideotrackinitconfig.html) 或者 [MicrophoneAudioTrackInitConfig](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/microphoneaudiotrackinitconfig.html)。</p><p>以上方法均为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><h3 id="使用屏幕画面"><a href="#使用屏幕画面" class="headerlink" title="使用屏幕画面"></a>使用屏幕画面</h3><p>SDK 提供 [createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 方法来创建屏幕共享轨道，这个方法会返回 <code>LocalVideoTrack</code> 对象。由于 <code>LocalVideoTrack</code> 只实现了视频轨道对象的基础方法，因此通过屏幕创建的轨道无法像摄像头轨道那样控制分辨率或切换设备。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> screenTrack = <span class="keyword">await</span> AgoraRTC.createScreenVideoTrack();</span><br></pre></td></tr></table></figure><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>如果你需要在 Electron 或较老版本的 Chrome 上使用屏幕共享，或者希望在共享屏幕的同时分享音频，可以参考[屏幕共享](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/screensharing_web_ng)。</p><h3 id="使用本地或在线的音频文件"><a href="#使用本地或在线的音频文件" class="headerlink" title="使用本地或在线的音频文件"></a>使用本地或在线的音频文件</h3><p>SDK 提供 [createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 方法来通过本地或者在线的音频文件创建本地音频轨道对象。通过该方法创建的对象类型为 <code>BufferSourceAudioTrack</code>，该对象继承自 <code>LocalAudioTrack</code>，在其基础上增加了控制音频文件播放行为的方法，比如暂停播放、跳转播放、循环播放等。</p><p>你可以使用这个方法实现混音或者播放音效的功能，详见[播放音效/混音](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/audio_effect_mixing_web_ng)。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioFileTrack = <span class="keyword">await</span> AgoraRTC.createBufferSourceAudioTrack(&#123;</span><br><span class="line">  <span class="attr">source</span>: <span class="string">&quot;https://web-demos-static.agora.io/agora/smlt.flac&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在播放之前先调用该方法读取音频文件</span></span><br><span class="line">audioFileTrack.startProcessAudioBuffer();</span><br><span class="line"></span><br><span class="line">audioFileTrack.play();</span><br></pre></td></tr></table></figure><h3 id="使用自定义方式"><a href="#使用自定义方式" class="headerlink" title="使用自定义方式"></a>使用自定义方式</h3><p>如果你熟悉 WebRTC 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack">MediaStreamTrack</a> 相关的 API，你可以通过自己实现采集来完成 <code>MediaStreamTrack</code> 的创建，然后通过 [createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 或者 [createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 方法将 <code>MediaStreamTrack</code> 对象转换成 SDK 内部的 <code>LocalAudioTrack</code> 或者 <code>LocalVideoTrack</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过自己实现采集获取 `MediaStreamTrack` 对象</span></span><br><span class="line"><span class="keyword">const</span> customMediaStreamTrack = getMediaStreamTrackFromXXX(<span class="comment">/* .. */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义的视频轨道</span></span><br><span class="line"><span class="keyword">const</span> customTrack = AgoraRTC.createCustomVideoTrack(&#123;</span><br><span class="line">  <span class="attr">mediaStreamTrack</span>: customMediaStreamTrack,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="启用和禁用本地轨道"><a href="#启用和禁用本地轨道" class="headerlink" title="启用和禁用本地轨道"></a>启用和禁用本地轨道</h3><p>创建好本地的轨道对象后，如果想要暂时关闭麦克风或摄像头，你可以禁用该轨道。SDK 提供 [LocalTrack.setEnabled](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 方法来启用或者禁用本地轨道对象。</p><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p><p>调用 <code>setEnabled(true)</code> 禁用本地轨道后，该轨道会停止本地播放。如果该轨道已经发布，发布也会停止，此时远端会收到 <code>user-unpublished</code> 回调；调用 <code>setEnabled(true)</code> 后，SDK 会自动重新发布轨道。</p><p>根据本地轨道类型的不同，调用 <code>setEnabled</code> 后会有一些不同的行为：</p><ul><li>通过设备采集创建的本地轨道（<code>CameraVideoTrack</code>/<code>MicrophoneAudioTrack</code>）：当调用 <code>setEnabled(false)</code> 后，会停止采集并释放其占用的设备。如果摄像头或麦克风有指示灯，此时指示灯会熄灭。当调用 <code>setEnabled(true)</code> 后，会自动恢复采集。</li><li>通过其他方式创建的本地轨道：当调用 <code>setEnabled(false)</code> 后，会默认编码黑屏帧（视频轨道）或者静音包（音频轨道）。当调用 <code>setEnabled(true)</code> 后，会自动恢复正常编码。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> videoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时关闭摄像头采集</span></span><br><span class="line"><span class="keyword">await</span> videoTrack.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复摄像头采集</span></span><br><span class="line"><span class="keyword">await</span> videoTrack.setEnabled(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>在创建本地音视频对象的过程中，由于不同设备和浏览器之间的差异，SDK 可能在调用上述方法时抛出异常。以下是调用创建轨道的方法时可能会遇到的错误：</p><ul><li><code>NOT_SUPPORTED</code>: 使用的功能在当前浏览器上不支持。</li><li><code>MEDIA_OPTION_INVALID</code>: 指定的采集参数无法被满足，一般是因为设备不支持指定的分辨率或帧率。</li><li><code>DEVICE_NOT_FOUND</code>: 找不到指定的采集设备。</li><li><code>PERMISSION_DENIED</code>: 用户拒绝授予访问摄像头/麦克风的权限，或者屏幕共享选择共享源时，用户没有选择共享源，并关闭了选择窗口。</li><li><code>CONSTRAINT_NOT_SATISFIED</code>: 浏览器不支持指定的采集选项。</li><li><code>SHARE_AUDIO_NOT_ALLOWED</code>: 屏幕共享分享音频时用户没有勾选<strong>分享音频</strong>。</li></ul><h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。</p><p>本文详细介绍如何使用 Agora Web SDK 发布和取消发布本地音视频，以及订阅和取消订阅远端音视频。</p><h3 id="发布音视频"><a href="#发布音视频" class="headerlink" title="发布音视频"></a>发布音视频</h3><p>完成本地轨道的创建并且成功加入频道后，就可以调用 [AgoraRTCClient.publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish) 将本地的音视频数据发布到当前频道，以供频道中的其他用户订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localAudioTrack = ...;</span><br><span class="line"><span class="keyword">const</span> localVideoTrack = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以多次调用 publish 发布多个轨道</span></span><br><span class="line"><span class="keyword">await</span> client.publish(localAudioTrack);</span><br><span class="line"><span class="keyword">await</span> client.publish(localVideoTrack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次性将需要发布的轨道一起发布</span></span><br><span class="line"><span class="keyword">await</span> client.publish([localAudioTrack, localVideoTrack]);</span><br></pre></td></tr></table></figure><p>关于发布，注意事项如下：</p><ul><li><p>同一时间只能发布一个视频轨道。</p></li><li><p>可以同时发布多个音频轨道，SDK 会自动混音。</p><blockquote><p>Safari 12 之前的版本不支持混音，无法使用此特性。</p></blockquote></li><li><p>可以多次调用该方法来发布不同的轨道，但是不能重复发布同一个轨道对象。</p></li><li><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</p></li></ul><h3 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h3><p>在发布过程中，可能因为网络环境或者 SDK 使用不当抛出以下错误：</p><ul><li><code>INVALID_OPERATION</code>: 非法操作，说明在加入频道成功之前就调用了 <code>publish</code> 方法。</li><li><code>OPERATION_ABORTED</code>: 发布被中止，可能是因为在发布成功之前就主动调用 <code>leave</code> 离开了频道。</li><li><code>INVALID_LOCAL_TRACK</code>: 参数错误，传入了非法的 <code>LocalTrack</code> 对象。</li><li><code>CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS</code>: 不允许同时发布多个视频轨道。</li><li><code>NOT_SUPPORTED</code>: 发布了多个音频轨道，但是浏览器不支持混音。</li><li><code>UNEXPECTED_RESPONSE</code>: 收到了 Agora 服务器异常的返回，发布轨道失败。建议保留日志，联系 Agora <a href="https://agora-ticket.agora.io/">技术支持</a>。</li><li><code>NO_ICE_CANDIDATE</code>: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 <a href="https://docs.agora.io/cn/faq/console_error_web#none-ice-candidate-not-alloweda-namecandidatea">FAQ</a>。</li></ul><h3 id="取消发布音视频"><a href="#取消发布音视频" class="headerlink" title="取消发布音视频"></a>取消发布音视频</h3><p>成功发布本地轨道后，如果想取消发布，可以调用 [AgoraRTCClient.unpublish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布音视频</span></span><br><span class="line"><span class="keyword">await</span> client.publish([localAudioTrack, localVideoTrack]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消发布视频，此时音频还在正常发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish(localVideoTrack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次将所有正在发布的轨道全部取消发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish();</span><br><span class="line"><span class="comment">// 或者批量取消发布</span></span><br><span class="line"><span class="keyword">await</span> client.unpublish([localAudioTrack, localVideoTrack]);</span><br></pre></td></tr></table></figure><p>关于取消发布，注意事项如下：</p><ul><li>该方法可以多次调用。你可以使用 <code>publish</code> 和 <code>unpublish</code> 实现发布和取消发布某个本地轨道。</li><li>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</li></ul><h3 id="订阅音视频"><a href="#订阅音视频" class="headerlink" title="订阅音视频"></a>订阅音视频</h3><p>当远端用户成功发布音视频轨道之后，SDK 会触发 [user-published](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件。这个事件携带两个参数：远端用户对象（<code>user</code>）和远端发布的媒体类型（<code>mediaType</code>）。此时，你可以调用 [AgoraRTCClient.subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 发起订阅。</p><blockquote><p>该方法为异步方法，使用时需要配合 <code>Promise</code> 或者 <code>async/await</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 发起订阅</span></span><br><span class="line">  <span class="keyword">await</span> client.subscribe(user, mediaType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果订阅的是音频轨道</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> audioTrack = user.audioTrack;</span><br><span class="line">    <span class="comment">// 自动播放音频</span></span><br><span class="line">    audioTrack.play();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> videoTrack = user.videoTrack;</span><br><span class="line">    <span class="comment">// 自动播放视频</span></span><br><span class="line">    videoTrack.play(DOM_ELEMENT);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当订阅方法调用完成之后，你可以通过 <code>user.audioTrack</code> 和 <code>user.videoTrack</code> 获取相应的 [RemoteAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 和 [RemoteVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。</p><p>订阅和发布不同，每次订阅只能订阅一个音频或视频轨道。即使发布端同时发布了音频轨道和视频轨道，SDK 也会触发两次 <code>user-published</code> 事件：一次 <code>user-published(audio)</code>，一次 <code>user-published(video)</code>。按照上面的代码逻辑，会完成两次订阅。</p><h3 id="处理-Autoplay-问题"><a href="#处理-Autoplay-问题" class="headerlink" title="处理 Autoplay 问题"></a>处理 Autoplay 问题</h3><p>详见[处理浏览器的自动播放策略](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/autoplay_policy_web_ng)。</p><h3 id="错误处理-3"><a href="#错误处理-3" class="headerlink" title="错误处理"></a>错误处理</h3><p>在订阅过程中，因为网络环境等因素 SDK 可能抛出如下错误：</p><ul><li><code>INVALID_OPERATION</code>: 非法操作，可能在加入频道成功之前就调用了 <code>subscribe</code>。</li><li><code>INVALID_REMOTE_USER</code>: 传入了非法的远端用户对象，例如该用户不在频道内。</li><li><code>REMOTE_USER_IS_NOT_PUBLISHED</code>：传入的远端用户没有发布 <code>subscribe</code> 方法中传入的媒体类型。</li><li><code>UNEXPECTED_RESPONSE</code>: 收到了 Agora 服务器异常的返回，订阅失败。建议保留日志，联系 Agora <a href="https://agora-ticket.agora.io/">技术支持</a>。</li><li><code>OPERATION_ABORTED</code>: 操作中止，可能在订阅成功之前就调用 <code>leave</code> 离开了频道。</li><li><code>NO_ICE_CANDIDATE</code>: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 <a href="https://docs.agora.io/cn/faq/console_error_web#none-ice-candidate-not-alloweda-namecandidatea">FAQ</a>。</li></ul><h3 id="取消订阅音视频"><a href="#取消订阅音视频" class="headerlink" title="取消订阅音视频"></a>取消订阅音视频</h3><p>你可以通过 [AgoraRTCClient.unsubscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe) 取消订阅远端的音视频。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅目标用户的音视频</span></span><br><span class="line"><span class="keyword">await</span> client.subscribe(user, <span class="string">&quot;audio&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> client.subscribe(user, <span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅视频</span></span><br><span class="line"><span class="keyword">await</span> client.unsubscribe(user, <span class="string">&quot;video&quot;</span>);</span><br><span class="line"><span class="comment">// 也可以取消订阅当前用户的所有媒体类型</span></span><br><span class="line"><span class="keyword">await</span> client.unsubscribe(user);</span><br></pre></td></tr></table></figure><p>关于取消订阅，注意事项如下：</p><ul><li>取消订阅成功后，SDK 会释放相应的 <code>RemoteTrack</code> 对象。一旦远端轨道对象被释放，SDK 会自动移除视频的播放元素，音频播放也会停止。</li><li>如果远端用户主动取消发布，本地会收到 <code>user-unpublished</code> 回调，收到该回调时 SDK 会自动释放相应的 <code>RemoteTrack</code> 对象，你无需再调用 <code>unsubscribe</code>。</li><li>该方法为异步方法，使用时需要配合 <code>Promise</code> 或 <code>async/await</code>。</li></ul><h2 id="api文档参考"><a href="#api文档参考" class="headerlink" title="api文档参考"></a>api文档参考</h2><p>Agora Web SDK 是通过 HTML 网页加载的 JavaScript 和 Typescript 库。你可以使用 Agora Web SDK 在网页浏览器中调用 API 建立连接，控制音视频通话和直播服务。</p><blockquote><p>请务必使用 HTTPS 协议或者 localhost，否则 SDK 无法正常工作。</p></blockquote><p>[全局模块](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#全局模块)</p><p>[AgoraRTC](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html) 是 Agora Web SDK 中所有可调用方法的入口，主要包含以下方法。</p><p>[核心方法](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#核心方法)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient)</td><td align="left">创建本地客户端</td></tr></tbody></table><p>[本地音视频采集](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地音视频采集)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)</td><td align="left">通过麦克风创建一个音频轨道对象</td></tr><tr><td align="left">[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)</td><td align="left">通过摄像头创建一个视频轨道对象</td></tr><tr><td align="left">[createMicrophoneAndCameraTracks](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks)</td><td align="left">同时创建麦克风音频轨道和摄像头视频轨道</td></tr><tr><td align="left">[createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack)</td><td align="left">通过屏幕共享创建一个视频轨道对象</td></tr><tr><td align="left">[createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack)</td><td align="left">通过音频文件创建一个音频轨道对象</td></tr><tr><td align="left">[createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack)</td><td align="left">创建一个自定义的音频轨道对象</td></tr><tr><td align="left">[createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack)</td><td align="left">创建一个自定义的视频轨道对象</td></tr></tbody></table><p>[媒体设备查询](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#媒体设备查询)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[getDevices](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getdevices)</td><td align="left">获取媒体设备列表</td></tr><tr><td align="left">[getCameras](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getcameras)</td><td align="left">获取摄像头列表</td></tr><tr><td align="left">[getMicrophones](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getmicrophones)</td><td align="left">获取麦克风列表</td></tr><tr><td align="left">[getPlaybackDevices](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getplaybackdevices)</td><td align="left">获取音频播放设备列表</td></tr><tr><td align="left">[getElectronScreenSources](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getelectronscreensources)</td><td align="left">获取 Electron 屏幕共享源列表</td></tr></tbody></table><p>[日志管理](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#日志管理)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[enableLogUpload](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#enablelogupload)</td><td align="left">打开日志上传功能</td></tr><tr><td align="left">[disableLogUpload](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#disablelogupload)</td><td align="left">关闭日志上传功能</td></tr><tr><td align="left">[setLogLevel](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#setloglevel)</td><td align="left">设置日志等级</td></tr></tbody></table><p>[全局事件回调](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#全局事件回调)</p><table><thead><tr><th align="left">回调</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[onCameraChanged](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#oncamerachanged)</td><td align="left">视频采集设备状态变化回调</td></tr><tr><td align="left">[onMicrophoneChanged](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onmicrophonechanged)</td><td align="left">音频采集设备状态变化回调</td></tr><tr><td align="left">[onAudioAutoplayFailed](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onaudioautoplayfailed)</td><td align="left">音频轨道自动播放失败回调</td></tr></tbody></table><p>[其他](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#其他)</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[checkSystemRequirements](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#checksystemrequirements)</td><td align="left">检测浏览器兼容性</td></tr><tr><td align="left">[getSupportedCodec](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getsupportedcodec)</td><td align="left">获取支持的编码格式</td></tr><tr><td align="left">[createChannelMediaRelayConfiguration](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createchannelmediarelayconfiguration)</td><td align="left">创建跨频道媒体流转发的配置对象</td></tr></tbody></table><h3 id="AgoraRTCClient-类"><a href="#AgoraRTCClient-类" class="headerlink" title="AgoraRTCClient 类"></a>AgoraRTCClient 类</h3><p>调用 [createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 创建一个本地客户端对象 [AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html)，代表一个通话中的本地用户。<code>AgoraRTCClient</code> 类提供音视频通话的核心功能，主要包含以下方法。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join)</td><td align="left">加入频道</td></tr><tr><td align="left">[leave](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave)</td><td align="left">离开频道</td></tr><tr><td align="left">[publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish)</td><td align="left">发布本地音视频轨道</td></tr><tr><td align="left">[unpublish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish)</td><td align="left">取消发布本地音视频轨道</td></tr><tr><td align="left">[subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe)</td><td align="left">订阅远端用户的音视频轨道</td></tr><tr><td align="left">[unsubscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe)</td><td align="left">取消订阅远端用户的音视频轨道</td></tr></tbody></table><h3 id="LocalTrack-类"><a href="#LocalTrack-类" class="headerlink" title="LocalTrack 类"></a>LocalTrack 类</h3><p><code>LocalTrack</code> 是 Agora Web SDK 中定义本地音视频轨道的抽象类，可用于本地播放和发布。</p><p>SDK 通过不同的方式创建不同的 <code>LocalTrack</code>，返回不同的 <code>LocalTrack</code> 派生类对象。以下列举了所有的 <code>LocalTrack</code> 派生类以及所对应的创建方式。</p><p>[本地音频轨道](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地音频轨道)</p><p>根据创建方式的不同，本地音频轨道可分为以下三种。其中 <code>LocalAudioTrack</code> 派生自 <code>LocalTrack</code>，<code>MicrophoneAudioTrack</code> 和 <code>BufferSourceAudioTrack</code> 派生自 <code>LocalAudioTrack</code>。</p><table><thead><tr><th align="left">本地音频轨道</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html)</td><td align="left">最基础的本地音频轨道对象，包含了基础的本地音频控制，如播放、设置音量控制。 通过调用 [AgoraRTC.createCustomAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 创建。</td></tr><tr><td align="left">[MicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html)</td><td align="left">本地麦克风音频轨道对象，比 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制麦克风的方法。 通过调用 [AgoraRTC.createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack) 创建。</td></tr><tr><td align="left">[BufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ibuffersourceaudiotrack.html)</td><td align="left">通过读取音频数据源创建的本地音频轨道，比基础的 [LocalAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制音频数据源的方法。 通过调用 [AgoraRTC.createBufferSourceAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 创建。</td></tr></tbody></table><p>[本地视频轨道](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#本地视频轨道)</p><p>根据创建方式的不同，本地视频可分为以下两种。其中 <code>LocalVideoTrack</code> 派生自 <code>LocalTrack</code>，<code>CameraVideoTrack</code> 派生自 <code>LocalVideoTrack</code>。</p><table><thead><tr><th align="left">本地视频轨道</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html)</td><td align="left">最基础的本地视频轨道对象，包含了基础的本地视频控制，如播放、美颜。 通过调用 [AgoraRTC.createCustomVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 或 [AgoraRTC.createScreenVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 创建。</td></tr><tr><td align="left">[CameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html)</td><td align="left">本地摄像头视频轨道对象，比 [LocalVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html) 多一些控制摄像头和编码参数的方法。 通过调用 [AgoraRTC.createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack) 创建。</td></tr></tbody></table><h3 id="RemoteTrack-类"><a href="#RemoteTrack-类" class="headerlink" title="RemoteTrack 类"></a>RemoteTrack 类</h3><p><code>RemoteTrack</code> 是 Agora Web SDK 中用于定义远端音视频轨道的抽象类。</p><p>在实际操作中，你需要先调用 [AgoraRTCClient.subscribe](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 订阅远端用户，然后从远端用户对象 [AgoraRTCRemoteUser](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcremoteuser.html) 中获取派生自 <code>RemoteTrack</code> 的 [RemoteAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 对象和 [RemoteVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。</p><p>[引入方式](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#引入方式)</p><p>如果你通过 <code>&lt;script&gt;</code> 的方式引入 Agora Web SDK，可以通过访问 [AgoraRTC.createClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 来获取导出的模块。</p><p>如果你通过 <code>npm</code> 或者模块化的方式引入 Agora Web SDK，可以通过以下方式访问 <code>AgoraRTC</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(AgoraRTC.createClient);</span><br></pre></td></tr></table></figure><p>[类型模块（适用于 Typescript）](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#类型模块（适用于-typescript）)</p><p>对于 Typescript 开发者，我们提供了 <code>.d.ts</code> 文件导出详细的类型定义。你可以查看 API 文档的 [Global](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/globals.html) 页面，该页面列出了所有 SDK 导出的模块和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC, &#123; IAgoraRTCClient &#125; <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client: IAgoraRTCClient = AgoraRTC.createClient();</span><br></pre></td></tr></table></figure><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>SDK 可能以下列方式抛出错误码：</p><ul><li>对于异步方法，SDK 返回 Promise 来通知异步操作的结果，Promise 被 reject 时 SDK 会抛出相应的错误码。</li><li>同步方法调用失败时，SDK 直接抛出错误码。</li><li>SDK 内部运行过程中，也可能抛出一些网络相关的错误码。</li></ul><p>你可参考本文了解这些错误码的详细含义及处理方法。</p><p>[通用错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#通用错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>UNEXPECTED_ERROR</code></td><td align="left">无法处理的、非预期的错误，通常这个错误会有具体的错误提示。</td><td align="left">无</td></tr><tr><td align="left"><code>UNEXPECTED_RESPONSE</code></td><td align="left">服务端返回了非预期的响应。</td><td align="left">无</td></tr><tr><td align="left"><code>INVALID_PARAMS</code></td><td align="left">非法参数。</td><td align="left">根据具体提示确认操作，并根据文档传入正确的参数。</td></tr><tr><td align="left"><code>NOT_SUPPORTED</code></td><td align="left">浏览器不支持。</td><td align="left">参考<a href="https://agoraio-community.github.io/AgoraWebSDK-NG/docs/zh-CN/overview">浏览器支持情况</a>。</td></tr><tr><td align="left"><code>INVALID_OPERATION</code></td><td align="left">非法操作，通常是因为在当前状态不能进行该操作。</td><td align="left">确认操作的先后顺序，比如发布前请确认已经加入频道。</td></tr><tr><td align="left"><code>OPERATION_ABORTED</code></td><td align="left">操作中止，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。</td><td align="left">通过 [AgoraRTCClient.on(“user-joined”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。</td></tr><tr><td align="left"><code>WEB_SECURITY_RESTRICT</code></td><td align="left">浏览器安全策略限制。</td><td align="left">请确保 Web 页面运行在<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">安全环境</a>中。</td></tr><tr><td align="left"><code>NO_ACTIVE_STATUS</code></td><td align="left">Agora 项目未激活或被禁用。</td><td align="left">请前往 Agora 控制台确认项目状态是否为启用。</td></tr></tbody></table><p>[请求相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#请求相关错误码)</p><p><strong>网络连接</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>NETWORK_TIMEOUT</code></td><td align="left">请求超时，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。</td><td align="left">通过 [AgoraRTCClient.on(“user-joined”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。</td></tr><tr><td align="left"><code>NETWORK_RESPONSE_ERROR</code></td><td align="left">响应错误，一般是状态码非法。</td><td align="left">确认操作的参数是否正确，并根据文档传入正确的参数。</td></tr><tr><td align="left"><code>NETWORK_ERROR</code></td><td align="left">无法定位的网络错误。</td><td align="left">无</td></tr></tbody></table><p><strong>SDK 内部请求</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>WS_ABORT</code></td><td align="left">请求 Agora 服务器过程中 WebSocket 断开。</td><td align="left">监听 [AgoraRTCClient.on(“connection-state-change”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 <strong>CONNECTED</strong> 后重试。</td></tr><tr><td align="left"><code>WS_DISCONNECT</code></td><td align="left">请求 Agora 服务器前，WebSocket 就已经断开。</td><td align="left">监听 [AgoraRTCClient.on(“connection-state-change”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 <strong>CONNECTED</strong> 后重试。</td></tr><tr><td align="left"><code>WS_ERR</code></td><td align="left">WebSocket 连接发生错误。</td><td align="left">检查当前浏览器对 WebSocket 的支持情况。</td></tr></tbody></table><p>[设备管理相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#设备管理相关错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>ENUMERATE_DEVICES_FAILED</code></td><td align="left">枚举本地设备失败，一般是由于浏览器限制。</td><td align="left">无</td></tr><tr><td align="left"><code>DEVICE_NOT_FOUND</code></td><td align="left">无法找到指定设备。</td><td align="left">传入正确的设备 ID。</td></tr></tbody></table><p>[Track 相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#track-相关错误码)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>TRACK_IS_DISABLED</code></td><td align="left">轨道被禁用，通常因为轨道设置了 [Track.setEnabled(false)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled)。</td><td align="left">对该轨道调用 [Track.setEnabled(true)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 后再进行操作。</td></tr><tr><td align="left"><code>SHARE_AUDIO_NOT_ALLOWED</code></td><td align="left">屏幕共享音频时终端用户没有点击<strong>分享音频</strong>。</td><td align="left">要求终端用户在弹出的屏幕共享窗口中勾选<strong>分享音频</strong>。</td></tr><tr><td align="left"><code>CHROME_PLUGIN_NO_RESPONSE</code></td><td align="left">Chrome 屏幕共享插件无响应。</td><td align="left">确认 [Chrome 屏幕共享插件](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/chrome_screensharing_plugin)的状态或重新安装屏幕共享插件。</td></tr><tr><td align="left"><code>CHROME_PLUGIN_NOT_INSTALL</code></td><td align="left">Chrome 屏幕共享插件没有安装。</td><td align="left">安装 [Chrome 屏幕共享插件](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/chrome_screensharing_plugin)。</td></tr><tr><td align="left"><code>MEDIA_OPTION_INVALID</code></td><td align="left">不支持的媒体采集的参数。</td><td align="left">修改媒体采集参数或使用 SDK 预设的配置。</td></tr><tr><td align="left"><code>CONSTRAINT_NOT_SATISFIED</code></td><td align="left">不支持的媒体采集的参数。</td><td align="left">修改媒体采集参数或使用 SDK 预设的配置。</td></tr><tr><td align="left"><code>PERMISSION_DENIED</code></td><td align="left">获取媒体设备权限被拒绝。</td><td align="left">在弹出的获取设备权限窗口中选择<strong>允许</strong>。</td></tr><tr><td align="left"><code>FETCH_AUDIO_FILE_FAILED</code></td><td align="left">下载在线音频文件失败。</td><td align="left">填入正确的在线音频地址，并确保可以正常访问。</td></tr><tr><td align="left"><code>READ_LOCAL_AUDIO_FILE_ERROR</code></td><td align="left">读取本地音频文件失败。</td><td align="left">填入正确的本地音频文件路径。</td></tr><tr><td align="left"><code>DECODE_AUDIO_FILE_FAILED</code></td><td align="left">音频文件解码失败，可能是因为音频文件的编码格式是浏览器 WebAudio 不支持的编码格式。</td><td align="left">检查浏览器 WebAudio 是否支持音频文件的编码格式。</td></tr></tbody></table><p>[Client 相关错误码](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#client-相关错误码)</p><p><strong>加入频道</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>UID_CONFLICT</code></td><td align="left">同一个频道内 UID 重复。</td><td align="left">使用不同的 UID 进入频道。</td></tr><tr><td align="left"><code>INVALID_UINT_UID_FROM_STRING_UID</code></td><td align="left">String UID 分配服务返回了非法的 int UID。</td><td align="left">使用不同的 UID 进入频道。</td></tr><tr><td align="left"><code>CAN_NOT_GET_PROXY_SERVER</code></td><td align="left">无法获取云代理服务地址。</td><td align="left">无</td></tr><tr><td align="left"><code>CAN_NOT_GET_GATEWAY_SERVER</code></td><td align="left">无法获取 Agora 服务器地址。</td><td align="left">无</td></tr></tbody></table><p><strong>发布/取消发布</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>INVALID_LOCAL_TRACK</code></td><td align="left">传入了非法的 LocalTrack。</td><td align="left">检查传入的 Track，并传入正确的 LocalTrack。</td></tr><tr><td align="left"><code>CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS</code></td><td align="left">一个 Client 发布多个视频轨道。</td><td align="left">一个 Client 同一时间只能发布一个视频轨道，如果想发布多个视频轨道请创建多个 Client。</td></tr></tbody></table><p><strong>订阅/取消订阅</strong></p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>INVALID_REMOTE_USER</code></td><td align="left">非法的远端用户，可能是远端用户不在频道内或还未发布任何媒体轨道。</td><td align="left">收到 [AgoraRTCClient.on(“user-published”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件后再进行订阅操作。</td></tr><tr><td align="left"><code>REMOTE_USER_IS_NOT_PUBLISHED</code></td><td align="left">远端用户已发布了音频或视频轨道，但不是与你的订阅操作所指定的类型不符。</td><td align="left">请确保订阅操作传入的轨道类型需要与 [AgoraRTCClient.on(“user-published”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published)) 事件给出的类型一致，或者在订阅前通过 [AgoraRTCRemoteUser.hasVideo]{@link AgoraRTCRemoteUser.hasVideo} 和 [AgoraRTCRemoteUser.hasAudio]{@link AgoraRTCRemoteUser.hasAudio} 确认远端用户是否发布了该类型的轨道。</td></tr></tbody></table><p>[推流到 CDN](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#推流到-cdn)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th><th align="left">处理方法</th></tr></thead><tbody><tr><td align="left"><code>LIVE_STREAMING_TASK_CONFLICT</code></td><td align="left">推流任务已经存在。</td><td align="left">先调用 [Client.stopLiveStreaming](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#stoplivestreaming) 停止该推流任务再重新进行推流操作。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INVALID_ARGUMENT</code></td><td align="left">推流参数错误。</td><td align="left">参考 [Client.startLiveStreaming](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#startlivestreaming) 的 API 文档检查推流操作的参数。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INTERNAL_SERVER_ERROR</code></td><td align="left">推流服务器内部错误。</td><td align="left">重新进行推流操作，如果仍然失败，刷新页面重试。</td></tr><tr><td align="left"><code>LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED</code></td><td align="left">推流 URL 被占用。</td><td align="left">检查填入的 URL 是否被占用。</td></tr><tr><td align="left"><code>LIVE_STREAMING_CDN_ERROR</code></td><td align="left">推流的目标 CDN 出现错误导致推流失败。</td><td align="left">确认目标 CDN 的健康状况。</td></tr><tr><td align="left"><code>LIVE_STREAMING_INVALID_RAW_STREAM</code></td><td align="left">推流超时。</td><td align="left">确认目标流是否存在。</td></tr></tbody></table><p>[跨频道连麦](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/index.html#跨频道连麦)</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>CROSS_CHANNEL_WAIT_STATUS_ERROR</code></td><td align="left">等待 [AgoraRTCClient.on(“channel-media-relay-state”)](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_channel_media_relay_state) 回调出错。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_JOIN_SRC</code></td><td align="left">发起跨频道转发媒体流请求失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_JOIN_DEST</code></td><td align="left">接受跨频道转发媒体流请求失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST</code></td><td align="left">服务器接收跨频道转发媒体流失败。</td></tr><tr><td align="left"><code>CROSS_CHANNEL_SERVER_ERROR_RESPONSE</code></td><td align="left">服务器响应出错。</td></tr></tbody></table><h2 id="官方实例"><a href="#官方实例" class="headerlink" title="官方实例"></a>官方实例</h2><p>本文仅适用于 Agora Web SDK 4.x 版本。如果你使用的是 3.x 或之前版本，请查看以下文档：</p><p>[跑通视频直播示例项目](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_live_web?platform=Web)</p><p>[实现音频直播](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/start_live_audio_web?platform=Web)</p><p>[实现视频直播](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/start_live_web?platform=Web)</p><p>根据本文指导快速集成 Agora Web SDK 并在你自己的 app 里实现实时音视频直播。</p><blockquote><p>由于浏览器的安全策略对除 127.0.0.1 以外的 HTTP 地址作了限制，Agora Web SDK 仅支持 HTTPS 协议或者 <code>http://localhost</code>（<code>http://127.0.0.1</code>）。请勿使用 HTTP 协议在 <code>http://localhost</code>（<code>http://127.0.0.1</code>） 之外访问你的项目。</p></blockquote><h3 id="开源示例项目"><a href="#开源示例项目" class="headerlink" title="开源示例项目"></a>开源示例项目</h3><p>我们在 GitHub 上提供一个开源的<a href="https://github.com/AgoraIO/API-Examples-Web">示例项目</a>供你参考。</p><p>同时，你可以通过我们的<a href="https://webdemo.agora.io/agora-websdk-api-example-4.x/">在线 Web 应用</a>快速体验 Agora 实现的音视频相关功能。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>可以连接到互联网的 Windows 或 macOS 计算机。如果你的网络环境部署了防火墙，请参考[应用企业防火墙限制](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/firewall?platform=Web)以正常使用 Agora 服务。</li><li>计算机搭载 2.2 GHz Intel 第二代 i3/i5/i7 处理器或同等性能的其他处理器。</li><li>物理音视频采集设备，如内置摄像头和麦克风。</li><li>安装最新稳定版 <a href="https://www.google.cn/chrome/">Chrome 浏览器</a>。</li><li>有效的 Agora [开发者账号](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/sign_in_and_sign_up?platform=Web)。</li></ul><h3 id="获取-SDK"><a href="#获取-SDK" class="headerlink" title="获取 SDK"></a>获取 SDK</h3><p>选择如下任意一种方法获取 Agora Web SDK：</p><h4 id="方法-1-使用-npm-获取-SDK"><a href="#方法-1-使用-npm-获取-SDK" class="headerlink" title="方法 1. 使用 npm 获取 SDK"></a>方法 1. 使用 npm 获取 SDK</h4><p>使用该方法需要先安装 npm，详见 <a href="https://www.npmjs.com.cn/getting-started/installing-node/">npm 快速入门</a>。</p><ol><li><p>运行安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install agora-rtc-sdk-ng --save</span><br></pre></td></tr></table></figure></li><li><p>在你的项目的 JavaScript 代码中加入以下代码，引入这个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"><span class="keyword">const</span> client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>如果你使用 TypeScript, 还可以引入 SDK 中的类型对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTC, &#123; IAgoraRTCClient &#125; <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"><span class="keyword">const</span> client: IAgoraRTCClient = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="方法-2-使用-CDN-方法获取-SDK"><a href="#方法-2-使用-CDN-方法获取-SDK" class="headerlink" title="方法 2. 使用 CDN 方法获取 SDK"></a>方法 2. 使用 CDN 方法获取 SDK</h4><p>该方法无需下载安装包。在项目 HTML 文件中，添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://download.agora.io/sdk/release/AgoraRTC_N-4.6.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方法-3-手动下载-SDK"><a href="#方法-3-手动下载-SDK" class="headerlink" title="方法 3. 手动下载 SDK"></a>方法 3. 手动下载 SDK</h4><ol><li><p>[下载](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/downloads?platform=Web) Agora Web SDK 4.x 版本 SDK 包。</p></li><li><p>将下载下来的 <code>.js</code> 文件保存到项目文件所在的目录下。</p></li><li><p>在项目文件中，将如下代码添加到 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./AgoraRTC_N-4.6.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>在方法 2 和方法 3 中，SDK 都会在全局导出一个 <code>AgoraRTC</code> 对象，直接访问这个对象即可操作 SDK。</li><li>在我们的示例项目中，为方便起见，我们选择第二种方法，直接使用 CDN 链接。</li></ul></blockquote><p>现在，我们已经将 Agora Web SDK 集成到项目中了。下一步我们要调用 Agora Web SDK 提供的核心 API。</p><h3 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h3><p>在使用 Agora Web SDK 时，你会经常用到以下三种对象：</p><ul><li>[AgoraRTCClient](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象，代表一个本地客户端。<code>AgoraRTCClient</code> 类的方法提供了音视频通话的主要功能，例如加入频道、发布音视频轨道等。</li><li>[LocalTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 对象和 [RemoteTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iremotetrack.html) 对象，代表本地和远端的音视频轨道对象，用于播放等音视频相关的控制。</li></ul><blockquote><p>音视频流由音视频轨道构成。在 Agora Web SDK 中，我们通过操作音视频轨道对象来控制音视频流的行为。</p></blockquote><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>一次简单的音视频直播的步骤一般如下：</p><ol><li>根据项目的 App ID 创建一个本地客户端 <code>AgoraRTCClient</code> 对象，</li><li>调用 <code>AgoraRTCClient.setClientRole</code> 设置用户角色。</li><li>通过 <code>AgoraRTCClient.join</code> 加入到一个指定的频道中。</li><li>通过麦克风采集的音频创建一个 <code>MicrophoneAudioTrack</code> 对象（本地音频轨道对象）；通过摄像头采集的视频创建一个 <code>CameraVideoTrack</code> 对象（本地视频轨道对象）。</li><li>通过 <code>AgoraRTCClient.publish</code> 将创建的本地音视频轨道对象发布到频道中。</li></ol><p>当有其他用户加入频道并且也发布音视频轨道时：</p><ol><li>SDK 会触发 <code>client.on(&quot;user-published&quot;)</code> 事件，在这个事件回调函数的参数中你可以拿到远端用户对象 <code>AgoraRTCRemoteUser</code>，表示这个用户刚刚发布了音视频轨道。</li><li>通过 <code>AgoraRTCClient.subscribe</code> 订阅获取到的 <code>AgoraRTCRemoteUser</code>。</li><li>订阅完成后，访问 <code>AgoraRTCRemoteUser.audioTrack</code> 和 <code>AgoraRTCRemoteUser.videoTrack</code> 即可获取到 <code>RemoteAudioTrack</code>（远端音频轨道对象）和 <code>RemoteVideoTrack</code>（远端视频轨道对象）。</li></ol><p>下图展示了基础的音视频直播的 API 调用。注意图中的方法是对不同的对象调用的。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210810000548.png"></p><p>为方便起见，我们预定义了两个变量和一个函数，下面的所有示例代码都包裹在这个函数中。此步骤不是必须的，你可以根据你的项目有其他的实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rtc = &#123;</span><br><span class="line">  <span class="comment">// 用来放置本地客户端。</span></span><br><span class="line">  <span class="attr">client</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 用来放置本地音视频频轨道对象。</span></span><br><span class="line">  <span class="attr">localAudioTrack</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">localVideoTrack</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="comment">// 替换成你自己项目的 App ID。</span></span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&quot;&lt;YOUR APP ID&gt;&quot;</span>,</span><br><span class="line">  <span class="comment">// 传入目标频道名。</span></span><br><span class="line">  <span class="attr">channel</span>: <span class="string">&quot;demo_channel_name&quot;</span>,</span><br><span class="line">  <span class="comment">// 如果你的项目开启了 App 证书进行 Token 鉴权，这里填写生成的 Token 值。</span></span><br><span class="line">  <span class="attr">token</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 设置频道内的用户角色，可设为 &quot;audience&quot; 或 &quot;host&quot;</span></span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;audience&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBasicLive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接下来的代码写在这里。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startBasicLive();</span><br></pre></td></tr></table></figure><h4 id="1-创建本地客户端"><a href="#1-创建本地客户端" class="headerlink" title="1. 创建本地客户端"></a>1. 创建本地客户端</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtc.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;live&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>调用 <code>createClient</code> 方法创建本地客户端对象。需注意 <code>mode</code> 和 <code>codec</code> 这两个参数的设置：</p><ul><li><p><code>mode</code> 用于设置[频道场景](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/terms?platform=All Platforms#channel-profile)。Agora Web SDK 会根据使用场景的不同实行不同的优化策略。</p><ul><li>一对一或多人通话中，建议设为 <code>&quot;rtc&quot;</code>，使用通信场景。</li><li>互动直播中，建议设为 <code>&quot;live&quot;</code>，使用直播场景。</li></ul></li><li><p><code>codec</code> 用于设置浏览器使用的编解码格式。如果你需要使用 Safari 12.1 及之前版本，将该参数设为 <code>&quot;h264&quot;</code>；其他情况我们推荐使用 <code>&quot;vp8&quot;</code>。</p></li></ul><h4 id="2-设置用户角色"><a href="#2-设置用户角色" class="headerlink" title="2. 设置用户角色"></a>2. 设置用户角色</h4><p>直播频道有两种用户角色：主播和观众，默认的角色为观众。直播频道内的用户，只能看到主播的画面、听到主播的声音。</p><p>设置频道场景为直播后，你可以调用 <code>setClientRole</code> 方法设置用户角色。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role 的值可以是 &quot;host&quot; 或者 &quot;audience&quot;。</span></span><br><span class="line">client.setClientRole(options.role);</span><br></pre></td></tr></table></figure><p>加入频道后，如果你想切换用户角色，也可以调用 <code>setClientRole</code> 方法。</p><h4 id="3-加入目标频道"><a href="#3-加入目标频道" class="headerlink" title="3. 加入目标频道"></a>3. 加入目标频道</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uid = <span class="keyword">await</span> rtc.client.join(options.appId, options.channel, options.token, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>调用 <code>join</code> 加入目标频道。该方法返回一个 <code>Promise</code>，当返回 <code>resolve</code> 时表示加入频道成功，返回 <code>reject</code> 时表示加入频道出现错误。我们可以利用 <code>async/await</code> 极大地简化我们的代码。</p><p>调用 <code>join</code> 方法时你需要注意以下参数：</p><ul><li><p><code>appid</code>: 你的 App ID。详见[创建 Agora 项目](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_video_call_web?platform=Web##1-创建-agora-项目)和[获取 App ID](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/run_demo_video_call_web?platform=Web#appid)。</p></li><li><p><code>channel</code>: 频道名，长度在 64 字节以内的字符串。在我们的示例项目中，<code>channel</code> 的值设为 <code>demo_channel_name</code>。</p></li><li><p><code>token</code>: （可选）如果你的 Agora 项目开启了 App 证书，你需要在该参数中传入一个 Token，详见[使用 Token](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/token?platform=All Platforms#使用-token)。</p><ul><li><p>在测试环境，我们推荐使用控制台生成临时 Token，详见[获取临时 Token](<a href="https://docs.agora.io/cn/Agora">https://docs.agora.io/cn/Agora</a> Platform/token?platform=All Platforms%23get-a-temporary-token#获取临时-token)。</p></li><li><p>在生产环境，我们推荐你在自己的服务端生成 Token，详见</p><p>生成 Token</p><blockquote><p>在我们的示例项目中，为了叙述方便，没有开启 App 证书，所以不需要校验 Token，<code>token</code> 的值为 <code>null</code>。如果你启用了 App 证书，请确保上面传入的 <code>channel</code> 值和生成 Token 时传入的 <code>channel</code> 值保持一致。</p></blockquote></li></ul></li><li><p><code>uid</code>：用户 ID，频道内每个用户的 UID 必须是唯一的。你可以填 <code>null</code>，Agora 会自动分配一个 UID 并在 <code>join</code> 的结果中返回。</p></li></ul><p>更多的 API 介绍和注意事项请参考 [AgoraRTCClient.join](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 接口中的参数描述。</p><h4 id="4-创建并发布本地音视频轨道"><a href="#4-创建并发布本地音视频轨道" class="headerlink" title="4. 创建并发布本地音视频轨道"></a>4. 创建并发布本地音视频轨道</h4><p>当用户角色设为主播时，成功加入频道后，就可以创建并发布本地音视频轨道了。</p><p>如果用户角色设为观众，跳过该步骤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过麦克风采集的音频创建本地音频轨道对象。</span></span><br><span class="line">rtc.localAudioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line"><span class="comment">// 通过摄像头采集的视频创建本地视频轨道对象。</span></span><br><span class="line">rtc.localVideoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line"><span class="comment">// 将这些音视频轨道对象发布到频道中。</span></span><br><span class="line"><span class="keyword">await</span> rtc.client.publish([rtc.localAudioTrack, rtc.localVideoTrack]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;publish success!&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们先调用 <code>createMicrophoneAudioTrack</code> 通过麦克风采集的音频创建本地音频轨道对象，调用 <code>createCameraVideoTrack</code> 通过摄像头采集的视频创建本地视频轨道对象；然后调用 <code>publish</code> 方法，将这些本地音视频轨道对象当作参数即可将音视频发布到频道中。</p><blockquote><ul><li>以上方法都会返回 <code>Promise</code>，<code>resolve</code> 时代表成功，<code>reject</code> 时代表失败。我们使用 <code>async/await</code> 来让代码逻辑更清晰。</li><li>由于加入频道和创建本地音视频轨道没有依赖关系，你可以利用 <code>Promise.all</code> 同时执行这些异步操作。</li></ul></blockquote><p>详细的参数设置（如采集设备和编码参数）请参考相关 API 文档：</p><ul><li>[createMicrophoneAudioTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)</li><li>[createCameraVideoTrack](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)</li><li>[publish](<a href="https://docs.agora.io/cn/Interactive">https://docs.agora.io/cn/Interactive</a> Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish)</li></ul><h4 id="5-订阅远端用户"><a href="#5-订阅远端用户" class="headerlink" title="5. 订阅远端用户"></a>5. 订阅远端用户</h4><p>当远端用户发布音视频轨道时，SDK 会触发 <code>client.on(&quot;user-published&quot;)</code> 事件。我们需要通过 <code>client.on</code> 监听该事件并在回调中订阅新加入的远端用户。</p><blockquote><p>我们建议<strong>在创建客户端对象之后立即监听事件</strong>，以避免错过任何事件。放在这里介绍是因为叙述顺序。</p></blockquote><p>在 <code>createClient</code> 后下一行插入以下代码，监听 <code>client.on(&quot;user-published&quot;)</code> 事件，当有远端用户发布时开始订阅，并在订阅后自动播放远端音视频轨道对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">rtc.client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 开始订阅远端用户。</span></span><br><span class="line">  <span class="keyword">await</span> rtc.client.subscribe(user, mediaType);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;subscribe success&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示本次订阅的是视频。</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅完成后，从 `user` 中获取远端视频轨道对象。</span></span><br><span class="line">    <span class="keyword">const</span> remoteVideoTrack = user.videoTrack;</span><br><span class="line">    <span class="comment">// 动态插入一个 DIV 节点作为播放远端视频轨道的容器。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="comment">// 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">    playerContainer.id = user.uid.toString();</span><br><span class="line">    playerContainer.style.width = <span class="string">&quot;640px&quot;</span>;</span><br><span class="line">    playerContainer.style.height = <span class="string">&quot;480px&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.append(playerContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅完成，播放远端音视频。</span></span><br><span class="line">    <span class="comment">// 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。</span></span><br><span class="line">    remoteVideoTrack.play(playerContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以只传入该 DIV 节点的 ID。</span></span><br><span class="line">    <span class="comment">// remoteVideoTrack.play(playerContainer.id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示本次订阅的是音频。</span></span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅完成后，从 `user` 中获取远端音频轨道对象。</span></span><br><span class="line">    <span class="keyword">const</span> remoteAudioTrack = user.audioTrack;</span><br><span class="line">    <span class="comment">// 播放音频因为不会有画面，不需要提供 DOM 元素的信息。</span></span><br><span class="line">    remoteAudioTrack.play();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你需要注意 <code>user-published</code> 事件的第二个参数 <code>mediaType</code>, 代表远端用户当前发布的媒体类型：</p><ul><li><code>audio</code>: 远端用户发布了音频轨道。</li><li><code>video</code>: 远端用户发布了视频轨道。</li></ul><p>当远端用户取消发布或离开频道时，SDK 会触发 <code>client.on(&quot;user-unpublished&quot;)</code> 事件。此时我们需要销毁刚刚动态创建的 DIV 节点。</p><p>在刚刚监听 <code>client.on(&quot;user-published&quot;)</code> 事件的代码下一行插入以下代码，监听 <code>client.on(&quot;user-unpublished&quot;)</code> 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rtc.client.on(<span class="string">&quot;user-unpublished&quot;</span>, <span class="function">(<span class="params">user, mediaType</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取刚刚动态创建的 DIV 节点。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.getElementById(user.uid.toString());</span><br><span class="line">    <span class="comment">// 销毁这个节点。</span></span><br><span class="line">    playerContainer.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-离开频道"><a href="#6-离开频道" class="headerlink" title="6. 离开频道"></a>6. 离开频道</h4><p>通过以下步骤离开频道：</p><ol><li>销毁创建的本地音视频轨道，解除网页对摄像头和麦克风的访问。</li><li>手动销毁之前动态创建的 DIV 节点。</li><li>调用 <code>leave</code> 离开频道。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">leaveCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 销毁本地音视频轨道。</span></span><br><span class="line">  rtc.localAudioTrack.close();</span><br><span class="line">  rtc.localVideoTrack.close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历远端用户。</span></span><br><span class="line">  rtc.client.remoteUsers.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 销毁动态创建的 DIV 节点。</span></span><br><span class="line">    <span class="keyword">const</span> playerContainer = <span class="built_in">document</span>.getElementById(user.uid);</span><br><span class="line">    playerContainer &amp;&amp; playerContainer.remove();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开频道。</span></span><br><span class="line">  <span class="keyword">await</span> rtc.client.leave();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在不同的产品设计中，离开频道可以既不销毁本地流，也不销毁动态创建的 DIV 节点。这些操作不是必须的，根据您自己的情况调整代码。</p></blockquote><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><p>AgoraRTC_Audio.vue       js核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> AgoraRTC <span class="keyword">from</span> <span class="string">&quot;agora-rtc-sdk-ng&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;AgoraRTC_Audio&#x27;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="attr">uid</span>: &#123;</span><br><span class="line">                <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">Number</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">status</span>: &#123;</span><br><span class="line">                <span class="attr">default</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">Boolean</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">channel</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">token</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">appId</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">                <span class="attr">default</span>: <span class="string">&#x27;f4e2f949feaf400583aa1872ffeed2eb&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">videoContainerId</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">classroomRole</span>: <span class="built_in">Number</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">client</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">localAudioTrack</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">localVideoTrack</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">remoteUsers</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">localStream</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">publishStatus</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">checkDeviceTime</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">fun</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;audioinput&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;videoinput&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">deviceCheck</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;deviceCheck&#x27;</span>)</span><br><span class="line">                AgoraRTC.onMicrophoneChanged = <span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;microphone changed!&quot;</span>, info.state, info.device);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">let</span> res = &#123;</span><br><span class="line">                    <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">let</span> devices = <span class="keyword">await</span> <span class="built_in">this</span>.getDevices()</span><br><span class="line">                <span class="built_in">console</span>.log(devices)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">Object</span>.keys(devices).length)&#123;</span><br><span class="line">                    res.code = <span class="number">1</span></span><br><span class="line">                    res.msg = <span class="built_in">this</span>.GLOBAL.errorMsg.main[<span class="string">&#x27;mic device is not fount&#x27;</span>]</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> &#123;audioinput, videoinput&#125; = devices</span><br><span class="line">                    <span class="keyword">let</span> audioId = audioinput.deviceId;</span><br><span class="line">                    <span class="keyword">let</span> videoId = videoinput.deviceId;</span><br><span class="line">                    <span class="keyword">let</span> audioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack(&#123; <span class="attr">microphoneId</span>: audioId &#125;)</span><br><span class="line">                    <span class="keyword">let</span> videoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack(&#123;<span class="attr">cameraId</span>: videoId&#125;);</span><br><span class="line">                    <span class="keyword">let</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.deviceCheckAction(audioTrack, videoTrack)</span><br><span class="line">                    <span class="keyword">if</span>(!status)&#123;</span><br><span class="line">                        res.code = <span class="number">0</span></span><br><span class="line">                        res.msg = <span class="built_in">this</span>.GLOBAL.errorMsg.main[<span class="string">&#x27;have mic no volume&#x27;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">getDevices</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> devices = <span class="keyword">await</span> AgoraRTC.getDevices()</span><br><span class="line">                <span class="built_in">console</span>.log(devices)</span><br><span class="line">                devices = devices || []</span><br><span class="line">                <span class="keyword">let</span> &#123;fun&#125; = <span class="built_in">this</span></span><br><span class="line">                <span class="keyword">let</span> funDe = &#123;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> devices)&#123;</span><br><span class="line">                    <span class="keyword">let</span> &#123;kind&#125; = devices[i]</span><br><span class="line">                    <span class="keyword">if</span>(!fun[kind] || funDe[kind]) <span class="keyword">continue</span></span><br><span class="line">                    funDe[kind] = devices[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> funDe</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">deviceCheckAction</span>(<span class="params">audioTrack</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> t = <span class="built_in">this</span>.checkDeviceTime * <span class="number">1000</span></span><br><span class="line">                    <span class="keyword">let</span> num = t, status = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        num = num - <span class="number">1000</span></span><br><span class="line">                        <span class="keyword">const</span> level = audioTrack.getVolumeLevel();</span><br><span class="line">                        <span class="keyword">if</span>(level &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            status = <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;local stream audio level&quot;</span>, level);</span><br><span class="line">                        <span class="keyword">if</span>(t &lt;= <span class="number">0</span> || status)&#123;</span><br><span class="line">                            <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">                            success(<span class="literal">true</span>)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">1000</span>);</span><br><span class="line">                    <span class="built_in">this</span>.GLOBAL.timeoutGet(t).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!status) success(<span class="literal">false</span>)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> promise</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">pageInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.localAudioTrack = <span class="keyword">await</span> AgoraRTC.createMicrophoneAudioTrack();</span><br><span class="line">                <span class="built_in">this</span>.localVideoTrack = <span class="keyword">await</span> AgoraRTC.createCameraVideoTrack();</span><br><span class="line">                <span class="built_in">this</span>.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;)</span><br><span class="line">                <span class="built_in">this</span>.eventInit()</span><br><span class="line">                <span class="comment">// 订阅自己的视频</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.localVideoTrack) <span class="built_in">this</span>.localVideoTrack.play(<span class="built_in">this</span>.getVideoContainerId(&#123;<span class="attr">uid</span>: <span class="built_in">this</span>.uid&#125;))</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.join()</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.publishCon();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">pageInitS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.client = AgoraRTC.createClient(&#123; <span class="attr">mode</span>: <span class="string">&quot;rtc&quot;</span>, <span class="attr">codec</span>: <span class="string">&quot;vp8&quot;</span> &#125;)</span><br><span class="line">                <span class="built_in">this</span>.eventInit()</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.join()</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.publishCon();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">join</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.client.join(<span class="built_in">this</span>.appId, <span class="built_in">this</span>.channel, <span class="built_in">this</span>.token, <span class="built_in">this</span>.uid);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;join status&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">renewToken</span>(<span class="params">token</span>)</span>&#123;</span><br><span class="line">                token = token || <span class="built_in">this</span>.token</span><br><span class="line">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.client.renewToken(token)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">getVideoContainerId</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// let &#123;videoContainerId&#125; = this</span></span><br><span class="line">                <span class="comment">// if(videoContainerId) return videoContainerId</span></span><br><span class="line">                <span class="comment">// const playerContainer = document.createElement(&quot;div&quot;);</span></span><br><span class="line">                <span class="comment">// // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">                <span class="comment">// playerContainer.id = user.uid.toString();</span></span><br><span class="line">                <span class="comment">// playerContainer.style.width = &quot;640px&quot;;</span></span><br><span class="line">                <span class="comment">// playerContainer.style.height = &quot;480px&quot;;</span></span><br><span class="line">                <span class="comment">// document.body.append(playerContainer);</span></span><br><span class="line">                <span class="comment">// return playerContainer.id</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;user.uid&#125;</span>_user_video`</span></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">eventInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&quot;user-published&quot;</span>, <span class="keyword">async</span> (user, mediaType) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;user-published&#x27;</span>)</span><br><span class="line">                    <span class="comment">// 开始订阅远端用户。</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="built_in">this</span>.client.subscribe(user, mediaType);</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;subscribe success&quot;</span>);</span><br><span class="line">                    <span class="built_in">console</span>.log(mediaType)</span><br><span class="line">                    <span class="comment">// 表示本次订阅的是音频。</span></span><br><span class="line">                    <span class="keyword">if</span> (mediaType === <span class="string">&quot;audio&quot;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 订阅完成后，从 `user` 中获取远端音频轨道对象。</span></span><br><span class="line">                        <span class="keyword">const</span> remoteAudioTrack = user.audioTrack;</span><br><span class="line">                        <span class="comment">// 播放音频因为不会有画面，不需要提供 DOM 元素的信息。</span></span><br><span class="line">                        remoteAudioTrack.play();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 表示本次订阅的是视频。</span></span><br><span class="line">                    <span class="keyword">if</span> (mediaType === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 订阅完成后，从 `user` 中获取远端视频轨道对象。</span></span><br><span class="line">                        <span class="keyword">const</span> remoteVideoTrack = user.videoTrack;</span><br><span class="line">                        <span class="comment">// // 动态插入一个 DIV 节点作为播放远端视频轨道的容器。</span></span><br><span class="line">                        <span class="comment">// const playerContainer = document.createElement(&quot;div&quot;);</span></span><br><span class="line">                        <span class="comment">// // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。</span></span><br><span class="line">                        <span class="comment">// playerContainer.id = user.uid.toString();</span></span><br><span class="line">                        <span class="comment">// playerContainer.style.width = &quot;640px&quot;;</span></span><br><span class="line">                        <span class="comment">// playerContainer.style.height = &quot;480px&quot;;</span></span><br><span class="line">                        <span class="comment">// document.body.append(playerContainer);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// // 订阅完成，播放远端音视频。</span></span><br><span class="line">                        <span class="comment">// // 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。</span></span><br><span class="line">                        <span class="comment">// remoteVideoTrack.play(playerContainer);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// // 也可以只传入该 DIV 节点的 ID。</span></span><br><span class="line">                        <span class="keyword">let</span> id = <span class="built_in">this</span>.getVideoContainerId(user)</span><br><span class="line">                        remoteVideoTrack.play(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//远端用户或主播加入频道回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;user-joined&#x27;</span>, <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;用户加入频道&#x27;</span>)</span><br><span class="line">                    <span class="built_in">console</span>.log(user)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//远端用户离线回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;user-left&#x27;</span>, <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;用户离开频道&#x27;</span>)</span><br><span class="line">                    <span class="built_in">console</span>.log(user)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//报告频道内正在说话的远端用户及其音量的回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;volume-indicator&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(data)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//token过期回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;token-privilege-did-expire&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;token 失效&#x27;</span>)</span><br><span class="line">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;tokenInvalid&#x27;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//token 即将过期(30s)</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&quot;token-privilege-will-expire&quot;</span>, <span class="keyword">async</span> () =&gt;&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;token 即将 失效&#x27;</span>)</span><br><span class="line">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;tokenWillInvalid&#x27;</span>)</span><br><span class="line">                    <span class="comment">// await client.renewToken(token);</span></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//异常回调</span></span><br><span class="line">                <span class="built_in">this</span>.client.on(<span class="string">&#x27;exception&#x27;</span>, <span class="built_in">this</span>.handlError)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">handlError</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;agroa error&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(e)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">publishCon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.status)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.status) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">this</span>.publish()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">unpublish</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// if(!this.client || !this.publishStatus) return</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;unpublish&#x27;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.unpublish(<span class="built_in">this</span>.localAudioTrack);</span><br><span class="line">                <span class="built_in">this</span>.publishStatus = <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">publish</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// if(!this.client || this.publishStatus) return</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client) <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;publish&#x27;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.publish([<span class="built_in">this</span>.localAudioTrack, <span class="built_in">this</span>.localVideoTrack]);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;publish success!&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.publishStatus = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">leave</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">this</span>.client || !<span class="built_in">this</span>.client.leave || !<span class="built_in">this</span>.localAudioTrack || !<span class="built_in">this</span>.localAudioTrack.close) <span class="keyword">return</span></span><br><span class="line">                <span class="comment">// 销毁本地音频轨道。</span></span><br><span class="line">                <span class="built_in">this</span>.localAudioTrack.close();</span><br><span class="line">                <span class="built_in">this</span>.localVideoTrack.close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 离开频道。</span></span><br><span class="line">                <span class="keyword">await</span> <span class="built_in">this</span>.client.leave();</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="title">bannedVoiceSet</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">                status = status || <span class="built_in">this</span>.status</span><br><span class="line">                status ? <span class="built_in">this</span>.publish() : <span class="built_in">this</span>.unpublish()</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">watch</span>: &#123;</span><br><span class="line">            <span class="attr">status</span>: &#123;</span><br><span class="line">                <span class="function"><span class="title">handler</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.bannedVoiceSet(val)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>应用文件代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AgoraRTCAudioVue <span class="keyword">from</span> <span class="string">&#x27;../../components/AgoraRTC_Audio4.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">agoraInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.agoraDisabled)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;不开启语音&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&#x27;开启语音&#x27;)</span></span><br><span class="line">    <span class="keyword">let</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.deviceCheckOpen()</span><br><span class="line">    <span class="comment">// this.agoraStatus = status</span></span><br><span class="line">    <span class="comment">// if(!status) return</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.agoraToekInit()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.agoraChannelName &amp;&amp; <span class="built_in">this</span>.agoraToken)&#123;</span><br><span class="line">        <span class="comment">// 开启视频</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.classroomRole == <span class="number">0</span>)&#123;   </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.$refs[<span class="string">&#x27;AgoraRTCAudioVue&#x27;</span>].pageInit()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.$refs[<span class="string">&#x27;AgoraRTCAudioVue&#x27;</span>].pageInitS()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.micStatusSet(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在各个文件中进行带调用完成加入，发布，订阅，销毁等主要功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;声网&quot;&gt;&lt;a href=&quot;#声网&quot; class=&quot;headerlink&quot; title=&quot;声网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.agora.io/cn&quot;&gt;声网&lt;/a&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;产品概述&quot;&gt;&lt;a href=&quot;#产品概述&quot; </summary>
      
    
    
    
    
    <category term="工作积累" scheme="https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>小程序问题与解决</title>
    <link href="https://andylinwenqin.github.io/2021/07/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <id>https://andylinwenqin.github.io/2021/07/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/</id>
    <published>2021-07-25T08:54:42.000Z</published>
    <updated>2021-08-02T02:47:02.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序问题"><a href="#小程序问题" class="headerlink" title="小程序问题"></a>小程序问题</h1><hr><h2 id="小程序app-js和首页的index-js的调用顺序"><a href="#小程序app-js和首页的index-js的调用顺序" class="headerlink" title="小程序app.js和首页的index.js的调用顺序"></a>小程序app.js和首页的index.js的调用顺序</h2><p>首先一个小程序打开一定是先执行app.js中的onlaunch函数，之后才会去执行index.js中的onload函数，但是为什么我们使用wx.login时候将一些获取到的token之类的放到APP.globalData中出现，index.js获取不到信息的问题呢？</p><p>因为但凡是个请求获取，就需要时间，在onlaunch中发起了请求但是回调函数还未返回，index.js页面就开始请求，此时就有可能会出现(看那个执行快)找不到APP.globalData中的数据的问题。</p><p>这种情况最好的解决办法就是封装到app.js中，第二个函数放在第一个函数的回调中，确保数据成功拿到了在执行第二个函数。保证函数的顺序性。当然也可以用 setTimeout()强制延缓第二个函数执行时间，很不推荐这种方法。</p>]]></content>
    
    
    <summary type="html">一些在编写小程序中遇到的小问题</summary>
    
    
    
    
    <category term="小程序" scheme="https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序基础API的使用</title>
    <link href="https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80API%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80API%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-17T14:14:41.000Z</published>
    <updated>2021-07-18T11:13:36.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础API的使用"><a href="#基础API的使用" class="headerlink" title="基础API的使用"></a>基础API的使用</h1><hr><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="wx-switchTab-Object-object"><a href="#wx-switchTab-Object-object" class="headerlink" title="wx.switchTab(Object object)"></a>wx.switchTab(Object object)</h2><p>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的 tabBar 页面的路径 (代码包路径)（需在 app.json 的 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabbar">tabBar</a> 字段定义的页面），路径后不能带参数。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;tabBar&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;list&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;index&quot;</span>,</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;首页&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;other&quot;</span>,</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;其他&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.switchTab(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/index&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-reLaunch-Object-object"><a href="#wx-reLaunch-Object-object" class="headerlink" title="wx.reLaunch(Object object)"></a>wx.reLaunch(Object object)</h2><p>关闭所有页面，打开到应用内的某个页面</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的应用内页面路径 (代码包路径)，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.reLaunch(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;test?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad (option) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(option.query)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-redirectTo-Object-object"><a href="#wx-redirectTo-Object-object" class="headerlink" title="wx.redirectTo(Object object)"></a>wx.redirectTo(Object object)</h2><p>关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。</p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 <code>?</code> 分隔，参数键与参数值用 <code>=</code> 相连，不同参数用 <code>&amp;</code> 分隔；如 ‘path?key=value&amp;key2=value2’</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.redirectTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;test?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-navigateTo-Object-object"><a href="#wx-navigateTo-Object-object" class="headerlink" title="wx.navigateTo(Object object)"></a>wx.navigateTo(Object object)</h2><p>保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a> 可以返回到原页面。小程序中页面栈最多十层。</p><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 <code>?</code> 分隔，参数键与参数值用 <code>=</code> 相连，不同参数用 <code>&amp;</code> 分隔；如 ‘path?key=value&amp;key2=value2’</td></tr><tr><td align="left">events</td><td align="left">Object</td><td align="left"></td><td align="left">否</td><td align="left">页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="object-success-回调函数"><a href="#object-success-回调函数" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">eventChannel</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/EventChannel.html">EventChannel</a></td><td align="left">和被打开页面进行通信</td></tr></tbody></table><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;test?id=1&#x27;</span>,</span><br><span class="line">  <span class="attr">events</span>: &#123;</span><br><span class="line">    <span class="comment">// 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据</span></span><br><span class="line">    <span class="attr">acceptDataFromOpenedPage</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">someEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过eventChannel向被打开页面传送数据</span></span><br><span class="line">    res.eventChannel.emit(<span class="string">&#x27;acceptDataFromOpenerPage&#x27;</span>, &#123; <span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(option.query)</span><br><span class="line">    <span class="keyword">const</span> eventChannel = <span class="built_in">this</span>.getOpenerEventChannel()</span><br><span class="line">    eventChannel.emit(<span class="string">&#x27;acceptDataFromOpenedPage&#x27;</span>, &#123;<span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span>&#125;);</span><br><span class="line">    eventChannel.emit(<span class="string">&#x27;someEvent&#x27;</span>, &#123;<span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据</span></span><br><span class="line">    eventChannel.on(<span class="string">&#x27;acceptDataFromOpenerPage&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-navigateBack-Object-object"><a href="#wx-navigateBack-Object-object" class="headerlink" title="wx.navigateBack(Object object)"></a>wx.navigateBack(Object object)</h2><blockquote><p><strong>以 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#%E5%BC%82%E6%AD%A5-API-%E8%BF%94%E5%9B%9E-Promise">Promise 风格</a> 调用</strong>：支持</p><p><strong>需要页面权限</strong>：小程序不能在插件页面中调用该接口，插件也不能在小程序页面中调用该接口</p><p><strong>小程序插件</strong>：支持，需要小程序基础库版本不低于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.1.0</a></p><p>在小程序插件中使用时，只能在当前插件的页面中调用</p><p><strong>微信 Windows 版</strong>：支持</p><p><strong>微信 Mac 版</strong>：支持</p></blockquote><p>关闭当前页面，返回上一页面或多级页面。可通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html">getCurrentPages</a> 获取当前的页面栈，决定需要返回几层。</p><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">delta</td><td align="left">number</td><td align="left">1</td><td align="left">否</td><td align="left">返回的页面数，如果 delta 大于现有页面数，则返回到首页。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是A页面</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;B?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是B页面</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;C?id=1&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在C页面内 navigateBack，将返回A页面</span></span><br><span class="line">wx.navigateBack(&#123;</span><br><span class="line">  <span class="attr">delta</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><h2 id="wx-navigateToMiniProgram-Object-object"><a href="#wx-navigateToMiniProgram-Object-object" class="headerlink" title="wx.navigateToMiniProgram(Object object)"></a>wx.navigateToMiniProgram(Object object)</h2><p>打开另一个小程序</p><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">appId</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">要打开的小程序 appId</td></tr><tr><td align="left">path</td><td align="left">string</td><td align="left"></td><td align="left">否</td><td align="left">打开的页面路径，如果为空则打开首页。path 中 ? 后面的部分会成为 query，在小程序的 <code>App.onLaunch</code>、<code>App.onShow</code> 和 <code>Page.onLoad</code> 的回调函数或小游戏的 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/(wx.onShow)">wx.onShow</a> 回调函数、<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 中可以获取到 query 数据。对于小游戏，可以只传入 query 部分，来实现传参效果，如：传入 “?foo=bar”。</td></tr><tr><td align="left">extraData</td><td align="left">object</td><td align="left"></td><td align="left">否</td><td align="left">需要传递给目标小程序的数据，目标小程序可在 <code>App.onLaunch</code>，<code>App.onShow</code> 中获取到这份数据。如果跳转的是小游戏，可以在 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/(wx.onShow)">wx.onShow</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 中可以获取到这份数据数据。</td></tr><tr><td align="left">envVersion</td><td align="left">string</td><td align="left">release</td><td align="left">否</td><td align="left">要打开的小程序版本。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p><strong>object.envVersion 的合法值</strong></p><table><thead><tr><th align="left">值</th><th align="left">说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">develop</td><td align="left">开发版</td><td align="left"></td></tr><tr><td align="left">trial</td><td align="left">体验版</td><td align="left"></td></tr><tr><td align="left">release</td><td align="left">正式版</td><td align="left"></td></tr></tbody></table><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><h5 id="需要用户触发跳转"><a href="#需要用户触发跳转" class="headerlink" title="需要用户触发跳转"></a>需要用户触发跳转</h5><p>从 2.3.0 版本开始，若用户未点击小程序页面任意位置，则开发者将无法调用此接口自动跳转至其他小程序。</p><h5 id="需要用户确认跳转"><a href="#需要用户确认跳转" class="headerlink" title="需要用户确认跳转"></a>需要用户确认跳转</h5><p>从 2.3.0 版本开始，在跳转至其他小程序前，将统一增加弹窗，询问是否跳转，用户确认后才可以跳转其他小程序。如果用户点击取消，则回调 <code>fail cancel</code>。</p><h5 id="无需声明跳转名单，不限跳转数量（众测中）"><a href="#无需声明跳转名单，不限跳转数量（众测中）" class="headerlink" title="无需声明跳转名单，不限跳转数量（众测中）"></a>无需声明跳转名单，不限跳转数量（众测中）</h5><ol><li>从2020年4月24日起，使用跳转其他小程序功能将无需在全局配置中声明跳转名单，调用此接口时将不再校验所跳转的 AppID 是否在 navigateToMiniProgramAppIdList 中。</li><li>从2020年4月24日起，跳转其他小程序将不再受数量限制，使用此功能时请注意遵守运营规范。</li></ol><h3 id="运营规范"><a href="#运营规范" class="headerlink" title="运营规范"></a>运营规范</h3><p>平台将坚决打击小程序盒子等互推行为，使用此功能时请严格遵守<a href="https://developers.weixin.qq.com/miniprogram/product/#_5-10-%E4%BA%92%E6%8E%A8%E8%A1%8C%E4%B8%BA">《微信小程序平台运营规范》</a>，若发现小程序违反运营规范将被下架处理。</p><h3 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h3><ul><li>在开发者工具上调用此 API 并不会真实的跳转到另外的小程序，但是开发者工具会校验本次调用跳转是否成功。<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%94%AF%E6%8C%81">详情</a></li><li>开发者工具上支持被跳转的小程序处理接收参数的调试。<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%94%AF%E6%8C%81">详情</a></li></ul><h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateToMiniProgram(&#123;</span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;page/index/index?id=123&#x27;</span>,</span><br><span class="line">  <span class="attr">extraData</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">envVersion</span>: <span class="string">&#x27;develop&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 打开成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-navigateBackMiniProgram-Object-object"><a href="#wx-navigateBackMiniProgram-Object-object" class="headerlink" title="wx.navigateBackMiniProgram(Object object)"></a>wx.navigateBackMiniProgram(Object object)</h2><p>返回到上一个小程序。只有在当前小程序是被其他小程序打开时可以调用成功</p><p>注意：<strong>微信客户端 iOS 6.5.9，Android 6.5.10 及以上版本支持</strong></p><h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">extraData</td><td align="left">Object</td><td align="left">{}</td><td align="left">否</td><td align="left">需要返回给上一个小程序的数据，上一个小程序可在 <code>App.onShow</code> 中获取到这份数据。 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html">详情</a>。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateBackMiniProgram(&#123;</span><br><span class="line">  <span class="attr">extraData</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="wx-exitMiniProgram-Object-object"><a href="#wx-exitMiniProgram-Object-object" class="headerlink" title="wx.exitMiniProgram(Object object)"></a>wx.exitMiniProgram(Object object)</h2><p>退出当前小程序。必须有点击行为才能调用成功。</p><h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h1 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h1><h2 id="wx-setStorageSync-string-key-any-data"><a href="#wx-setStorageSync-string-key-any-data" class="headerlink" title="wx.setStorageSync(string key, any data)"></a>wx.setStorageSync(string key, any data)</h2><blockquote><p><strong>以 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#%E5%BC%82%E6%AD%A5-API-%E8%BF%94%E5%9B%9E-Promise">Promise 风格</a> 调用</strong>：支持</p><p><strong>小程序插件</strong>：支持，需要小程序基础库版本不低于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.6</a></p></blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html">wx.setStorage</a> 的同步版本</p><h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><h4 id="string-key"><a href="#string-key" class="headerlink" title="string key"></a>string key</h4><p>本地缓存中指定的 key</p><h4 id="any-data"><a href="#any-data" class="headerlink" title="any data"></a>any data</h4><p>需要存储的内容。只支持原生类型、Date、及能够通过<code>JSON.stringify</code>序列化的对象。</p><h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.setStorage(&#123;</span><br><span class="line">  <span class="attr">key</span>:<span class="string">&quot;key&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>:<span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.setStorageSync(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="wx-setStorage-Object-object"><a href="#wx-setStorage-Object-object" class="headerlink" title="wx.setStorage(Object object)"></a>wx.setStorage(Object object)</h2><blockquote><p><strong>以 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#%E5%BC%82%E6%AD%A5-API-%E8%BF%94%E5%9B%9E-Promise">Promise 风格</a> 调用</strong>：支持</p><p><strong>小程序插件</strong>：支持，需要小程序基础库版本不低于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.6</a></p></blockquote><p>将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。</p><h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">本地缓存中指定的 key</td></tr><tr><td align="left">data</td><td align="left">any</td><td align="left"></td><td align="left">是</td><td align="left">需要存储的内容。只支持原生类型、Date、及能够通过<code>JSON.stringify</code>序列化的对象。</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.setStorage(&#123;</span><br><span class="line">  <span class="attr">key</span>:<span class="string">&quot;key&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>:<span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.setStorageSync(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="wx-getStorage-Object-object"><a href="#wx-getStorage-Object-object" class="headerlink" title="wx.getStorage(Object object)"></a>wx.getStorage(Object object)</h2><p>从本地缓存中异步获取指定 key 的内容。缓存相关策略请查看 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html">存储</a>。</p><h2 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h2><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">本地缓存中指定的 key</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="object-success-回调函数-1"><a href="#object-success-回调函数-1" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">data</td><td align="left">any</td><td align="left">key对应的内容</td></tr></tbody></table><h3 id="示例代码-9"><a href="#示例代码-9" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.getStorage(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;key&#x27;</span>,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> value = wx.getStorageSync(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="comment">// Do something with return value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Do something when catch error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wx-getStorageInfo-Object-object"><a href="#wx-getStorageInfo-Object-object" class="headerlink" title="wx.getStorageInfo(Object object)"></a>wx.getStorageInfo(Object object)</h2><p>异步获取当前storage的相关信息。缓存相关策略请查看 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html">存储</a>。</p><h3 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="object-success-回调函数-2"><a href="#object-success-回调函数-2" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">keys</td><td align="left">Array.<string></td><td align="left">当前 storage 中所有的 key</td></tr><tr><td align="left">currentSize</td><td align="left">number</td><td align="left">当前占用的空间大小, 单位 KB</td></tr><tr><td align="left">limitSize</td><td align="left">number</td><td align="left">限制的空间大小，单位 KB</td></tr></tbody></table><h3 id="示例代码-10"><a href="#示例代码-10" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.getStorageInfo(&#123;</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.keys)</span><br><span class="line">    <span class="built_in">console</span>.log(res.currentSize)</span><br><span class="line">    <span class="built_in">console</span>.log(res.limitSize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = wx.getStorageInfoSync()</span><br><span class="line">  <span class="built_in">console</span>.log(res.keys)</span><br><span class="line">  <span class="built_in">console</span>.log(res.currentSize)</span><br><span class="line">  <span class="built_in">console</span>.log(res.limitSize)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Do something when catch error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wx-clearStorage-Object-object"><a href="#wx-clearStorage-Object-object" class="headerlink" title="wx.clearStorage(Object object)"></a>wx.clearStorage(Object object)</h2><p>清理本地数据缓存。缓存相关策略请查看 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html">存储</a>。</p><h3 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="示例代码-11"><a href="#示例代码-11" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.clearStorage()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.clearStorageSync()</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// Do something when catch error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础API的使用&quot;&gt;&lt;a href=&quot;#基础API的使用&quot; class=&quot;headerlink&quot; title=&quot;基础API的使用&quot;&gt;&lt;/a&gt;基础API的使用&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="小程序" scheme="https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序登录接口的更新</title>
    <link href="https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
    <id>https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/</id>
    <published>2021-07-17T04:19:31.000Z</published>
    <updated>2021-07-17T14:16:19.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取用户信息（2021-4-28微信更新）"><a href="#获取用户信息（2021-4-28微信更新）" class="headerlink" title="获取用户信息（2021.4.28微信更新）"></a>获取用户信息（2021.4.28微信更新）</h1><hr><h2 id="wx-login"><a href="#wx-login" class="headerlink" title="wx.login"></a>wx.login</h2><p>调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。</p><h3 id="object-success-回调函数"><a href="#object-success-回调函数" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">string</td><td align="left">用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">auth.code2Session</a>，使用 code 换取 openid、unionid、session_key 等信息</td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.code) &#123;</span><br><span class="line">      <span class="comment">//发起网络请求</span></span><br><span class="line">      wx.request(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;https://example.com/onLogin&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">          <span class="attr">code</span>: res.code</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;登录失败！&#x27;</span> + res.errMsg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实际使用代码"><a href="#实际使用代码" class="headerlink" title="实际使用代码"></a>实际使用代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    that.globalData.code = res.code</span><br><span class="line">    <span class="built_in">console</span>.log(glo.copy(res))</span><br><span class="line">    <span class="keyword">let</span> u = <span class="string">&#x27;https://golaxy.weiqiai.com:8080/user/authorize&#x27;</span></span><br><span class="line">    that.getData(u, &#123; <span class="attr">js_code</span>: res.code &#125;)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(glo.copy(r))</span><br><span class="line">        that.globalData.openId = r.openid</span><br><span class="line">        <span class="keyword">let</span> session_key = r.session_key;</span><br><span class="line">        <span class="keyword">let</span> u = <span class="string">&#x27;https://golaxy.weiqiai.com:8080/user/getUserInfo&#x27;</span></span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        success(<span class="literal">false</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 发送 res.code 到后台换取 openId, sessionKey, unionId</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>拿到了openId等信息</p><h2 id="wx-getUserProfile"><a href="#wx-getUserProfile" class="headerlink" title="wx.getUserProfile"></a>wx.getUserProfile</h2><p>获取用户信息。页面产生点击事件（例如 <code>button</code> 上 <code>bindtap</code> 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 <code>userInfo</code>。该接口用于替换 <code>wx.getUserInfo</code>，</p><p><strong>这个函数只能通过点击事件触发</strong></p><h3 id="object-success-回调函数-1"><a href="#object-success-回调函数-1" class="headerlink" title="object.success 回调函数"></a>object.success 回调函数</h3><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">userInfo</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/UserInfo.html">UserInfo</a></td><td align="left">用户信息对象</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">rawData</td><td align="left">string</td><td align="left">不包括敏感信息的原始数据字符串，用于计算签名</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">signature</td><td align="left">string</td><td align="left">使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">用户数据的签名验证和加解密</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">encryptedData</td><td align="left">string</td><td align="left">包括敏感数据在内的完整用户信息的加密数据，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">iv</td><td align="left">string</td><td align="left">加密算法的初始向量，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr><tr><td align="left">cloudID</td><td align="left">string</td><td align="left">敏感数据对应的云 ID，开通<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">云开发</a>的小程序才会返回，可通过云调用直接获取开放数据，详细见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#method-cloud">云调用直接获取开放数据</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.4</a></td></tr></tbody></table><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p><a href="https://developers.weixin.qq.com/s/tsJaq2mP7Mp4">在开发者工具中预览效果</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;canIUseGetUserProfile&#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;getUserProfile&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:else</span> <span class="attr">open-type</span>=<span class="string">&quot;getUserInfo&quot;</span> <span class="attr">bindgetuserinfo</span>=<span class="string">&quot;getUserInfo&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">bindtap</span>=<span class="string">&quot;bindViewTap&quot;</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-avatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">userInfo</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">hasUserInfo</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">canIUseGetUserProfile</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">onLoad</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (wx.getUserProfile) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">        <span class="attr">canIUseGetUserProfile</span>: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getUserProfile</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认</span></span><br><span class="line">    <span class="comment">// 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗</span></span><br><span class="line">    wx.getUserProfile(&#123;</span><br><span class="line">      <span class="attr">desc</span>: <span class="string">&#x27;用于完善会员资料&#x27;</span>, <span class="comment">// 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span></span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">          <span class="attr">userInfo</span>: res.userInfo,</span><br><span class="line">          <span class="attr">hasUserInfo</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getUserInfo</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 不推荐使用getUserInfo获取用户信息，预计自2021年4月13日起，getUserInfo将不再弹出弹窗，并直接返回匿名的用户个人信息</span></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">userInfo</span>: e.detail.userInfo,</span><br><span class="line">      <span class="attr">hasUserInfo</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实际使用代码-1"><a href="#实际使用代码-1" class="headerlink" title="实际使用代码"></a>实际使用代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wx.getUserProfile(&#123;</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = res.userInfo || &#123;&#125;</span><br><span class="line">    wx.setStorageSync(<span class="string">&#x27;userInfo&#x27;</span>, userInfo)</span><br><span class="line">    <span class="comment">// that.globalData.userInfo = userInfo</span></span><br><span class="line">    <span class="built_in">this</span>.userInfoSet()</span><br><span class="line">    success(userInfo)</span><br><span class="line">    <span class="comment">// that.globalData.loged = true</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>虽然微信这个变动让很多小程序开发者苦不堪言，但是还是很方便的，之前的方式是wx.login获取code给wx.getUserInfo去拿取session_key和openid，然后传给后端，后端去请求用户个人信息，对此很多程序员都封装了组件，类似套娃的方法去实现。</p><p>在这次更新后，wx.getUserProfile取缔wx.getUserInfo，wx.getUserProfile必须用点击事件触发例如bindtap(),之前的’套娃组件‘也都要废弃，改成了更加简单的方式，封装一个函数，在app.js页面一开始调用wx.login获取openid。然后在写一个button点击事件bindtap()调用wx.getUserProfile获取以下信息</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210717131151.png"></p><p>然后前端在调用接口传个后端存进数据库</p>]]></content>
    
    
    <summary type="html">解决一个大家都头疼的问题(可能只有我头大吧哈哈哈)</summary>
    
    
    
    
    <category term="小程序" scheme="https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单工,半双工,全双工三者区别</title>
    <link href="https://andylinwenqin.github.io/2021/07/11/%E5%8D%95%E5%B7%A5-%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%85%A8%E5%8F%8C%E5%B7%A5%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/"/>
    <id>https://andylinwenqin.github.io/2021/07/11/%E5%8D%95%E5%B7%A5-%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%85%A8%E5%8F%8C%E5%B7%A5%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-11T07:10:38.000Z</published>
    <updated>2021-07-11T07:15:35.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单工-半双工-全双工三者区别"><a href="#单工-半双工-全双工三者区别" class="headerlink" title="单工 半双工 全双工三者区别"></a>单工 半双工 全双工三者区别</h1><hr><h2 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h2><p>单工就是指A只能发信号，而B只能接收信号，通信是单向的，就象灯塔之于航船-灯塔发出光信号而航船只能接收信号以确保自己行驶在正确的航线上。 </p><h2 id="半双工（Half-Duplex）"><a href="#半双工（Half-Duplex）" class="headerlink" title="半双工（Half Duplex）"></a>半双工（Half Duplex）</h2><p>半双工就是指A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。最典型的例子就象我们在影视作品中看到的对讲机一样： </p><p>007：呼叫总部，请求支援，OVER  </p><p>总部：收到，增援人员将在5分钟内赶到，OVER  </p><p>007：要5分钟这么久？！要快呀！OVER  </p><p>总部：„„  </p><p>在这里，每方说完一句话后都要说个OVER，然后切换到接收状态，同时也告之对方-你可以发言了。如果双方同时处于收状态，或同时处于发状态，便不能正常通信了。 </p><h2 id="全双工-（Full-Duplex）"><a href="#全双工-（Full-Duplex）" class="headerlink" title="全双工 （Full Duplex）"></a>全双工 （Full Duplex）</h2><p>全双工比半双工又进了一步。在A给B发信号的同时，B也可以给A发信号。典型的例子就是打电话。<br>A：我跟你说呀„„<br>B：你先听我说，情况是这样的„„<br>A和B在说的同时也能听到对方说的内容，这就是全双工。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://blog.csdn.net/erwangshi/article/details/44940069">原文链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单工-半双工-全双工三者区别&quot;&gt;&lt;a href=&quot;#单工-半双工-全双工三者区别&quot; class=&quot;headerlink&quot; title=&quot;单工 半双工 全双工三者区别&quot;&gt;&lt;/a&gt;单工 半双工 全双工三者区别&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;单工&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="通信机制" scheme="https://andylinwenqin.github.io/tags/%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Stomp</title>
    <link href="https://andylinwenqin.github.io/2021/07/06/STOMP/"/>
    <id>https://andylinwenqin.github.io/2021/07/06/STOMP/</id>
    <published>2021-07-06T11:12:57.000Z</published>
    <updated>2021-07-17T03:15:40.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习血汗史"><a href="#学习血汗史" class="headerlink" title="学习血汗史"></a>学习血汗史</h2><p>查了各类资料花了整整三天才学通，又被跨域卡了一天，直到第五天才完完全全跑通，下一步学习emoji的表情包用法</p><hr><h2 id="stomp-over-websocket协议原理"><a href="#stomp-over-websocket协议原理" class="headerlink" title="stomp over websocket协议原理"></a>stomp over websocket协议原理</h2><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>http协议是单工的, 只能由client发请求再由server返回请求结果, 在http协议中server是不能主动发请求到client的.</p><p>大多数情况下http协议都是适用的, 但当遇到在线聊天, 股票行情这样需要实时获取取服务端信息的应用时, client需要频繁轮询server<br>过程如下:</p><blockquote><p>client 建立连接<br>client 问server有没有新的消息, 并根据返回结果进行处理<br>client 关闭连接<br>client 建立连接<br>client 问server有没有新的消息, 并根据返回结果进行处理<br>client 关闭连接<br>…</p></blockquote><p>为了拿到最新信息, client一直这样循环下去<br>server如果一直没有新的消息, client的大多请求都是无效的, 效率低下.</p><p>为了提高效率需要有一种协议可以让server主动发消息给client.<br>这样就不需要client频繁轮询, 只要server有新消息就会主动推送给client.</p><p>这种协议就是websocket协议(效果：服务端主动向客户端发送信息).</p><h3 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h3><p>webSocket协议是基于TCP的一种网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。<br>在webscoket协议中, client利用http来建立tcp连接, 建立tcp连接之后, client与server就可以基于tcp连接来愉快的进行通信了.</p><p>那么webscoket如何利用http建立连接的呢?</p><p>先看一个经典图示</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154116.png"></p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><h5 id="client与server是利用http的一次request-response来建立连接的"><a href="#client与server是利用http的一次request-response来建立连接的" class="headerlink" title="client与server是利用http的一次request, response来建立连接的."></a>client与server是利用http的一次request, response来建立连接的.</h5><p>其中http request消息体如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/echo</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host:jingxu.test.com:8100</span><br><span class="line">Origin:http://jingxu.test.com:8099</span><br><span class="line">Sec-WebSocket-Extensions:permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Key:rVX0XFeQzA9QVXXEfjm0yw==</span><br><span class="line">Sec-WebSocket-Version:13</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure><p>其中前三个header:Get, Host, Origin都是http协议之前就有, 不多做解释, 主要解释一下后面这几个header<br>Sec-WebSocket-Extensions: 用于对websocket协议进行扩展. 比如websocket协议本身不支持压缩, 但可以通过Sec-WebSocket-Extensions中的permessage-deflate来协商压缩.<br>Sec-WebSocket-Key:client随机生成的一段key. 详情之后response中Sec-WebSocket-Accept的解释.<br>Sec-WebSocket-Version:协议的版本号<br>Upgrade:通过http的Upgrade对协议进行切换. 告诉server, 建立连接后用websocket协议.</p><p>http response消息体如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connection:upgrade</span><br><span class="line">Date:Mon, 04 Dec 2017 10:05:18 GMT</span><br><span class="line">Sec-WebSocket-Accept:q3dUKg4lRGCqqRhGIvmE7sH8Yuc=</span><br><span class="line">Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits=15</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure><p>Connection与Date都是http协议之前就有的header, 主要解释一下后面的.<br>Sec-WebSocket-Accept:对应于request中的Sec-WebSocket-Key.<br>server会根据request中的Sec-WebSocket-Key的值来生成response中的Sec-WebSocket-Accept的值.<br>具体的算法是根据Sec-WebSocket-Key与协议中已定义的一个guid “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”进行拼接<br>再对结果进行sha1, 再对sha1的结果进行base64, 最后得到Sec-WebSocket-Accept的值.</p><h5 id="client通过验证server返回的Sec-WebSocket-Accept的值-来确定两件事情"><a href="#client通过验证server返回的Sec-WebSocket-Accept的值-来确定两件事情" class="headerlink" title="client通过验证server返回的Sec-WebSocket-Accept的值, 来确定两件事情:"></a>client通过验证server返回的Sec-WebSocket-Accept的值, 来确定两件事情:</h5><p>server理解websocket协议.<br>如果server不理解, 那么server不会返回正确的Sec-WebSocket-Accept.<br>如果server没有返回正确的Sec-WebSocket-Accept, 那么建立websocket连接失败.</p><p>server返回的response是对于client的此次reuqest的响应而不是之前的缓存.<br>主要是防止有些缓存服务器返回缓存的response.</p><p>发送数据<br>现在websocket连接已经建立, 由于websocket没有规范payload的格式, 所以应用需要自己去定义payload的格式.</p><p>websocket的payload可以是文本也可以是二进制.<br>应用一般会选择用文本.<br>这个文本是什么格式websocket协议本身并没有规定, 由应用自己来定.</p><p>比如我要请求发送消息这个接口, 那么我的payload可以写成:</p><p><code>/send | params=我是消息</code></p><p>这里我自己定义了一个格式, 中坚线之前的是要调用的地址, 中竖线之后是参数.<br>由于格式是自己定义的, 所以在服务端我也需要自己写代码来解析这个格式.<br>把/send路由到相应的处理方法.</p><p>那有没有一种统一的协议呢? 统一的标准呢?<br>因为这样就会有相应的已经实现的库来解析路由, 而不用自己去写, 自己去定义格式.</p><p>这个统一的协议就是stomp协议(一个基于webSocket的通信协议或者说一种标准).</p><h3 id="stomp协议"><a href="#stomp协议" class="headerlink" title="stomp协议"></a>stomp协议</h3><p><strong>stomp是一个用于client之间进行异步消息传输的简单文本协议, 全称是Simple Text Oriented Messaging Protocol.</strong></p><blockquote><p>对于stomp协议来说, client分为消费者client与生产者client两种. server是指broker, 也就是消息队列的管理者.</p></blockquote><p>stomp协议并不是为websocket设计的, 它是属于消息队列的一种协议, 和amqp, jms平级.<br>只不过由于它的简单性恰巧可以用于定义websocket的消息体格式.<br>stomp协议很多mq都已支持, 比如rabbitmq, activemq. 很多语言也都有stomp协议的解析client库.</p><p>可以这么理解, websocket结合stomp相当于一个面向公网对用户比较友好的一种消息队列.</p><p>stomp协议中的client分为两角色:</p><blockquote><p>生产者: 通过<code>SEND</code>命令给某个目的地址(destination)发送消息.</p><p>消费者: 通过<code>SUBSCRIBE</code>命令订阅某个目的地址(destination), 当生产者发送消息到目的地址后, 订阅此目的地址的消费者会即时收到消息.</p></blockquote><p>stomp协议的结构与http结构相似, 结构如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1 </span><br><span class="line">header2:value2 </span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure><p><strong>其中^@代表null结尾.</strong></p><p>与http相似有三部分组成: 命令, header, 消息体.<br>命令与header使用utf-8格式, body可以是二进制也可以是文本.</p><p>命令有SEND, SUBSCRIBE, MESSAGE, CONNECT, CONNECTED等.</p><p>header类似http有content-length, content-type等.<br>消息体类似http可以是二进制也可以是文本.</p><p>下面例举一些主要命令<br>和http, websocket类似, 首先要确认双方都懂stomp这个协议, 通过建立连接来确认.<br>由于我们已经建立了webscoket连接, 接下来我只需要在webscoket连接的基础上建立stomp连接.</p><p>将以下内容写到websocket的payload中, 来发送建立stomp连接请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECT</span><br><span class="line">accept-version:1.2</span><br><span class="line">host:stomp.github.org</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>stomp协议并不与websocket协议耦合, 比如双方建立了tcp连接, 那么完成可以在tcp连接上建立stomp连接, 也就是将上述内容写到tcp的payload中.</p><p>server收到后回复, 同样以下内容是在server回复的websocket的消息体中</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONNECTED</span><br><span class="line">version:1.2 </span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>这样一个stomp连接就建立了, 协议版本为1.2.</p><p>由于stomp连接是一个长连接, stomp协议定义了发送心跳来监测stomp连接是否存活.</p><p>在CONNECT命令消息中加入heart-beat心跳header来建立连接就开启了心跳:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONNECT </span><br><span class="line">accept-version:1.2 </span><br><span class="line">heart-beat:&lt;cx&gt;,&lt;cy&gt; </span><br><span class="line">host:stomp.github.org </span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECTED </span><br><span class="line">version:1.2</span><br><span class="line">heart-beat:&lt;sx&gt;,&lt;sy&gt;</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>其中<code>&lt;cx&gt;, &lt;cy&gt;, &lt;sx&gt;, &lt;sy&gt;</code>分别代表一个以毫秒为单位的数字.</p><p>client发送的CONNECT命令消息中的<code>&lt;cx&gt;,&lt;cy&gt;</code>分别代表:</p><p><code>&lt;cx&gt;</code>:client能保证的发送心跳的最小间隔, 如果是0代表client不发送心跳.<br><code>&lt;cy&gt;</code>:client希望收到server心跳的间隔, 如果是0代表client不希望收到server的心跳.<br>与client类似, server发送的CONNECTED命令消息中的<sx>,<sy>分别代表:</p><p><code>&lt;sx&gt;</code>:server能保证的发送心跳的最小间隔, 如果是0代表server不发送心跳.</p><p><code>&lt;sy&gt;</code>:server希望收到client心跳的间隔, 如果是0代表server不希望收到client的心跳</p><p>如果在建立连接时没有心跳header, 默认当作heart-beat:0,0. 也就是不发心跳, 也不希望对方发心跳.</p><p>加入心跳header进行连接后, 最终协商得出发送心跳的频率的逻辑如下:<br>对于client来说, 取<cx>与<sy>的最大值, 也就是说client会取client最小能发送的间隔与server希望client发送间隔的最大值来发送心跳.<br>如果<cx>或<sy>中任何一个为0, client都不发送心跳.</p><p>类似, 对于server来说, 取<sx>与<cy>的最大值, 也就是说server取server最小能发送的间隔与client希望server发送间隔的最大值来发送心跳.<br>如果<sx>或<cy>中任何一个为0, server都不发送心跳.</p><p>举个例子, 如下建立连接</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONNECT</span><br><span class="line">accept-version:1.2</span><br><span class="line">heart-beat:1000,2000</span><br><span class="line">host:stomp.github.org</span><br><span class="line"></span><br><span class="line">^@123456</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECTED</span><br><span class="line">version:1.2</span><br><span class="line">heart-beat:3000,4000</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>上述, client发送CONNECT命令消息中heart-beat为1000, 2000.<br>解释为client最小能保证发送心跳间隔为1000毫秒, 希望server发送心跳间隔为2000毫秒</p><p>server回复的CONNECTED命令消息中heart-beat为3000,4000<br>解释为server最小能保证发送心跳间隔为3000毫秒, 希望client发送心跳间隔为4000毫秒</p><p>最终的协商结果, client取自己能保证的最小心跳间隔1000毫秒与server希望client发送心跳间隔4000毫秒的最大值<br>得出client会每4000毫秒发一次心跳,</p><p>同理, server取自己能保证的最小心跳间隔3000毫秒与client希望server发送心跳间隔2000毫秒的最大值<br>得出server会每3000毫秒发一次心跳.</p><p>client和server根据心跳来判定对方已经挂掉了的逻辑如下:</p><p>以server为例, 假设经过协商, client每10秒发送一个心跳.</p><p>client必须在10秒以内给server至少发送一次数据, 不管是心跳还是正常数据.<br>如果在10秒内client未发送数据, 那么server认为与client的stomp连接已经挂掉.<br>现在连接已经建立, 接下来准备发送stomp消息.</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>发送消息使用SEND这个COMMAND, 如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/topic/a </span><br><span class="line">content-type:text/plain </span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>其中destination这个header的值为发送消息的目的地址.<br>上述SEND命令消息的意思为, 给/topic/a这个目的地址发送一条类型为text/plain, 内容是hello world的消息.<br>所有订阅/topic/a这个目的地址的消费者client都会收到hello world这条消息.</p><blockquote><p>stomp协议并没有规定destination的格式, 这个是由使用stomp协议的应用自己来定义.<br>比如, /topic/a, /queue/a, queue.a, topic.a, topic-a, queue-a对于stomp协议来说都是正确的.<br>应用可以自己规定不同的格式以及此格式代表的含义.<br>比如, 应用自己可以定义以/topic打头的为发布订阅模式, 消息会被所有消费者client收到,<br>以/queue打头的为负载平衡模式, 只会被一个消费都client收到.</p></blockquote><p>client发送SEND命令消息如何确保server收到了这条消息呢?</p><p>协议规定, 可以在SEND命令消息中加入receipt header. receipt header的值唯一确定一次send.<br>server收到有receipt header的SEND命令消息后, 需要回复一个RECEIPT命令消息,<br>里面会包含receipt-id header, receipt-id的值就是SEND命令消息中receipt header的值.<br>这样当client收到了这条RECEIPT命令消息后, 就能确定server已收到SEND命令消息. 例如:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/queue/a</span><br><span class="line">receipt:message-12345</span><br><span class="line"></span><br><span class="line">hello queue a^@12345</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RECEIPT</span><br><span class="line">receipt-id:message-12345</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>接下来看一下消费者client如何订阅消息.</p><h4 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h4><p>订阅消息用SUBSCRIBE命令, 如下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE </span><br><span class="line">id:0  </span><br><span class="line">destination:/topic/foo  </span><br><span class="line">ack:client </span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>上述代表client订阅/topic/foo这个目的地址.<br>其中多了两个新的header: id与ack.</p><p><strong>订阅中的id header</strong><br>此id能唯一确定一个订阅.<br>一个client对于一个server可以订阅多次, 甚至对于同一个目的地址都可以订阅多次.<br>为了唯一确定一次订阅, 协议规定必须包含id header, 此id要求在同一连接中唯一.</p><p><strong>订阅中的ack header</strong><br>ack header告诉server, server如何确认client已经收到消息.<br>有三个值: <code>auto</code>, <code>client</code>, <code>client-individual</code></p><p><code>auto</code>表示当server发出消息后就立即确认client收到了消息. 也就是说当<code>client</code>收到消息后不会对server进行确认.<br><code>client</code>表示只有当server收到client的ack后才确认client收到了消息, 也就是说client需要对server发ack进行确认.<br>这个确认是累积的, 意思是说收到某条消息的ack, 那么这条消息之前的所有的消息, server都认为client已收到.<br><code>client-individual</code>与client类似. 只不过不是累积的. 每收到一条消息都需要给server回复ack来确认.</p><p>有订阅消息, 那肯定有取消订阅消息.</p><h4 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h4><p>取消订阅用UNSUBSCRIBE这个命令</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UNSUBSCRIBE</span><br><span class="line">id:0</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>取消订阅相对来说比较简单只需要传一个id header.<br>这个id header的值来自订阅时id header值. 这样server才能唯一确定到底要取消哪个订阅.</p><p>当有生产者client给目的地址发消息后, 首先server会收到消息, server收到消息后会把消息发送给所有订阅这个目的地址的client, 那么server是如何发送这个消息到消费都client的呢?</p><h4 id="server发送消息"><a href="#server发送消息" class="headerlink" title="server发送消息"></a>server发送消息</h4><p>server发送消息用MESSAGE这个命令来给client发送消息, 如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">subscription:0</span><br><span class="line">message-id:007</span><br><span class="line">destination:/queue/a</span><br><span class="line">content-type:text/plain</span><br><span class="line"></span><br><span class="line">hello queue a^@</span><br></pre></td></tr></table></figure><p>message-id这个header的值能唯一确定一条消息<br>subscription的值就是订阅时SUBSCRIBE命令中id header的值, 表示这条消息属于哪个订阅.</p><p>到此, 介绍了一些stomp常用的命令, 还有一些其他命令, 有兴趣可以查看<a href="https://stomp.github.io/stomp-specification-1.2.html">stomp协议文档</a>:</p><h3 id="协议总结"><a href="#协议总结" class="headerlink" title="协议总结"></a>协议总结</h3><p>由于http是一个单工的协议, server不能主动发送消息给client, 导致http在处理实时性要求高的应用时效率不高.</p><p>为了提高效率, 我们使用了全双工的websocket协议, 可以让server主动推送消息.</p><p>又由于websocket协议是个底层协议, 不是应用层协议, 未对payload的格式进行规范, 导致我们需要自己定义消息体格式, 自己解析消息体, 成本高, 扩展性也不好, 所以我们引入了已被很多库和消息队列厂商实现的stomp协议, 将websocket协议与stomp协议结合.</p><p>我们再总结一下websocket与stomp的优点</p><h4 id="websocket相对于http的优点"><a href="#websocket相对于http的优点" class="headerlink" title="websocket相对于http的优点:"></a>websocket相对于http的优点:</h4><p>全双工. 相对于http协议只能由client发送消息. 全双工的websocket协议, server与client都可以发送消息.<br>消息体更轻量. http的一个请求比websocket的请求大不少. 主要因为http的每次请求都要加很多的header.</p><h4 id="stomp-over-websocket相对于websocket的优点"><a href="#stomp-over-websocket相对于websocket的优点" class="headerlink" title="stomp over websocket相对于websocket的优点:"></a>stomp over websocket相对于websocket的优点:</h4><p>不需要自己去规定消息的格式, 以及对消息的格式做解析.<br>由于stomp是一个统一的标准, 有很多库与厂商都对stomp协议进行了支持. 拿来用就可以. 成本低, 扩展好.<br>理论到此为止, 接下来我们一起了解下spring websocket是如何实现stomp over websocket协议的.</p><h2 id="Stomp使用文档-官方文档翻译版"><a href="#Stomp使用文档-官方文档翻译版" class="headerlink" title="Stomp使用文档(官方文档翻译版)"></a>Stomp使用文档(官方文档翻译版)</h2><p>STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议，它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。</p><h3 id="创建STOMP客户端"><a href="#创建STOMP客户端" class="headerlink" title="创建STOMP客户端"></a>创建<code>STOMP</code>客户端</h3><h4 id="在web浏览器中使用普通的Web-Socket"><a href="#在web浏览器中使用普通的Web-Socket" class="headerlink" title="在web浏览器中使用普通的Web Socket"></a>在web浏览器中使用普通的Web Socket</h4><p>　　STOMP javascript 客户端会使用<code>ws://</code>的URL与STOMP 服务端进行交互。</p><p>　　为了创建一个STOMP客户端js对象，你需要使用<code>Stomp.client(url)</code>，而这个URL连接着服务端的WebSocket的代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;ws://localhost:61614/stomp&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> client = Stomp.client(url);</span><br></pre></td></tr></table></figure><p><code>　　Stomp.client(url, protocols)</code>也可以用来覆盖默认的<code>subprotocols</code>。第二个参数可以是一个字符串或一个字符串数组去指定多个<code>subprotocols</code>。</p><h4 id="在web浏览器中使用定制的WebSocket"><a href="#在web浏览器中使用定制的WebSocket" class="headerlink" title="在web浏览器中使用定制的WebSocket"></a>在web浏览器中使用定制的WebSocket</h4><p>　　浏览器提供了不同的WebSocket的协议，一些老的浏览器不支持WebSocket的脚本或者使用别的名字。默认下，<code>stomp.js</code>会使用浏览器原生的<code>WebSocket class</code>去创建WebSocket。</p><p>　　但是利用<code>Stomp.over(ws)</code>这个方法可以使用其他类型的WebSockets。这个方法得到一个满足WebSocket定义的对象。</p><p>　　例如，可以使用由<code>SockJS</code>实现的Websocket。</p><p>　　如果使用原生的Websockets就使用<code>Stomp.client(url)</code>，如果需要使用其他类型的Websocket（例如由SockJS包装的Websocket）就使用<code>Stomp.over(ws)</code>。除了初始化有差别，Stomp API在这两种方式下是相同的。</p><h4 id="在node-js程序中"><a href="#在node-js程序中" class="headerlink" title="在node.js程序中"></a>在<code>node.js</code>程序中</h4><p>　　通过<code>stompjs npm package</code>同样也可以在<code>node.js</code>程序中使用这个库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install stompjs</span><br></pre></td></tr></table></figure><p>　　在node.js <code>app</code>中，<code>require</code>这个模块：<code>var Stomp = require(&#39;stompjs&#39;);</code></p><p>　　为了与建立在TCP socket的STOMP-broker连接，使用<code>Stomp.overTCP(host, port)</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = Stomp.overTCP(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">61613</span>);</span><br></pre></td></tr></table></figure><p>　　为了与建立在Web Socket的STOMP broker连接，使用<code>Stomp.overWS(url)</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = Stomp.overWS(<span class="string">&#x27;ws://localhost:61614/stomp&#x27;</span>);</span><br></pre></td></tr></table></figure><p>　　除了初始化不同，无论是浏览器还是node.js环境下，Stomp API都是相同的。</p><h3 id="连接服务端"><a href="#连接服务端" class="headerlink" title="连接服务端"></a>连接服务端</h3><p>　　一旦Stomp 客户端建立了，必须调用它的<code>connect()</code>方法去连接Stomp服务端进行验证。这个方法需要两个参数，用户的登录和密码凭证。这种情况下，客户端会使用Websocket打开连接，并发送一个<code>CONNECT frame</code>。</p><p>　　这个连接是异步进行的：你不能保证当这个方法返回时是有效连接的。为了知道连接的结果，你需要一个回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect_callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// called back after the client is connected and authenticated to the STOMP server</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　但是如果连接失败会发生什么呢？</p><p>　　<code>connect()</code>方法接受一个可选的参数(<code>error_callback</code>)，当客户端不能连接上服务端时，这个回调函数<code>error_callback</code>会被调用，该函数的参数为对应的错误对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var error_callback = function(error) &#123;</span><br><span class="line">    // display the error&#x27;s message header:</span><br><span class="line">    alert(error.headers.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　在大多数情况下，<code>connect()</code>方法可接受不同数量的参数来提供简单的API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.connect(login, passcode, connectCallback);</span><br><span class="line">client.connect(login, passcode, connectCallback, errorCallback);</span><br><span class="line">client.connect(login, passcode, connectCallback, errorCallback, host);</span><br></pre></td></tr></table></figure><p><code>　　login</code>和<code>passcode</code>是strings，<code>connectCallback</code>和<code>errorCallback</code>则是functions。（有些brokers（代理）还需要传递一个<code>host</code>（String类型）参数。）</p><p>　　如果你需要附加一个<code>headers</code>头部，<code>connect</code>方法还接受其他两种形式的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.connect(headers, connectCallback);</span><br><span class="line">client.connect(headers, connectCallback, errorCallback);</span><br></pre></td></tr></table></figure><p><code>　　header</code>是<code>map</code>形式，<code>connectCallback</code>和<code>errorCallback</code>为functions。</p><p>　　需要注意：如果你使用上述这种方式，你需要自行在<code>headers</code>添加<code>login</code>、<code>passcode</code>（甚至<code>host</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = &#123;</span><br><span class="line">    <span class="attr">login</span>: <span class="string">&#x27;mylogin&#x27;</span>,</span><br><span class="line">    <span class="attr">passcode</span>: <span class="string">&#x27;mypasscode&#x27;</span>,</span><br><span class="line">    <span class="comment">// additional header</span></span><br><span class="line">    <span class="string">&#x27;client-id&#x27;</span>: <span class="string">&#x27;my-client-id&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">client.connect(headers, connectCallback);</span><br></pre></td></tr></table></figure><p>　　断开连接时，调用<code>disconnect</code>方法，这个方法也是异步的，当断开成功后会接收一个额外的回调函数的参数。如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.disconnect(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;See you next time!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　当客户端与服务端断开连接，就不会再发送或接收消息了。</p><h3 id="Heart-beating-心跳"><a href="#Heart-beating-心跳" class="headerlink" title="Heart-beating(心跳)"></a>Heart-beating(心跳)</h3><p>　　如果STOMP broker(代理)接收STOMP 1.1版本的帧，<code>heart-beating</code>是默认启用的。</p><p>　　<code>heart-beating</code>也就是频率，<code>incoming</code>是接收频率，<code>outgoing</code>是发送频率。通过改变<code>incoming</code>和<code>outgoing</code>可以更改客户端的<code>heart-beating</code>(默认为10000ms)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client.heartbeat.outgoing = <span class="number">20000</span>; </span><br><span class="line"><span class="comment">// client will send heartbeats every 20000ms</span></span><br><span class="line">client.heartbeat.incoming = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// client does not want to receive heartbeats</span></span><br><span class="line"><span class="comment">// from the server</span></span><br></pre></td></tr></table></figure><p><code>　　heart-beating</code>是利用<code>window.setInterval()</code>去规律地发送<code>heart-beats</code>或者检查服务端的<code>heart-beats</code>。</p><h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><p>　　当客户端与服务端连接成功后，可以调用<code>send()</code>来发送STOMP消息。这个方法必须有一个参数，用来描述对应的STOMP的目的地。另外可以有两个可选的参数：<code>headers</code>，<code>object</code>类型包含额外的信息头部；<code>body</code>，一个String类型的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.send(<span class="string">&quot;/queue/test&quot;</span>, &#123;<span class="attr">priority</span>: <span class="number">9</span>&#125;, <span class="string">&quot;Hello, STOMP&quot;</span>);</span><br><span class="line"><span class="comment">// client会发送一个STOMP发送帧给/queue/test，这个帧包含一个设置了priority为9的header和内容为“Hello, STOMP”的body。</span></span><br></pre></td></tr></table></figure><p>　　如果你想发送一个有<code>body</code>的信息，也必须传递<code>headers</code>参数。如果没有<code>headers</code>需要传递，那么就传<code>&#123;&#125;</code>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.send(destination, &#123;&#125;, body);</span><br></pre></td></tr></table></figure><h3 id="订阅（Subscribe）和接收（receive）消息"><a href="#订阅（Subscribe）和接收（receive）消息" class="headerlink" title="订阅（Subscribe）和接收（receive）消息"></a>订阅（Subscribe）和接收（receive）消息</h3><p>　　为了在浏览器中接收消息，STOMP客户端必须先订阅一个目的地<code>destination</code>。</p><p>　　你可以使用<code>subscribe()</code>去订阅。这个方法有2个必需的参数：目的地(<code>destination</code>)，回调函数(<code>callback</code>)；还有一个可选的参数<code>headers</code>。其中<code>destination</code>是String类型，对应目的地，回调函数是伴随着一个参数的<code>function</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscription = client.subscribe(<span class="string">&quot;/queue/test&quot;</span>, callback);</span><br></pre></td></tr></table></figure><p><code>　　subscribe()</code>方法返回一个<code>object</code>，这个<code>object</code>包含一个<code>id</code>属性，对应这个这个客户端的订阅ID。</p><p>　　而<code>unsubscribe()</code>可以用来取消客户端对这个目的地<code>destination</code>的订阅。</p><p>　　默认情况下，如果没有在<code>headers</code>额外添加，这个库会默认构建一个独一无二的<code>ID</code>。在传递<code>headers</code>这个参数时，可以使用你自己的<code>ID</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysubid = <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> subscription = client.subscribe(destination, callback, &#123; <span class="attr">id</span>: mysubid &#125;);</span><br></pre></td></tr></table></figure><p>　　这个客户端会向服务端发送一个STOMP订阅帧（<code>SUBSCRIBE frame</code>）并注册回调事件。每次服务端向客户端发送消息时，客户端都会轮流调用回调函数，参数为对应消息的STOMP帧对象（<code>Frame object</code>）。</p><p><code>　　subscribe()</code>方法，接受一个可选的<code>headers</code>参数用来标识附加的头部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = &#123;<span class="attr">ack</span>: <span class="string">&#x27;client&#x27;</span>, <span class="string">&#x27;selector&#x27;</span>: <span class="string">&quot;location = &#x27;Europe&#x27;&quot;</span>&#125;;</span><br><span class="line">client.subscribe(<span class="string">&quot;/queue/test&quot;</span>, message_callback, headers);</span><br></pre></td></tr></table></figure><p>　　这个客户端指定了它会确认接收的信息，只接收符合这个<code>selector : location = &#39;Europe&#39;</code>的消息。</p><p>　　如果想让客户端订阅多个目的地，你可以在接收所有信息的时候调用相同的回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// called every time the client receives a message</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sub1 = client.subscribe(<span class="string">&quot;queue/test&quot;</span>, onmessage);</span><br><span class="line"><span class="keyword">var</span> sub2 = client.subscribe(<span class="string">&quot;queue/another&quot;</span>, onmessage)</span><br></pre></td></tr></table></figure><p>　　如果要中止接收消息，客户端可以在<code>subscribe()</code>返回的<code>object</code>对象调用<code>unsubscribe()</code>来结束接收。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscription = client.subscribe(...);</span><br><span class="line">...</span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure><h3 id="支持JSON"><a href="#支持JSON" class="headerlink" title="支持JSON"></a>支持JSON</h3><p>　　STOMP消息的<code>body</code>必须为字符串。如果你需要发送/接收<code>JSON</code>对象，你可以使用<code>JSON.stringify()</code>和<code>JSON.parse()</code>去转换JSON对象。</p><h3 id="确认-Acknowledgment"><a href="#确认-Acknowledgment" class="headerlink" title="确认(Acknowledgment)"></a>确认(Acknowledgment)</h3><p>　　默认情况，在消息发送给客户端之前，服务端会自动确认（<code>acknowledged</code>）。</p><p>　　客户端可以选择通过订阅一个目的地时设置一个<code>ack header</code>为<code>client</code>或<code>client-individual</code>来处理消息确认。</p><p>　　在下面这个例子，客户端必须调用<code>message.ack()</code>来通知服务端它已经接收了消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscription = client.subscribe(<span class="string">&quot;/queue/test&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do something with the message</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// and acknowledge it</span></span><br><span class="line">        message.ack();</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="attr">ack</span>: <span class="string">&#x27;client&#x27;</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>　ack()</code>接受<code>headers</code>参数用来附加确认消息。例如，将消息作为事务(transaction)的一部分，当要求接收消息时其实代理（broker）已经将<code>ACK STOMP frame</code>处理了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tx = client.begin();</span><br><span class="line">message.ack(&#123; <span class="attr">transaction</span>: tx.id, <span class="attr">receipt</span>: <span class="string">&#x27;my-receipt&#x27;</span> &#125;);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h3 id="事务-Transactions"><a href="#事务-Transactions" class="headerlink" title="事务(Transactions)"></a>事务(Transactions)</h3><p>　　可以在将消息的发送和确认接收放在一个事务中。</p><p>　　客户端调用自身的<code>begin()</code>方法就可以开始启动事务了，<code>begin()</code>有一个可选的参数<code>transaction</code>，一个唯一的可标识事务的字符串。如果没有传递这个参数，那么库会自动构建一个。这个方法会返回一个object。这个对象有一个<code>id</code>属性对应这个事务的ID，还有两个方法：</p><p>　　<code>commit()</code>提交事务</p><p>　　<code>abort()</code>中止事务</p><p>　　在一个事务中，客户端可以在发送/接受消息时指定transaction id来设置transaction。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start the transaction</span></span><br><span class="line"><span class="keyword">var</span> tx = client.begin();</span><br><span class="line"><span class="comment">// send the message in a transaction</span></span><br><span class="line">client.send(<span class="string">&quot;/queue/test&quot;</span>, &#123;<span class="attr">transaction</span>: tx.id&#125;, <span class="string">&quot;message in a transaction&quot;</span>);</span><br><span class="line"><span class="comment">// commit the transaction to effectively send the message</span></span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><p>　　如果你在调用<code>send()</code>方法发送消息的时候忘记添加transction header，那么这不会称为事务的一部分，这个消息会直接发送，不会等到事务完成后才发送。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txid = <span class="string">&quot;unique_transaction_identifier&quot;</span>;</span><br><span class="line"><span class="comment">// start the transaction</span></span><br><span class="line"><span class="keyword">var</span> tx = client.begin();</span><br><span class="line"><span class="comment">// oops! send the message outside the transaction</span></span><br><span class="line">client.send(<span class="string">&quot;/queue/test&quot;</span>, &#123;&#125;, <span class="string">&quot;I thought I was in a transaction!&quot;</span>);</span><br><span class="line">tx.abort(); <span class="comment">// Too late! the message has been sent</span></span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>　　有一些测试代码能有助于你知道库发送或接收的是什么，从而来调试程序。</p><p>　　客户端可以将其<code>debug</code>属性设置为一个函数，传递一个字符串参数去观察库所有的debug语句。默认情况，debug消息会被记录在在浏览器的控制台。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.debug = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// append the debug log to a #debug div somewhere in the page using JQuery:</span></span><br><span class="line">    $(<span class="string">&quot;#debug&quot;</span>).append(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error_callback = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">　　第一次连接失败和连接后断开连接都会调用这个函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关闭控制台调试数据：设置<code>client.debug = null</code> 就可以，stompjs会去检测debug是否是函数，不是函数就不会调用输出</p><h2 id="个人实例"><a href="#个人实例" class="headerlink" title="个人实例"></a>个人实例</h2><h3 id="跨域问题（之后专门写一个跨域）"><a href="#跨域问题（之后专门写一个跨域）" class="headerlink" title="跨域问题（之后专门写一个跨域）"></a>跨域问题（之后专门写一个跨域）</h3><p>首先我没有后端，用的github现成的<a href="https://github.com/anlingyi/xechat">Java项目</a>，所以需要做跨域请求，在Java中进行了跨域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册STOMP的节点，并映射指定的url</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册STOMP的endpoint，并指定使用SockJS协议</span></span><br><span class="line">    registry.addEndpoint(StompConstant.STOMP_ENDPOINT).setAllowedOrigins(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了<code>.setAllowedOrigins(&quot;*&quot;)</code>对所有端口开放</p><p>vue项目中做了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="attr">proxy</span>: &#123;  <span class="comment">//配置跨域</span></span><br><span class="line"><span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line"><span class="attr">target</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,<span class="comment">// 实际访问地址和端口号</span></span><br><span class="line"><span class="attr">ws</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">changOrigin</span>: <span class="literal">true</span>,  <span class="comment">//允许跨域</span></span><br><span class="line"><span class="attr">pathRewrite</span>: &#123;</span><br><span class="line"><span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span><span class="comment">// 使用/api代替Target</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用/api替代实际访问地址</p><h3 id="连接服务器并配置心跳"><a href="#连接服务器并配置心跳" class="headerlink" title="连接服务器并配置心跳"></a>连接服务器并配置心跳</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">connect () &#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">&#x27;/api/xechat&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.stompClient = Stomp.over(socket);</span><br><span class="line">    <span class="comment">// 配置stomp</span></span><br><span class="line">    <span class="comment">// 心跳</span></span><br><span class="line">    <span class="built_in">this</span>.stompClient.heartbeat.outgoing = <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">// 客户端不接受服务器心跳检测</span></span><br><span class="line">    <span class="built_in">this</span>.stompClient.heartbeat.incoming = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 订阅地址</span></span><br><span class="line">    <span class="built_in">this</span>.sub();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>CONNECT发送连接服务器请求，CONNECTED服务器返回连接情况</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711212936.png"></p><h3 id="订阅服务器地址"><a href="#订阅服务器地址" class="headerlink" title="订阅服务器地址"></a>订阅服务器地址</h3><p>订阅了四个地址，并在连接成功后返回信息，进行广播</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sub () &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="built_in">this</span>.createUser();</span><br><span class="line">    <span class="built_in">this</span>.stompClient.connect(user, <span class="function"><span class="keyword">function</span> <span class="title">connectCallback</span> (<span class="params">frame</span>) </span>&#123;</span><br><span class="line">        _this.uid = frame.headers[<span class="string">&#x27;user-name&#x27;</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功&#x27;</span>)</span><br><span class="line">        <span class="comment">// 聊天室订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/topic/chatRoom&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;订阅成功&#x27;</span>)</span><br><span class="line">            _this.handleMessage(_this.getData(data.body));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/user/&#x27;</span> + _this.uid + <span class="string">&#x27;/chat&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            _this.handleMessage(_this.getData(data.body));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误信息订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/user/&#x27;</span> + _this.uid + <span class="string">&#x27;/error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            _this.getData(data.body);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 聊天室动态订阅</span></span><br><span class="line">        _this.stompClient.subscribe(<span class="string">&#x27;/topic/status&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = _this.getData(data.body);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;看这里&#x27;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(obj)</span><br><span class="line">            _this.handleMessage(obj);</span><br><span class="line">            _this.showOnlineNum(obj.onlineCount);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> <span class="title">errorCallBack</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;请重新连接！&#x27;</span>);</span><br><span class="line">        _this.refresh();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>成功订阅并接受到广播信息  SUBSCRIBE订阅地址</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711213722.png"></p><p>实现进入效果</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711213748.png"></p><h3 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sendMessage (pub, header, data) &#123;</span><br><span class="line">    <span class="built_in">this</span>.stompClient.send(pub, header, data);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//发送信息到聊天室</span></span><br><span class="line">sendToChatRoom () &#123;</span><br><span class="line">    <span class="comment">// 获取发送的内容</span></span><br><span class="line">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;sendTxt&#x27;</span>).value;</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: content</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> pub = <span class="string">&#x27;/chatRoom&#x27;</span>;</span><br><span class="line">    data = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    <span class="built_in">this</span>.sendMessage(pub, &#123;&#125;, data);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>SEND发送 MESSAGE接收到广播信息</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711214258.png"></p><p>实现效果</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711214306.png"></p><h3 id="等待补充"><a href="#等待补充" class="headerlink" title="等待补充"></a>等待补充</h3><p>1.断开自动刷新连接服务器</p><p>2.中断订阅地址</p><p>3.对事务的理解</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://stomp.github.io/">Stomp官方文档</a></p><p><a href="https://www.cnblogs.com/goloving/p/10746378.html">StompJS使用文档总结</a></p><p><a href="https://blog.csdn.net/a617137379/article/details/78765025">stomp over websocket协议原理与实现</a></p>]]></content>
    
    
    <summary type="html">Stomp协议的原理和基础实现</summary>
    
    
    
    
    <category term="html&amp;浏览器" scheme="https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="协议" scheme="https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://andylinwenqin.github.io/2021/07/02/Web-Socket/"/>
    <id>https://andylinwenqin.github.io/2021/07/02/Web-Socket/</id>
    <published>2021-07-02T04:11:54.000Z</published>
    <updated>2021-07-17T04:18:57.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket-教程"><a href="#WebSocket-教程" class="headerlink" title="WebSocket 教程"></a>WebSocket 教程</h1><hr><p><a href="https://websocket.org/">WebSocket</a> 是一种网络通信协议，很多高级功能都需要它。</p><p>本文介绍 WebSocket 协议的使用方法。</p><h2 id="为什么需要-WebSocket？"><a href="#为什么需要-WebSocket？" class="headerlink" title="为什么需要 WebSocket？"></a>为什么需要 WebSocket？</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702153804.jpg"></p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<a href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”</a>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154116.png"></p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154224.jpg"></p><h2 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h2><p>WebSocket 的用法相当简单。</p><p>下面是一个网页脚本的例子（点击<a href="http://jsbin.com/muqamiqimu/edit?js,console">这里</a>看运行结果），基本上一眼就能明白。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://echo.websocket.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure></blockquote><h2 id="客户端的-API"><a href="#客户端的-API" class="headerlink" title="客户端的 API"></a>客户端的 API</h2><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">这里</a>。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p><blockquote><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul></blockquote><p>下面是一个示例。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果要指定多个回调函数，可以使用<code>addEventListener</code>方法。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象）。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received data string&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received arraybuffer&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send()"></a>webSocket.send()</h3><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p><p>发送文本的例子。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">&#x27;your message&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><p>发送 Blob 对象的例子。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure></blockquote><p>发送 ArrayBuffer 对象的例子。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>WebSocket 服务器的实现，可以查看维基百科的<a href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表</a>。</p><p>常用的 Node 实现有以下三种。</p><ul><li><a href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li><li><a href="http://socket.io/">Socket.IO</a></li><li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li></ul><p>具体的用法请查看它们的文档，这里不详细介绍了。</p><h2 id="WebSocketd"><a href="#WebSocketd" class="headerlink" title="WebSocketd"></a>WebSocketd</h2><p>下面，我要推荐一款非常特别的 WebSocket 服务器：<a href="http://websocketd.com/">Websocketd</a>。</p><p>它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154529.png"></p><p>举例来说，下面是一个 Bash 脚本<code>counter.sh</code>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 2</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 3</span><br></pre></td></tr></table></figure></blockquote><p>命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash ./counter.sh</span><br></pre></td></tr></table></figure></blockquote><p>现在，启动<code>websocketd</code>，指定这个脚本作为服务。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 bash ./counter.sh</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令会启动一个 WebSocket 服务器，端口是<code>8080</code>。每当客户端连接这个服务器，就会执行<code>counter.sh</code>脚本，并将它的输出推送给客户端。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。</p><p>有了它，就可以很方便地将命令行的输出，发给浏览器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 ls</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令会执行<code>ls</code>命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（<a href="https://github.com/joewalnes/web-vmstats">代码</a>）。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154601.jpg"></p><p>更多的用法可以参考<a href="https://github.com/joewalnes/websocketd/tree/master/examples/bash">官方示例</a>。</p><blockquote><ul><li>Bash 脚本<a href="https://github.com/joewalnes/websocketd/blob/master/examples/bash/greeter.sh">读取客户端输入</a>的例子</li><li>五行代码实现一个最简单的<a href="https://github.com/joewalnes/websocketd/blob/master/examples/bash/chat.sh">聊天服务器</a></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210702154728.png"></p><p>websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务<a href="https://github.com/joewalnes/websocketd/blob/master/examples/nodejs/greeter.js"><code>greeter.js</code></a>。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">&#x27;data: &#x27;</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>启动这个脚本的命令如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 node ./greeter.js</span><br></pre></td></tr></table></figure></blockquote><p>官方仓库还有其他<a href="https://github.com/joewalnes/websocketd/tree/master/examples">各种语言</a>的例子。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="http://cjihrig.com/blog/how-to-use-websockets/">How to Use WebSockets</a></p></li><li><p><a href="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">WebSockets - Send &amp; Receive Messages</a></p></li><li><p><a href="https://www.html5rocks.com/en/tutorials/websockets/basics/">Introducing WebSockets: Bringing Sockets to the Web</a></p></li><li><p>本文来自<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰的 WebSocker</a>仅作为学习使用</p></li></ul>]]></content>
    
    
    <summary type="html">WebSocket网络协议的基础概念和协议用法</summary>
    
    
    
    
    <category term="html&amp;浏览器" scheme="https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="协议" scheme="https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>mini-vue</title>
    <link href="https://andylinwenqin.github.io/2021/06/27/mini-vue/"/>
    <id>https://andylinwenqin.github.io/2021/06/27/mini-vue/</id>
    <published>2021-06-27T09:14:43.000Z</published>
    <updated>2021-06-27T10:23:42.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mini-vue"><a href="#mini-vue" class="headerlink" title="mini-vue"></a>mini-vue</h1><hr><h2 id="实现一个-mini-vue-之-vdom"><a href="#实现一个-mini-vue-之-vdom" class="headerlink" title="实现一个 mini-vue 之 vdom"></a>实现一个 mini-vue 之 vdom</h2><p><a href="https://www.bilibili.com/video/BV1rC4y187Vw?p=1">B 站传送门 (opens new window)</a>vue 总共包含三大部分:</p><ul><li>模板编译</li><li>虚拟 dom</li><li>响应式 api</li></ul><p>这篇文章主要很简单的实现一下虚拟 dom 部分</p><h3 id="h-函数"><a href="#h-函数" class="headerlink" title="#h 函数"></a><a href="https://dafunk.gitee.io/views/vue/mini-vue-vdom.html#h-%E5%87%BD%E6%95%B0">#</a>h 函数</h3><p>h 函数很简单,就是返回一个 js 对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>mount 函数接受两个参数,第一个是虚拟节点也就是 h 函数生成的 vnode,第二个是要挂载到的真实 dom 节点. mount 的主要作用是将虚拟节点挂载到真实 dom 节点上,也不是很复杂.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; tag, props, children &#125; = vnode;</span><br><span class="line">  <span class="comment">//这里要将生成的真实dom节点保存到vnode上</span></span><br><span class="line">  <span class="keyword">const</span> el = (vnode.el = <span class="built_in">document</span>.createElement(tag));</span><br><span class="line">  <span class="comment">//添加dom属性</span></span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = props[key];</span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        el.addEventListener(key.slice(<span class="number">2</span>).toLowerCase(), value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.setAttribute(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加子节点</span></span><br><span class="line">  <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">          el.append(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">//child是一个对象时,说明child是一个元素节点</span></span><br><span class="line">          <span class="comment">//这时就要递归调用mount</span></span><br><span class="line">          mount(child, el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.append(children);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.append(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>虚拟 dom 部分里最复杂的就是 patch 函数,这个函数的作用是,比对两个虚拟节点, 进行 diff 算法,从而实现最小量更新,也就是尽可能的减少对真实 dom 的操作,因为操作真实 dom 的性能开销远大于操作 js 对象,这也是 vue 使用虚拟 dom 的原因之一.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n1.tag === n2.tag) &#123;</span><br><span class="line">    <span class="comment">//这个分支为新旧节点tag类型相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要将真实dom节点el,在每次patch时向后传递,保证每次更新的都是</span></span><br><span class="line">    <span class="comment">//这个节点.</span></span><br><span class="line">    <span class="keyword">const</span> el = (n2.el = n1.el);</span><br><span class="line">    <span class="comment">//diff props</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.props || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.props || &#123;&#125;;</span><br><span class="line">    <span class="comment">//添加新的属性或更改原来已有但变化了的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key];</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key];</span><br><span class="line">      <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">        el.setAttribute(key, newValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除新属性中没有的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.removeAttribute(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//diff children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.children;</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.children;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在diff children的时候,有四个主要分支</span></span><br><span class="line">    <span class="comment">// 1.新老都是string</span></span><br><span class="line">    <span class="comment">// 2.新: array 老: string</span></span><br><span class="line">    <span class="comment">// 3.新: string 老: array</span></span><br><span class="line">    <span class="comment">// 4.新老都是array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//情况1</span></span><br><span class="line">        <span class="keyword">if</span> (oldChildren !== newChildren) &#123;</span><br><span class="line">          el.innerHTML = newChildren;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//情况3</span></span><br><span class="line">        el.innerHTML = newChildren;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      <span class="comment">//情况2</span></span><br><span class="line">      el.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      newChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> mount(child, el));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(oldChildren) &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      <span class="comment">//情况4 是最复杂的情况</span></span><br><span class="line">      <span class="comment">//这里简单起见并没有真正实现vue中的diff算法,而是选取了一个低效但</span></span><br><span class="line">      <span class="comment">//容易理解的算法,但其实vue中如果不给元素提供key的话,也会使用这个</span></span><br><span class="line">      <span class="comment">//算法,这个算法在子元素的tag不会变的情况下非常高效,但如果tag会变</span></span><br><span class="line">      <span class="comment">//则会因为不必要的创造和删除节点,而变得不那么高效.</span></span><br><span class="line">      <span class="keyword">const</span> minLength = <span class="built_in">Math</span>.min(oldChildren.length, newChildren.length);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">        patch(oldChildren[i], newChildren[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//老的children长度较小,则说明要添加节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldChildren.length === minLength) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">          mount(newChildren[i], el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之,则说明要删除节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; oldChildren.length; i++) &#123;</span><br><span class="line">          el.removeChild(oldChildren[i].el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//标签类型不同时需要用新节点替换节点</span></span><br><span class="line">    <span class="comment">//这里并没有实现😂</span></span><br><span class="line">    <span class="comment">//回头再补</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="实现一个-mini-vue-之-reactive"><a href="#实现一个-mini-vue-之-reactive" class="headerlink" title="实现一个 mini-vue 之 reactive"></a>实现一个 mini-vue 之 reactive</h2><p>简单的实现一下 vue3 的响应式原理核心</p><h3 id="Dep-类"><a href="#Dep-类" class="headerlink" title="Dep 类"></a>Dep 类</h3><p>要理解 vue 响应式原理,首先要明白 Dep 类是干什么的.</p><p>Dep 故名思意,就是依赖的意思. 为什么叫依赖,因为视图的变化,实际上是数据的变化所导致的. 所以现在数据就是视图的依赖.</p><p>现在我们假设视图的变化是由一个神奇的函数 render 的调用的结果也就是 <code>view = render(data)</code>.</p><p>现在我们在 data 变化时想改变视图,就要手动调用这个函数,而响应式就是要避免这个操作.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dep类的实例就是依赖</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//在构造函数里传入了value,这时dep同时也是数据的载体</span></span><br><span class="line">    <span class="built_in">this</span>._value = value;</span><br><span class="line">    <span class="comment">//这里dep保存着它的订阅者,注意是set,意味着不能重复</span></span><br><span class="line">    <span class="built_in">this</span>.subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过js特性对象数据访问器getter和setter,</span></span><br><span class="line">  <span class="comment">//进行订阅者的注册和依赖改变后副作用的执行,也就是发布</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">//get时注册订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.depend();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = newValue;</span><br><span class="line">    <span class="comment">//set后通知订阅者,执行副作用</span></span><br><span class="line">    <span class="built_in">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//这里的activeEffect为全局变量,指向当前要被注册的订阅者</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.add(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//执行所有副作用,也就是订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这步赋值置空的操作,保证了只能在watchEffect中进行订阅者的注册</span></span><br><span class="line">  activeEffect = effect;</span><br><span class="line">  effect();</span><br><span class="line">  activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">        Copied!</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="keyword">new</span> Dep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count.value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">count.value++; <span class="comment">// log 2</span></span><br><span class="line">count.value++; <span class="comment">// log 3</span></span><br><span class="line">count.value++; <span class="comment">// log 4</span></span><br><span class="line">count.value = <span class="number">15</span>; <span class="comment">// log 15</span></span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>在 Dep 类中了解了 vue 中基本的响应式原理后,对 reactive-api 就好理解了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dep类和当前要注册的订阅者</span></span><br><span class="line"><span class="comment">//和上面的区别是,这里Dep不再是数据的载体</span></span><br><span class="line"><span class="comment">//而只负责整个发布订阅过程</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.add(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect;</span><br><span class="line">  effect();</span><br><span class="line">  activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们从上到下看</span></span><br><span class="line"><span class="comment">//reactive接收一个原始的对象</span></span><br><span class="line"><span class="comment">//返回一个原始对象的代理</span></span><br><span class="line"><span class="comment">// Proxy(target, handler)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reactiveHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//依旧是get时进行订阅者的注册</span></span><br><span class="line">    <span class="comment">//问题是我的dep从哪获取,这里暂时认为getDep帮我拿到了</span></span><br><span class="line">    <span class="comment">//这个target和这个key对应的dep</span></span><br><span class="line">    <span class="comment">//这里为了简单起见,没有处理深层嵌套对象的响应式转换</span></span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//set时触发所有副作用</span></span><br><span class="line">    <span class="comment">//同样需要获得对应的dep</span></span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    dep.notify();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后我们看是如何获取对应的dep的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  我们先搞明白一个对应关系</span></span><br><span class="line"><span class="comment">  target是个对象,对应着一组key, value,</span></span><br><span class="line"><span class="comment">  dep的depend和notify操作,就是在对target[key], </span></span><br><span class="line"><span class="comment">  get和set时进行的,dep储存着所有订阅者,所以一个key</span></span><br><span class="line"><span class="comment">  对应着一个dep,这个数据结构可以使用Map储存这一组key,value.</span></span><br><span class="line"><span class="comment">  而前面我们知道,一个target对应着一组key,value,所以这个</span></span><br><span class="line"><span class="comment">  数据结构也是一个Map(这里考虑到垃圾回收使用了WeakMap).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!targetMap.has(target)) &#123;</span><br><span class="line">    targetMap.set(target, <span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> depMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depMap.has(key)) &#123;</span><br><span class="line">    depMap.set(key, <span class="keyword">new</span> Dep());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depMap.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个-mini-vue"><a href="#实现一个-mini-vue" class="headerlink" title="实现一个 mini-vue"></a>实现一个 mini-vue</h2><p>我们来执行最后一步,将前面的函数进行组合,得到最终可以运行的 mini-vue.</p><p>先将之前所有的代码复制过来.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vdom部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; tag, props, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = (vnode.el = <span class="built_in">document</span>.createElement(tag));</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = props[key];</span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        el.addEventListener(key.slice(<span class="number">2</span>).toLowerCase(), value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.setAttribute(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">          el.append(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">          mount(child, el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.append(children);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.append(el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n1.tag === n2.tag) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = (n2.el = n1.el);</span><br><span class="line">    <span class="comment">//diff props</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.props || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.props || &#123;&#125;;</span><br><span class="line">    <span class="comment">//添加新的属性或更改原来已有但变化了的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key];</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key];</span><br><span class="line">      <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">        el.setAttribute(key, newValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除新属性中没有的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.removeAttribute(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//diff children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.children;</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldChildren !== newChildren) &#123;</span><br><span class="line">          el.innerHTML = newChildren;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      el.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      newChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> mount(child, el));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(oldChildren) &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span><br><span class="line">      <span class="keyword">const</span> minLength = <span class="built_in">Math</span>.min(oldChildren.length, newChildren.length);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">        patch(oldChildren[i], newChildren[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (oldChildren.length === minLength) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">          mount(newChildren[i], el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; oldChildren.length; i++) &#123;</span><br><span class="line">          el.removeChild(oldChildren[i].el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//replace</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reactivity部分</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.add(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect;</span><br><span class="line">  effect();</span><br><span class="line">  activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!targetMap.has(target)) &#123;</span><br><span class="line">    targetMap.set(target, <span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> depMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depMap.has(key)) &#123;</span><br><span class="line">    depMap.set(key, <span class="keyword">new</span> Dep());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depMap.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reactiveHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// dep</span></span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key);</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    dep.notify();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="mountApp"><a href="#mountApp" class="headerlink" title="mountApp"></a>mountApp</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//component组件实例</span></span><br><span class="line"><span class="comment">//container要挂载的dom元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountApp</span>(<span class="params">component, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isMounted = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> oldVdom;</span><br><span class="line">  watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">      <span class="comment">//第一次挂载</span></span><br><span class="line">      oldVdom = component.render();</span><br><span class="line">      mount(oldVdom, container);</span><br><span class="line">      isMounted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//数据变化,要进行更新</span></span><br><span class="line">      <span class="keyword">const</span> newVdom = component.render();</span><br><span class="line">      patch(oldVdom, newVdom);</span><br><span class="line">      oldVdom = newVdom;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  <span class="attr">data</span>: reactive(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: <span class="function">() =&gt;</span> App.data.count++,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">String</span>(<span class="built_in">this</span>.data.count)</span><br><span class="line">      ),</span><br><span class="line">    ]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一个点击自增的计数器</span></span><br><span class="line">mountApp(App, <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>));</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">根据尤大的教学视频实现 mini-vue 包括diff算法，订阅者模式等等</summary>
    
    
    
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue的diff算法</title>
    <link href="https://andylinwenqin.github.io/2021/06/27/Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    <id>https://andylinwenqin.github.io/2021/06/27/Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/</id>
    <published>2021-06-27T08:49:57.000Z</published>
    <updated>2021-06-27T09:17:16.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue如何操作节点及diff算法"><a href="#Vue如何操作节点及diff算法" class="headerlink" title="Vue如何操作节点及diff算法"></a>Vue如何操作节点及diff算法</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="当数据发生变化时，vue是怎么更新节点的？"><a href="#当数据发生变化时，vue是怎么更新节点的？" class="headerlink" title="当数据发生变化时，vue是怎么更新节点的？"></a>当数据发生变化时，vue是怎么更新节点的？</h3><p>要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。</p><p>我们先根据真实DOM生成一颗<code>virtual DOM</code>，当<code>virtual DOM</code>某个节点的数据改变后会生成一个新的<code>Vnode</code>，然后<code>Vnode</code>和<code>oldVnode</code>作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使<code>oldVnode</code>的值为<code>Vnode</code>。</p><p>diff的过程就是调用名为<code>patch</code>的函数，比较新旧节点，一边比较一边给<strong>真实的DOM</strong>打补丁。</p><h3 id="virtual-DOM和真实DOM的区别？"><a href="#virtual-DOM和真实DOM的区别？" class="headerlink" title="virtual DOM和真实DOM的区别？"></a>virtual DOM和真实DOM的区别？</h3><p>virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的virtual DOM（伪代码）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vnode = &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;123&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（温馨提示：<code>VNode</code>和<code>oldVNode</code>都是对象，一定要记住）</p><h3 id="diff的比较方式？"><a href="#diff的比较方式？" class="headerlink" title="diff的比较方式？"></a>diff的比较方式？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>456<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170145.png"></p><h3 id="diff流程图"><a href="#diff流程图" class="headerlink" title="diff流程图"></a>diff流程图</h3><p>当数据发生改变时，set方法会让调用<code>Dep.notify</code>通知所有订阅者Watcher，订阅者就会调用<code>patch</code>给真实的DOM打补丁，更新相应的视图。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170223.png"></p><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>来看看<code>patch</code>是怎么打补丁的（代码只保留核心部分）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">    <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        patchVnode(oldVnode, vnode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> oEl = oldVnode.el <span class="comment">// 当前oldVnode对应的真实元素节点</span></span><br><span class="line">        <span class="keyword">let</span> parentEle = api.parentNode(oEl)  <span class="comment">// 父元素</span></span><br><span class="line">        createEle(vnode)  <span class="comment">// 根据Vnode生成新元素</span></span><br><span class="line">        <span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</span><br><span class="line">            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) <span class="comment">// 将新元素添加进父元素</span></span><br><span class="line">            api.removeChild(parentEle, oldVnode.el)  <span class="comment">// 移除以前的旧元素节点</span></span><br><span class="line">            oldVnode = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// some code </span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>patch函数接收两个参数<code>oldVnode</code>和<code>Vnode</code>分别代表新的节点和之前的旧节点</p><ul><li>判断两节点是否值得比较，值得比较则执行<code>patchVnode</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;  <span class="comment">// key值</span></span><br><span class="line">    a.tag === b.tag &amp;&amp;  <span class="comment">// 标签名</span></span><br><span class="line">    a.isComment === b.isComment &amp;&amp;  <span class="comment">// 是否为注释节点</span></span><br><span class="line">    <span class="comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span></span><br><span class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;  </span><br><span class="line">    sameInputType(a, b) <span class="comment">// 当标签是&lt;input&gt;的时候，type必须相同</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不值得比较则用<code>Vnode</code>替换<code>oldVnode</code></li></ul><p>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明<code>Vnode</code>完全被改变了，就可以直接替换<code>oldVnode</code>。</p><p>虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。</p><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>当我们确定两个节点值得比较之后我们会对两个节点指定<code>patchVnode</code>方法。那么这个方法做了什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">patchVnode (oldVnode, vnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = vnode.el = oldVnode.el</span><br><span class="line">    <span class="keyword">let</span> i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode.text !== <span class="literal">null</span> &amp;&amp; vnode.text !== <span class="literal">null</span> &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        api.setTextContent(el, vnode.text)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        updateEle(el, vnode, oldVnode)</span><br><span class="line">        <span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class="line">            updateChildren(el, oldCh, ch)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch)&#123;</span><br><span class="line">            createEle(vnode) <span class="comment">//create el&#x27;s children dom</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldCh)&#123;</span><br><span class="line">            api.removeChildren(el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数做了以下事情：</p><ul><li>找到对应的真实dom，称为<code>el</code></li><li>判断<code>Vnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li><li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>Vnode</code>的文本节点。</li><li>如果<code>oldVnode</code>有子节点而<code>Vnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>Vnode</code>有，则将<code>Vnode</code>的子节点真实化之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li></ul><p>其他几个点都很好理解，我们详细来讲一下updateChildren</p><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx</span><br><span class="line">    <span class="keyword">let</span> idxInOld</span><br><span class="line">    <span class="keyword">let</span> elmToMove</span><br><span class="line">    <span class="keyword">let</span> before</span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;   <span class="comment">// 对于vnode.key的比较，会把oldVnode = null</span></span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx] </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode)</span><br><span class="line">            api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode)</span><br><span class="line">            api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 使用key时的比较</span></span><br><span class="line">            <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) <span class="comment">// 有key生成index表</span></span><br><span class="line">            &#125;</span><br><span class="line">            idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">            <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">                api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                elmToMove = oldCh[idxInOld]</span><br><span class="line">                <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    patchVnode(elmToMove, newStartVnode)</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">null</span></span><br><span class="line">                    api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)</span><br><span class="line">                &#125;</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        before = newCh[newEndIdx + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].el</span><br><span class="line">        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说一下这个函数做了什么</p><ul><li>将<code>Vnode</code>的子节点<code>Vch</code>和<code>oldVnode</code>的子节点<code>oldCh</code>提取出来</li><li><code>oldCh</code>和<code>vCh</code>各有两个头尾的变量<code>StartIdx</code>和<code>EndIdx</code>，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了<code>key</code>，就会用<code>key</code>进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx&gt;EndIdx</code>表明<code>oldCh</code>和<code>vCh</code>至少有一个已经遍历完了，就会结束比较。</li></ul><h4 id="图解updateChildren"><a href="#图解updateChildren" class="headerlink" title="图解updateChildren"></a>图解updateChildren</h4><p>终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。</p><p>粉红色的部分为oldCh和vCh</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170936.png"></p><p>我们将它们取出来并分别用s和e指针指向它们的头child和尾child</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627170958.png"></p><p>现在分别对<code>oldS、oldE、S、E</code>两两做<code>sameVnode</code>比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方</p><ul><li>如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后</li><li>如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动</li><li>如果四种匹配没有一对是成功的，那么遍历<code>oldChild</code>，<code>S</code>挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将<code>S对应的节点</code>插入到dom中对应的<code>oldS</code>位置，<code>oldS</code>和<code>S</code>指针向中间移动。</li></ul><p>再配个图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171028.png"></p><ul><li>第一步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldS = a, oldE = d；</span><br><span class="line">S = a, E = b;</span><br></pre></td></tr></table></figure><p><code>oldS</code>和<code>S</code>匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d</p><ul><li>第二步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldS = b, oldE = d；</span><br><span class="line">S = c, E = b;</span><br></pre></td></tr></table></figure><p><code>oldS</code>和<code>E</code>匹配，就将原本的b节点移动到最后，因为<code>E</code>是最后一个节点，他们位置要一致，这就是上面说的：<strong>当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置</strong>，此时dom的位置为：a d b</p><ul><li>第三步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldS = d, oldE = d；</span><br><span class="line">S = c, E = d;</span><br></pre></td></tr></table></figure><p><code>oldE</code>和<code>E</code>匹配，位置不变此时dom的位置为：a d b</p><ul><li>第四步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oldS++;</span><br><span class="line">oldE--;</span><br><span class="line">oldS &gt; oldE;</span><br></pre></td></tr></table></figure><p>遍历结束，说明<code>oldCh</code>先遍历完。就将剩余的<code>vCh</code>节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b</p><p>一次模拟完成。</p><p>这个匹配过程的结束有两个条件：</p><ul><li><code>oldS &gt; oldE</code>表示<code>oldCh</code>先遍历完，那么就将多余的<code>vCh</code>根据index添加到dom中去（如上图）</li><li><code>S &gt; E</code>表示vCh先遍历完，那么就在真实dom中将区间为<code>[oldS, oldE]</code>的多余节点删掉(本图第二第三步画错了应该对换位置)</li></ul><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171110.png"></p><p>下面再举一个例子，可以像上面那样自己试着模拟一下</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171120.png"></p><p>当这些节点<code>sameVnode</code>成功后就会紧接着执行<code>patchVnode</code>了，可以看一下上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。也将dom的所有补丁都打好啦。那么现在再回过去看updateChildren的代码会不会容易很多呢？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上为diff算法的全部过程，放上一张文章开始就发过的总结图，可以试试看着这张图回忆一下diff的过程。</p><p> <img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210627171154.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文摘抄自<a href="https://www.cnblogs.com/wind-lanyan/p/9061684.html">详解vue的diff算法</a></p><p><a href="">尤大的mini-vue</a></p>]]></content>
    
    
    <summary type="html">了解vue如何进行更新节点的</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SPA单页面应用和多页应用优缺点</title>
    <link href="https://andylinwenqin.github.io/2021/06/27/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    <id>https://andylinwenqin.github.io/2021/06/27/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/</id>
    <published>2021-06-27T08:42:42.000Z</published>
    <updated>2021-06-27T08:55:06.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPA单页应用"><a href="#SPA单页应用" class="headerlink" title="SPA单页应用"></a>SPA单页应用</h2><hr><p>其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。</p><p><strong>优 点</strong>: 减轻服务端的压力，可维护性高</p><p><strong>缺点</strong>: 首次加载速度慢，搜索引擎优化效果不好</p><h3 id="为什么首屏时间慢，SEO-差？"><a href="#为什么首屏时间慢，SEO-差？" class="headerlink" title="为什么首屏时间慢，SEO 差？"></a>为什么首屏时间慢，SEO 差？</h3><p>单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。</p><p>SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。</p><h2 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h2><p>多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SPA单页应用&quot;&gt;&lt;a href=&quot;#SPA单页应用&quot; class=&quot;headerlink&quot; title=&quot;SPA单页应用&quot;&gt;&lt;/a&gt;SPA单页应用&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaS</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://andylinwenqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://andylinwenqin.github.io/2021/06/27/Promise/"/>
    <id>https://andylinwenqin.github.io/2021/06/27/Promise/</id>
    <published>2021-06-27T06:39:46.000Z</published>
    <updated>2021-06-27T08:54:58.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="彻底弄懂-Promise-原理"><a href="#彻底弄懂-Promise-原理" class="headerlink" title="彻底弄懂 Promise 原理"></a>彻底弄懂 Promise 原理</h1><hr><p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。</p><p>基本过程：</p><ol><li>初始化 Promise 状态（pending）</li><li>立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li><li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li><li>Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li></ol><p><strong>真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.</strong></p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>先从 Promise 执行结果看一下，有如下一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123; <span class="attr">test</span>: <span class="number">1</span> &#125;)</span><br><span class="line">        resolve(&#123; <span class="attr">test</span>: <span class="number">2</span> &#125;)</span><br><span class="line">        reject(&#123; <span class="attr">test</span>: <span class="number">2</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result1&#x27;</span>, data)</span><br><span class="line">&#125;,<span class="function">(<span class="params">data1</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result2&#x27;</span>,data1)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result3&#x27;</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//result1 &#123; test: 1 &#125;</span></span><br><span class="line"><span class="comment">//result3 undefined</span></span><br></pre></td></tr></table></figure><p>显然这里输出了不同的 data。由此可以看出几点：</p><ol><li>可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。</li><li>只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。</li><li>then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。</li></ol><p>基于以上几点，我们先写个基于 <a href="https://promisesaplus.com/">PromiseA+</a> 规范的只含 resolve 方法的 Promise 模型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">let</span> state = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> callbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            handle(&#123; <span class="comment">//桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中</span></span><br><span class="line">                onFulfilled, </span><br><span class="line">                resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(state === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!callback.onFulfilled)&#123;</span><br><span class="line">                callback.resolve(value)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> ret = callback.onFulfilled(value) <span class="comment">//处理回调</span></span><br><span class="line">            callback.resolve(ret) <span class="comment">//处理下一个 promise 的resolve</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(state !== <span class="string">&#x27;pending&#x27;</span>)<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            state = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">            value = newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(fn,<span class="number">0</span>) <span class="comment">//基于 PromiseA+ 规范</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handelCb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(callbacks.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> fulfiledFn = callbacks.shift();</span><br><span class="line">            handle(fulfiledFn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。</strong></p><p>但是如果仅仅是例子中的情况，我们可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123; <span class="attr">test</span>: <span class="number">1</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result1&#x27;</span>, data)</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//result1 &#123; test: 1 &#125;</span></span><br><span class="line"><span class="comment">//result3</span></span><br></pre></td></tr></table></figure><p>实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(&#123; <span class="attr">test</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;result1&#x27;</span>, data)</span><br><span class="line">  <span class="comment">//dosomething</span></span><br><span class="line">  <span class="keyword">return</span> test()</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;result2&#x27;</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123; <span class="attr">test</span>: <span class="number">2</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于第一个 Promise 模型，执行后的输出</span></span><br><span class="line"><span class="comment">//result1 &#123; test: 1 &#125;</span></span><br><span class="line"><span class="comment">//result2 Promise &#123;then: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(state !== <span class="string">&#x27;pending&#x27;</span>)<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue === <span class="string">&#x27;function&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;then&#125; = newValue</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span></span><br><span class="line">                    <span class="comment">//相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span></span><br><span class="line">                    then.call(newValue,resolve)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">            value = newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(fn,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个模型，再测试我们的例子，就得到了正确的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123; <span class="attr">test</span>: <span class="number">1</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result1&#x27;</span>, data)</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">    <span class="keyword">return</span> test()</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result2&#x27;</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(&#123; <span class="attr">test</span>: <span class="number">2</span> &#125;)</span><br><span class="line">        &#125;, <span class="number">5000</span>)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result1 &#123; test: 1 &#125;</span></span><br><span class="line"><span class="comment">//result2 &#123; test: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。</p><p>显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。</p><p>我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。</p><p>基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表：</p><table><thead><tr><th>Promise</th><th>callback</th></tr></thead><tbody><tr><td>P1</td><td>[{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}]</td></tr><tr><td>P2 (P1 调用 then 时产生)</td><td>[{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}]</td></tr><tr><td>P3 (P2 调用 then 时产生)</td><td>[]</td></tr><tr><td>P4 (执行c1中产生[调用 test ])</td><td>[{onFulfilled:p2resolve,resolve:p5resolve}]</td></tr><tr><td>P5 (调用p2resolve 时，进入 then.call 逻辑中产生)</td><td>[]</td></tr></tbody></table><p>有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是：</p><p>c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; []</p><p>以上就是链式调用的原理了。</p><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。</p><p>完整代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">let</span> state = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> callbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> cb = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled:callback.onRejected;</span><br><span class="line">        <span class="keyword">const</span> next = state === <span class="string">&#x27;fulfilled&#x27;</span>? callback.resolve:callback.reject;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!cb)&#123;</span><br><span class="line">            next(value)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> ret = cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(state !== <span class="string">&#x27;pending&#x27;</span>)<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue === <span class="string">&#x27;function&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;then&#125; = newValue</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span></span><br><span class="line">                    <span class="comment">//相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span></span><br><span class="line">                    then.call(newValue,resolve, reject)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">            value = newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(fn,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fn = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(state !== <span class="string">&#x27;pending&#x27;</span>)<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(error &amp;&amp; (<span class="keyword">typeof</span> error === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> error === <span class="string">&#x27;function&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;then&#125; = error</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">                    then.call(error,resolve, reject)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">            value = error</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(fn,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handelCb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(callbacks.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> fn = callbacks.shift();</span><br><span class="line">            handle(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。</p><p>handle代码改造如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">        callbacks.push(callback)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cb = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled:callback.onRejected;</span><br><span class="line">    <span class="keyword">const</span> next = state === <span class="string">&#x27;fulfilled&#x27;</span>? callback.resolve:callback.reject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!cb)&#123;</span><br><span class="line">        next(value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ret = cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        callback.reject(e);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际使用时，常习惯注册 catch 方法来处理错误，例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123; <span class="attr">test</span>: <span class="number">1</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result1&#x27;</span>, data)</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">    <span class="keyword">return</span> test()</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">ex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, ex)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onError</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.then(<span class="literal">null</span>,onError)</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finally方法"><a href="#Finally方法" class="headerlink" title="Finally方法"></a>Finally方法</h3><p>在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onError</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.then(<span class="literal">null</span>,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.finally = <span class="function"><span class="keyword">function</span> (<span class="params">onDone</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.then(onDone,onDone)</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve-方法和-reject-方法"><a href="#resolve-方法和-reject-方法" class="headerlink" title="resolve 方法和 reject 方法"></a>resolve 方法和 reject 方法</h3><p>实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(&#123;<span class="attr">name</span>:<span class="string">&#x27;winty&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.reject(&#123;<span class="attr">name</span>:<span class="string">&#x27;winty&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(&#123;<span class="attr">name</span>:<span class="string">&#x27;winty&#x27;</span>&#125;))</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> reject(&#123;<span class="attr">name</span>:<span class="string">&#x27;winty&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure><p>这些情况下，Promise.resolve 的入参可能有以下几种情况：</p><ul><li>无参数 [直接返回一个resolved状态的 Promise 对象]</li><li>普通数据对象 [直接返回一个resolved状态的 Promise 对象]</li><li>一个Promise实例 [直接返回当前实例]</li><li>一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。]</li></ul><p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> then = value.then;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                then(resolve);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            reject(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([]);</span><br><span class="line">            <span class="keyword">var</span> remaining = args.length;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">res</span>(<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">var</span> then = val.then;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                            then.call(val, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">                                res(i, val);</span><br><span class="line">                            &#125;, reject);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    args[i] = val;</span><br><span class="line">                    <span class="keyword">if</span>(--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">                        resolve(args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">                    reject(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                res(i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">                values[i].then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://promisesaplus.com/">PromiseA+规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/58428287">Promise 实现原理精解</a></li><li><a href="https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">30分钟，让你彻底明白Promise原理</a></li></ul><h3 id="完整-Promise-模型"><a href="#完整-Promise-模型" class="headerlink" title="完整 Promise 模型"></a>完整 Promise 模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onError</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.finally = <span class="function"><span class="keyword">function</span> (<span class="params">onDone</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.then(onDone, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125; <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; then &#125; = value</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        then(resolve)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(arr)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line">      <span class="keyword">let</span> remaining = args.length</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">res</span>(<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; then &#125; = val</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">              then.call(val, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;, reject)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] = val</span><br><span class="line">          <span class="keyword">if</span> (--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cb = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    <span class="keyword">const</span> next = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     ret = cb(value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; then &#125; = newValue</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span></span><br><span class="line">          <span class="comment">// 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span></span><br><span class="line">          then.call(newValue, resolve, reject)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">      value = newValue</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (error &amp;&amp; (<span class="keyword">typeof</span> error === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> error === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; then &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          then.call(error, resolve, reject)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      value = error</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handelCb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (callbacks.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">reject(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">promise的原理和实现</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="ES6" scheme="https://andylinwenqin.github.io/tags/ES6/"/>
    
    <category term="JS" scheme="https://andylinwenqin.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS的基础知识点</title>
    <link href="https://andylinwenqin.github.io/2021/06/26/JS%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://andylinwenqin.github.io/2021/06/26/JS%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-06-26T12:39:17.000Z</published>
    <updated>2021-06-26T13:42:20.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS的数据类型"><a href="#JS的数据类型" class="headerlink" title="JS的数据类型"></a>JS的数据类型</h2><p>JS一共有6种基本数据类型分别是<code>undefined</code>, <code>null</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>symbol</code>, 引用数据类型<code>object</code>, <code>array</code>, <code>function</code></p><p><code>symbol</code>作用: 定义一个独一无二的值</p><p>基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问</p><p>引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用</p><h2 id="string是个基本数据类型，为什么可以使用String的一些方法"><a href="#string是个基本数据类型，为什么可以使用String的一些方法" class="headerlink" title="string是个基本数据类型，为什么可以使用String的一些方法"></a>string是个基本数据类型，为什么可以使用String的一些方法</h2><p>除去Object, Array等引用类型，JavaScript还提供了三种特殊的引用类型: String, Number和Boolean，方便我们操作对应的基本类型，所以在调用String方法时，并不是基本数据类型stirng执行了自身方法，而是后台为它创建了一个对应的基本包装类型String，它根据基本类型的值实例化了一个实例，让这个实例去调用指定的方法，最后销毁这个实例</p><h2 id="var-let-const的区别"><a href="#var-let-const的区别" class="headerlink" title="var, let, const的区别"></a><code>var</code>, <code>let</code>, <code>const</code>的区别</h2><p><code>var</code>声明的变量没有块级作用域而<code>let</code>声明的变量拥有块级作用域，<code>const</code>声明的是常量，声明之后无法对其进行修改， <code>const</code>保证的实际上并不是变量的值不得改变，而是变量指向的那个内存地址不得改动，对于复合类型的数据如对象，数组，变量指向的内存地址保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的</p><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的，在语法上称为暂时性死区</p><h2 id="Object-is的区别"><a href="#Object-is的区别" class="headerlink" title="==, ===, Object.is的区别"></a><code>==</code>, <code>===</code>, <code>Object.is</code>的区别</h2><p><code>==</code>: 会进行强制的类型转换,在转换类型后，二者相等也会返回True,而<code>===</code>不会进行转换, <code>Object.is</code>也不会进行强制类型转换，但与<code>===</code>不同的是，<code>+0===0</code>, <code>Object.is(+0, -0) false</code>, <code>Nan !== Nan, Object.is(Nan, Nan) false</code></p><p>如果Type(x)和Type(y)相同，返回x===y的结果<br>如果Type(x)和Type(y)不同<br>如果x是null，y是undefined，返回true<br>如果x是undefined，y是null，返回true<br>如果Type(x)是Number，Type(y)是String，返回 x==ToNumber(y) 的结果<br>如果Type(x)是String，Type(y)是Number，返回 ToNumber(x)==y 的结果<br>如果Type(x)是Boolean，返回 ToNumber(x)==y 的结果<br>如果Type(y)是Boolean，返回 x==ToNumber(y) 的结果<br>如果Type(x)是String或Number或Symbol中的一种并且Type(y)是Object，返回 x==ToPrimitive(y) 的结果<br>如果Type(x)是Object并且Type(y)是String或Number或Symbol中的一种，返回 ToPrimitive(x)==y 的结果<br>其他返回false</p><h2 id="slice-和splice-的区别"><a href="#slice-和splice-的区别" class="headerlink" title="slice()和splice()`的区别"></a>slice()<code>和</code>splice()`的区别</h2><p><code>slice</code>: 只能截取数组中的一段，且截取后原数据不会发生变化;</p><p><code>splice</code>: 不仅仅能够截取数组中的一段，还能够在原数组中进行替换</p><h2 id="push-pop-shift-和unshift"><a href="#push-pop-shift-和unshift" class="headerlink" title="push(), pop(), shift()和unshift()"></a><code>push()</code>, <code>pop()</code>, <code>shift()</code>和<code>unshift()</code></h2><p>(1). <code>push</code>, <code>pop</code>:类似于栈的行为，后进先出</p><p>(2). <code>shift</code>, <code>unshift</code>: 类似于队列的行为, 先进先出</p><p>数组方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>). 修改器方法</span><br><span class="line"></span><br><span class="line">    push, pop, unshift, shift, sort, reverse, splice</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>). 访问方法 (返回新的数组)</span><br><span class="line"></span><br><span class="line">    concat, slice</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>). 迭代方法</span><br><span class="line"></span><br><span class="line">    forEach, filter, map, reduce</span><br></pre></td></tr></table></figure><h2 id="map和set"><a href="#map和set" class="headerlink" title="map和set"></a><code>map</code>和<code>set</code></h2><p>map是一组键值对的结构，具有极快的查找速度</p><p>set和map类似，也是一组key的集合，但不储存value，在set中，key不可重复</p><p>现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。</p><h2 id="null和undefined，怎么判断是null"><a href="#null和undefined，怎么判断是null" class="headerlink" title="null和undefined，怎么判断是null"></a><code>null</code>和<code>undefined</code>，怎么判断是<code>null</code></h2><p><code>null</code>: 表示一个值被定义了，定义为”空值”;</p><p><code>undefined</code>: 表示根本不存在定义;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exp = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> (exp) === <span class="string">&#x27;undefined&#x27;</span>) <span class="built_in">console</span>.log(<span class="string">&#x27;undefined&#x27;</span>);</span><br><span class="line"></span><br><span class="line">exp = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (!exp) <span class="built_in">console</span>.log(<span class="string">&#x27;null&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><code>arguments</code></h2><p>在调用函数时，我们所传递的实参都会在<code>arguments</code>中保存，是一个类似于数组的对象，只有数组的length，没有数组方法</p><h2 id="call-apply和bind的用法"><a href="#call-apply和bind的用法" class="headerlink" title="call, apply和bind的用法"></a>call, apply和bind的用法</h2><p>call, apply, bind都是用来改变<code>this</code>的指向</p><p>apply接收两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接收的参数，以数组的形式进行传递</p><p>call第一个参数也是用来改变<code>this</code>的指向，后面的参数均是函数接收的参数</p><p><strong>apply与call均只改变this的指向一次</strong></p><p>bind第一个参数也是改变<code>this</code>的指向，后面与call类似也是传入参数列表，但与call不同的是，bind的可以不需要一次性传入所有参数，并且bind改变<code>this</code>指向后不会立即执行而是返回一个永久改变<code>this</code>指向的函数</p><p>三者的区别:</p><p>(1). 都可以改变<code>this</code>的指向;<br>(2). 第一个参数都是<code>this</code>要指向的对象;<br>(3). 三个都可以传参，但是方法各不相同，apply是数组，bind和call都是利用参数列表进行传参但是bind可以分多次传参，call只可以传一次;<br>(4). bind是返回绑定<code>this</code>之后的函数，apply和call是立即调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// step 1: 调用函数的上下文指向obj</span><br><span class="line">// step 2: 传参</span><br><span class="line">// step 3: 执行函数并返回结果</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myApply = <span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments][<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> (!args) <span class="keyword">return</span> context.fn()</span><br><span class="line">  <span class="keyword">let</span> res = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCall = <span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> res = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myBind = <span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> me = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> me.call(context, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CommonJS和ES6模块的区别"><a href="#CommonJS和ES6模块的区别" class="headerlink" title="CommonJS和ES6模块的区别"></a>CommonJS和ES6模块的区别</h2><p>(1). CommonJS输出的是一个值的拷贝，ES6模块输出的是值的引用，换句话说就是CommonJS在模块内部发生的后续变化影响不了外部对这个值的使用;</p><p>(2). CommonJS模块是运行时加载，ES6模块是编译时输出接口;</p><p>(3). CommonJS顶层<code>this</code>指向当前模块, 而在ES6模块中<code>this</code>指向<code>undefined</code></p><h2 id="innerHtml-innerText-outerHtml"><a href="#innerHtml-innerText-outerHtml" class="headerlink" title="innerHtml, innerText, outerHtml"></a><code>innerHtml</code>, <code>innerText</code>, <code>outerHtml</code></h2><p><code>innerHtml</code>: 是指从对象的起始位置到终止位置的全部内容包括html标签</p><p><code>innerText</code>: 从起始位置到终止位置的内容，不包括html标签</p><p><code>outerHtml</code>: 除了包含<code>innerHtml</code>全部内容外还包含了对象标签本身</p><p>怎么判断是数组</p><p>(1). <code>instanceof</code>;</p><p>(2). <code>constructor</code> <code>arr.constructor === Array</code>; </p><p>(3). <code>toString</code> example: <code>Object.prototype.toString.call(arr) === &#39;[object Array]&#39;;</code>; </p><p>(4). <code>Array.isArray(arr)</code></p><h2 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h2><p>浅拷贝: 直接将数组引用复制的方法是浅拷贝</p><p>深拷贝: 递归复制了所有层级 <code>JSON.parse(JSON.stringify(arr));</code> <code>slice和concat在多维数组中无效</code></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包就是能够读取其他函数内部变量的函数，本质上闭包就是函数内部与函数外部的一座桥梁</p><h2 id="promise与async-await"><a href="#promise与async-await" class="headerlink" title="promise与async/await"></a><code>promise</code>与<code>async/await</code></h2><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了</p><p>说到底，Promise 也还是使用回调函数，只不过是把回调封装在了内部，使用上一直通过 then 方法的链式调用，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。</p><p>promise可解决回调地狱的问题</p><p>(1). <code>promise</code>是ES6的语法，<code>async/await</code>是ES7的语法;</p><p>(2). <code>promise</code>的错误可以通过catch来捕捉，而<code>async/await</code>的错误用<code>try-catch</code>来捕捉，因为<code>await</code>只会返回<code>promise</code>成功的值;</p><p>async与generator</p><p>async相当于自执行的generator函数，相当于自带一个状态机，在await的部分等待即过，返回后自动执行下一步</p><h2 id="js中0-1-0-2为什么不等于0-3-怎么解决"><a href="#js中0-1-0-2为什么不等于0-3-怎么解决" class="headerlink" title="js中0.1+0.2为什么不等于0.3,怎么解决"></a>js中0.1+0.2为什么不等于0.3,怎么解决</h2><p>计算机是用二进制储存数的，而十进制小数转二进制的方法是用2去乘小数部分，这会导致小数不能精确的表达所以当两个小数相加时，很有可能产生误差</p><p>解决方法是可以将数组转为整数先进行加法再除以他们放大的倍数或者利用第三方库</p><h2 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h2><p>(1). 标记清理 在垃圾程序运行的时候，会标记内存中存储的所有变量然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存   ;<br>(2). 引用计数 对每个值都记录它被引用的次数，声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1，类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.当一个值的引用数为0时，就说明没发再访问这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存;</p><p>垃圾回收算法: (1). 标记空间中可达的值; (2). 回收不可达的值所占据的内存; (3). 做内存整理;</p><p>分代收集:</p><p>(1). 浏览器将数据分为两种，一种是临时对象，一种是长久对象;<br>(2). 临时对象: 函数内部声明的变量，块级作用域中的变量; 长久对象: 生命周期很长的对象，比如全局的window，DOM<br>(3). 两种不同的对象对应不同的回收策略，V8把堆分成新生代和老生代两个区域，新生代中存放临时对象，老生代中存放持久对象并且让副垃圾回收器，主垃圾回收器分别负责新生代和老生代的垃圾回收，这样就可以高效的垃圾回收<br>(4). 主垃圾回收器: 负责老生代的垃圾回收，有两个特点: 对象占用空间大，对象存活时间长。它使用标记清除的算法执行垃圾回收。在遍历的过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据，然后是垃圾清除，直接将标记为垃圾的数据清理掉，这样会产生大量的不连续的内存碎片，需要进行内存整理<br>(5). 副垃圾回收器: 负责新生代的垃圾回收，通常只支持1-8M的容量，新生代被分为两个区域：一般是对象区域，一半是空闲区域。<br>新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。先给对象区域所有垃圾做标记；标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍；<br>这就回到我们前面留下的问题 – 副垃圾回收器没有碎片整理。因为空闲区域里此时是有序的，没有碎片，也就不需要整理了；复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。这样，就完成了垃圾回收。因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS的数据类型&quot;&gt;&lt;a href=&quot;#JS的数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS的数据类型&quot;&gt;&lt;/a&gt;JS的数据类型&lt;/h2&gt;&lt;p&gt;JS一共有6种基本数据类型分别是&lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://andylinwenqin.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>let var const</title>
    <link href="https://andylinwenqin.github.io/2021/06/26/let-var-const/"/>
    <id>https://andylinwenqin.github.io/2021/06/26/let-var-const/</id>
    <published>2021-06-26T12:36:09.000Z</published>
    <updated>2021-06-26T12:50:59.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="var-let-const的区别"><a href="#var-let-const的区别" class="headerlink" title="var, let, const的区别"></a><code>var</code>, <code>let</code>, <code>const</code>的区别</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><code>var</code>声明的变量没有块级作用域而<code>let</code>声明的变量拥有块级作用域，</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code>声明的是常量，声明之后无法对其进行修改， <code>const</code>保证的实际上并不是变量的值不得改变，而是变量指向的那个内存地址不得改动，对于复合类型的数据如对象，数组，变量指向的内存地址保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的，在语法上称为暂时性死区</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;var-let-const的区别&quot;&gt;&lt;a href=&quot;#var-let-const的区别&quot; class=&quot;headerlink&quot; title=&quot;var, let, const的区别&quot;&gt;&lt;/a&gt;&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, </summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="ES6" scheme="https://andylinwenqin.github.io/tags/ES6/"/>
    
    <category term="JS" scheme="https://andylinwenqin.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器工作原理</title>
    <link href="https://andylinwenqin.github.io/2021/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://andylinwenqin.github.io/2021/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-26T07:25:39.000Z</published>
    <updated>2021-06-26T09:21:12.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从输入-URL-到页面加载完成的过程中都发生了什么？"><a href="#从输入-URL-到页面加载完成的过程中都发生了什么？" class="headerlink" title="从输入 URL 到页面加载完成的过程中都发生了什么？"></a>从输入 URL 到页面加载完成的过程中都发生了什么？</h1><h2 id="简单路径线（掌握即可）："><a href="#简单路径线（掌握即可）：" class="headerlink" title="简单路径线（掌握即可）："></a>简单路径线（掌握即可）：</h2><p>1.键盘或触屏输入URL并回车确认</p><p>2.URL解析/DNS解析查找域名IP地址</p><p>3.网络连接发起HTTP请求</p><p>4.HTTP报文传输过程</p><p>5.服务器接收数据</p><p>6.服务器响应请求/MVC</p><p>7.服务器返回数据</p><p>8.客户端接收数据</p><p>9.浏览器加载/渲染页面</p><p>10.打印绘制输出</p><h2 id="详细路径线（看看就好）："><a href="#详细路径线（看看就好）：" class="headerlink" title="详细路径线（看看就好）："></a>详细路径线（看看就好）：</h2><h3 id="键盘或触屏输入URL并回车确认"><a href="#键盘或触屏输入URL并回车确认" class="headerlink" title="键盘或触屏输入URL并回车确认"></a>键盘或触屏输入URL并回车确认</h3><p>事情的开端要追溯到服务器启动监听服务的时候，在某个未知的时刻，一台机房里普普通通的服务器，加上电，启动了操作系统，随着操作系统的就绪，服务器启动了 http 服务进程，这个 http 服务的守护进程（daemon），可能是 Apache、Nginx、IIS、Lighttpd中的一个，不管怎么说，这个 http 服务进程开始定位到服务器上的 www 文件夹（网站根目录），一般是位于 /var/www ，然后启动了一些附属的模块，例如 php，或者，使用 fastcgi 方式连接到 php 的 fpm 管理进程，然后，向操作系统申请了一个 tcp 连接，然后绑定在了 80 端口，调用了 accept 函数，开始了默默的监听，监听着可能来自位于地球任何一个地方的请求，随时准备做出响应。这个时候，典型的情况下，机房里面应该还有一个数据库服务器，或许，还有一台缓存服务器，如果对于流量巨大的网站，那么动态脚本的解释器可能还有单独的物理机器来跑，如果是中小的站点，那么，上述的各色服务，甚至都可能在一台物理机上，这些服务监听之间的关系，可以通过自己搭建一次 Apache PHP MySQL 环境来了解一下，不管怎么说，他们做好了准备，静候差遣。<br> 然后是开始键盘或手机触屏输入URL，然后通过某种机制传到CPU（过程略），CPU进行内部处理（过程略），处理完后，再从CPU传到操作系统内核（过程略），然后再由操作系统GUI传到浏览器，再由浏览器到浏览器内核。（很浅显意会即可）</p><p>上面一步操作系统 GUI 会将输入事件传递到浏览器中，在这过程中，浏览器可能会做一些预处理，甚至已经在智能匹配所有可能的URL了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的URL，来预估所输入字符对应的网站，然后给出智能提示，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「<a href="https://link.jianshu.com/?t=http://www.baidu.com">www.baidu.com</a> 」，因此就会在输入回车前就马上开始建立 TCP 链接了。对于 Chrome这种变态的浏览器，他甚至会直接从缓存中把网页渲染出来，就是说，你还没有按下「回车」键，页面就已经出来了，再比如Chrome会在浏览器启动时预先查询10个你有可能访问的域名等等，这里面还有很多其它策略，不详细讲了。感兴趣的推荐阅读 <a href="https://link.jianshu.com/?t=http://aosabook.org/en/posa/high-performance-networking-in-chrome.html">High Performance Networking in Chrome</a>。</p><h3 id="URL-解析-DNS-查询"><a href="#URL-解析-DNS-查询" class="headerlink" title="URL 解析/DNS 查询"></a>URL 解析/DNS 查询</h3><p>接着是输入 URL 「回车」后，这时浏览器会对 URL 进行检查，这里需要对URL有个回顾，请见百科《<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/url">URL</a>》，完整的URL由几个部分构成：<br><strong>协议、网络地址、资源路径、文件名、动态参数</strong></p><p><strong>URL完整格式为：协议://用户名:密码@子域名.域名.顶级域名:<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a>/目录/文件名.文件后缀?参数=值#标志</strong><br> 例如：<a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/55998388/answer/166987812">https://www.zhihu.com/question/55998388/answer/166987812</a><br> 协议部分：https<br> 网络地址：<a href="https://link.jianshu.com/?t=http://www.zhihu.com">www.zhihu.com</a>（依次为 子/三级域名.二级域名.顶/一级域名）<br> 资源路径：/question/55998388/answer/166987812</p><p><strong>DNS递归查询和迭代查询的区别</strong>？<br> 递归查询是以本地名称服务器为中心的，是DNS客户端和服务器之间的查询活动，递归查询的过程中“查询的递交者” 一直在更替，其结果是直接告诉DNS客户端需要查询的网站目标IP地址。<br> 迭代查询则是DNS客户端自己为中心的，是各个服务器和服务器之间的查询活动，迭代查询的过程中“查询的递交者”一直没变化，其结果是间接告诉DNS客户端另一个DNS服务器的地址。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210626171452.webp"></p><h3 id="应用层客户端发送HTTP请求"><a href="#应用层客户端发送HTTP请求" class="headerlink" title="应用层客户端发送HTTP请求"></a>应用层客户端发送HTTP请求</h3><p>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210626171604.webp"></p><p>从上面的步骤中得到 IP 地址后，浏览器会开始构造一个 HTTP 请求，应用层客户端向服务器端发送的HTTP请求包括：请求报头和请求主体两个部分，其中请求报头（request header）包含了至关重要的信息，包括请求的方法（GET / POST和不常用的PUT / DELETE以及更不常用的HEAD / OPTION / TRACE，一般的浏览器只能发起 GET 或者 POST 请求）、目标url、遵循的协议（HTTP / HTTPS / FTP…），返回的信息是否需要缓存，以及客户端是否发送Cookie等信息。需要注意的是，因为 HTTP 请求是纯文本格式的，所以在 TCP 的数据段中可以直接分析 HTTP 文本的。</p><h3 id="传输层TCP传输报文"><a href="#传输层TCP传输报文" class="headerlink" title="传输层TCP传输报文"></a>传输层TCP传输报文</h3><p>当应用层的 HTTP 请求准备好后，浏览器会在传输层发起一条到达服务器的 TCP 连接，位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210626171928.webp"></p><p>这里需要谈一下 TCP 的 Head-of-line blocking 问题：假设客户端的发送了 3 个 TCP 片段（segments），编号分别是 1、2、3，如果编号为 1 的包传输时丢了，即便编号 2 和 3 已经到达也只能等待，因为 TCP 协议需要保证顺序，这个问题在 HTTP pipelining 下更严重，因为 HTTP pipelining 可以让多个 HTTP 请求通过一个 TCP 发送，比如发送两张图片，可能第二张图片的数据已经全收到了，但还得等第一张图片的数据传到。为了解决 TCP 协议的性能问题，Chrome 团队提出了 <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/QUIC">QUIC</a> 协议，它是基于 UDP 实现的可靠传输，比起 TCP，它能减少很多来回（round trip）时间，还有前向纠错码（Forward Error Correction）等功能。目前 Google Plus、 Gmail、Google Search、blogspot、Youtube 等几乎大部分 Google 产品都在使用 QUIC，可以通过<a href="https://link.jianshu.com/?t=chrome://net-internals/#spdy">chrome://net-internals/#spdy</a> 页面来发现。另外，浏览器对同一个域名有连接数限制，<a href="https://link.jianshu.com/?t=http://www.browserscope.org/?category=network&v=top">大部分是 6</a>，但并非将这个连接数改大后就会提升性能，Chrome 团队有做过实验，发现从 6 改成 10 后性能反而下降了，造成这个现象的因素有很多，如建立连接的开销、拥塞控制等问题，而像 SPDY、HTTP 2.0 协议尽管只使用一个 TCP 连接来传输数据，但性能反而更好，而且还能实现请求优先级。</p><h3 id="网络层IP协议查询MAC地址"><a href="#网络层IP协议查询MAC地址" class="headerlink" title="网络层IP协议查询MAC地址"></a>网络层IP协议查询MAC地址</h3><p>IP协议的作用是把TCP分割好的各种数据包封装到IP包里面传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址才可以。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p><h3 id="数据到达数据链路层"><a href="#数据到达数据链路层" class="headerlink" title="数据到达数据链路层"></a>数据到达数据链路层</h3><p>在找到对方的MAC地址后，已被封装好的IP包再被封装到数据链路层的数据帧结构中，将数据发送到数据链路层传输，再通过物理层的比特流送出去。这时，客户端发送请求的阶段结束。</p><h3 id="服务器接收数据"><a href="#服务器接收数据" class="headerlink" title="服务器接收数据"></a>服务器接收数据</h3><p>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。</p><h3 id="服务器响应请求并返回相应文件"><a href="#服务器响应请求并返回相应文件" class="headerlink" title="服务器响应请求并返回相应文件"></a>服务器响应请求并返回相应文件</h3><p>服务接收到客户端发送的HTTP请求后，服务器上的的 http 监听进程会得到这个请求，然后一般情况下会启动一个新的子进程去处理这个请求，同时父进程继续监听。http 服务器首先会查看重写规则，然后如果请求的文件是真实存在，例如一些图片，或 html、css、js 等静态文件，则会直接把这个文件返回，如果是一个动态的请求，那么会根据 url 重写模块的规则，把这个请求重写到一个 rest 风格的 url 上，然后根据动态语言的脚本，来决定调用什么类型的动态文件脚本解释器来处理这个请求。</p><p>我们以 php 语言为例来说的话，请求到达一个 php 的 mvc 框架之后，框架首先应该会初始化一些环境的参数，例如远端 ip，请求参数等等，然后根据请求的 url 送到一个路由器类里面去匹配路由，路由由上到下逐条匹配，一旦遇到 url 能够匹配的上，而且请求的方法也能够命中的话，那么请求就会由这个路由所定义的处理方法去处理。</p><p>请求进入处理函数之后，如果客户端所请求需要浏览的内容是一个动态的内容，那么处理函数会相应的从数据源里面取出数据，这个地方一般会有一个缓存，例如 memcached 来减小 db 的压力，如果引入了 orm 框架的话，那么处理函数直接向 orm 框架索要数据就可以了，由 orm 框架来决定是使用内存里面的缓存还是从 db 去取数据，一般缓存都会有一个过期的时间，而 orm 框架也会在取到数据回来之后，把数据存一份在内存缓存中的。</p><p>orm 框架负责把面向对象的请求翻译成标准的 sql 语句，然后送到后端的 db 去执行，db 这里以 mysql 为例的话，那么一条 sql 进来之后，db 本身也是有缓存的，不过 db 的缓存一般是用 sql 语言 hash 来存取的，也就是说，想要缓存能够命中，除了查询的字段和方法要一样以外，查询的参数也要完全一模一样才能够使用 db 本身的查询缓存，sql 经过查询缓存器，然后就会到达查询分析器，在这里，db 会根据被搜索的数据表的索引建立情况，和 sql 语言本身的特点，来决定使用哪一个字段的索引，值得一提的是，即使一个数据表同时在多个字段建立了索引，但是对于一条 sql 语句来说，还是只能使用一个索引，所以这里就需要分析使用哪个索引效率最高了，一般来说，sql 优化在这个点上也是很重要的一个方面。</p><p>sql 由 db 返回结果集后，再由 orm 框架把结果转换成模型对象，然后由 orm 框架进行一些逻辑处理，把准备好的数据，送到视图层的渲染引擎去渲染，渲染引擎负责模板的管理，字段的友好显示，也包括负责一些多国语言之类的任务。对于一条请求在 mvc 中的生命周期，可以参考这里，<a href="https://link.jianshu.com/?t=http://zrj.me/archives/404">临摹了一个 PHP MVC 框架</a>，在视图层把页面准备好后，再从动态脚本解释器送回到 http 服务器，由 http 服务器把这些正文加上一个响应头，封装成一个标准的 http 响应包，再通过 tcp ip 协议，送回到客户机浏览器。</p><h3 id="浏览器开始处理数据信息并渲染页面"><a href="#浏览器开始处理数据信息并渲染页面" class="headerlink" title="浏览器开始处理数据信息并渲染页面"></a>浏览器开始处理数据信息并渲染页面</h3><p>历经千辛万苦，我们请求的响应终于成功到达了客户端的浏览器，响应到达浏览器之后，浏览器首先会根据返回的响应报文里的一个重要信息——状态码，来做个判断。如果是 200 开头的就好办，表示请求成功，直接进入渲染流程，如果是 300 开头的就要去相应头里面找 location 域，根据这个 location 的指引，进行跳转，这里跳转需要开启一个跳转计数器，是为了避免两个或者多个页面之间形成的循环的跳转，当跳转次数过多之后，浏览器会报错，同时停止。比如：301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。如果是 400 开头或者 500 开头的状态码，浏览器也会给出一个错误页面。比如：404 not found 就表示客户端请求的资源找不到。</p><p>当浏览得到一个正确的 200 响应之后，接下来面临的一个问题就是多国语言的编码解析了，响应头是一个 ascii 的标准字符集的文本，这个还好办，但是响应的正文本质上就是一个字节流，对于这一坨字节流，浏览器要怎么去处理呢？首先浏览器会去看响应头里面指定的 encoding 域，如果有了这个东西，那么就按照指定的 encoding 去解析字符，如果没有的话，那么浏览器会使用一些比较智能的方式，去猜测和判断这一坨字节流应该使用什么字符集去解码。相关的笔记可以看这里，<a href="https://www.jianshu.com/p/d38a79a4f0f4">字符集编码</a></p><p>接下来就是构建 dom 树了，在 html 语言嵌套正常而且规范的情况下，这种 xml 标记的语言是比较容易的能够构建出一棵 dom 树出来的，当然，对于互联网上大量的不规范的页面，不同的浏览器应该有自己不同的容错去处理。构建出来的 dom 本质上还是一棵抽象的逻辑树，构建 dom 树的过程中，如果遇到了由 script 标签包起来的 js 动态脚本代码，那么会把代码送到 js 引擎里面去跑，如果遇到了 style 标签包围起来的 css 代码，也会保存下来，用于稍后的渲染。如果遇到了 img 或 css 和 js等引用外部文件的标签，那么浏览器会根据指定的 url 再次发起一个新的 http 请求，去把这个文件拉取回来，值得一提的是，对于同一个域名下的下载过程来说，浏览器一般允许的并发请求是有限的，通常控制在两个左右，所以如果有很多的图片的话，一般出于优化的目的，都会把这些图片使用一台静态文件的服务器来保存起来，负责响应，从而减少主服务器的压力。</p><p>dom 树构造好了之后，就是根据 dom 树和 css 样式表来构造 render 树了，这个才是真正的用于渲染到页面上的一个一个的矩形框的树，网页渲染是浏览器最复杂、最核心的功能，对于 render 树上每一个框，需要确定他的 x y 坐标，尺寸，边框，字体，形态，等等诸多方面的东西，render 树一旦构建完成，整个页面也就准备好了，可以上菜了。需要说明的是，下载页面，构建 dom 树，构建 render 树这三个步骤，实际上并不是严格的先后顺序的，为了加快速度，提高效率，让用户不要等那么久，现在一般都并行的往前推进的，现代的浏览器都是一边下载，下载到了一点数据就开始构建 dom 树，也一边开始构建 render 树，构建了一点就显示一点出来，这样用户看起来就不用等待那么久了。</p><h3 id="将渲染好的页面图像显示出来，并开始响应用户的操作"><a href="#将渲染好的页面图像显示出来，并开始响应用户的操作" class="headerlink" title="将渲染好的页面图像显示出来，并开始响应用户的操作"></a>将渲染好的页面图像显示出来，并开始响应用户的操作</h3><p>这一步主要涉及显卡，内存及显示器原理等知识，不做详细解说，大概就是从内存到 LCD/LED，再由光线进入人眼的一个过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上过程简单讲主要是：从输入 URL 到浏览器接收（回车前），从浏览器接收到数据如何发送给网卡（回车后），再把接收的数据从本机网卡发送到服务器，服务器接收到数据后做了怎么的处理？服务器返回数据后浏览器又做了哪些处理？浏览器又是如何将处理好的页面展现在屏幕上的？的这么一个过程。<br> 但只是最基本的一些步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及。即使基本步骤本身也有很复杂的子步骤，TCP/IP、DNS、HTTP、HTML等等，还需要考虑很多情况，比如广播、拆包解包合并包丢包重传、路由表，NAT、TCP 状态机、CDN、HTTPS 证书校验与中间人攻击检测、RSA 密钥协商、AES 加解密、浏览器解析 HTTP 的有限自动状态机、GUI 库与绘图、OpenGL 绘图、GPU 加速（OpenCL 与 CUDA）、JIT（JavaScript 会把 JavaScript 代码编译成汇编代码）、服务器的数据库 NoSQL 或 SQL 查询、主从数据库同步、服务器和浏览器的内存管理（WebKit 实现的 fastMalloc()，服务器上可能是 TCMalloc 或者 JeMalloc）、服务器上的语言解释器（可能也是 JIT）、多媒体：傅里叶变换、H.264 解码（硬件解码，硬件解码的话 GPU 的处理单元又在计算…….或软件解码）、音频解码、WebGL 绘图、浏览器的 Sandbox、服务器的 SQL 注入检查、产生的键盘中断信号处理（或者是高级层面的输入输出驱动）、网卡驱动、网络栈的 TCP FastOpen、SYN Cookie 之类众多技术……每一个都可以展开成庞大的课题，而浏览器的基础——操作系统、编译器、硬件等更是一个比一个复杂。即便是计算机专业的同学看了也会头大，但我保证这里面的每一个步骤都经过深思熟虑和时间的考验的，并不是谁闲的蛋疼非要搞得那么复杂，不复杂也不行啊。你输入URL即可浏览互联网，而计算机系统在背后做了无数你看不到的工作，计算机各个子领域无数工程师为此付出了你难以想象的努力。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p> <a href="https://link.jianshu.com/?t=http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html">了解html页面的渲染过程</a><br> <a href="https://link.jianshu.com/?t=https://leohxj.gitbooks.io/front-end-database/content/">前端工程师手册</a><br> <a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000005169412">浏览器渲染那些事</a><br> <a href="https://link.jianshu.com/?t=http://fex.baidu.com/blog/2014/05/what-happen/">手机上从输入URL到页面加载完成的过程中都发生了什么？</a><br> <a href="https://link.jianshu.com/?t=https://github.com/skyline75489/what-happens-when-zh_CN">当页面渲染时，浏览器发生了什么？</a><br> <a href="https://link.jianshu.com/?t=https://www.chengrang.com/how-browsers-work.html">浏览器工作原理分析与首屏加载</a><br> <a href="https://link.jianshu.com/?t=https://www.youtube.com/watch?v=eeS4brbDVuU">https://www.youtube.com/watch?v=eeS4brbDVuU</a></p><p><a href="https://www.jianshu.com/p/d616d887953a">卐鑫卍</a></p>]]></content>
    
    
    <summary type="html">从URL输入到页面展现到底发生了什么？</summary>
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="性能优化" scheme="https://andylinwenqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="html&amp;浏览器" scheme="https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>重排和重绘</title>
    <link href="https://andylinwenqin.github.io/2021/06/26/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/"/>
    <id>https://andylinwenqin.github.io/2021/06/26/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</id>
    <published>2021-06-26T06:27:49.000Z</published>
    <updated>2021-07-11T06:47:17.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重排-reflow-和重绘-repaint"><a href="#重排-reflow-和重绘-repaint" class="headerlink" title="重排(reflow)和重绘(repaint)"></a>重排(reflow)和重绘(repaint)</h1><hr><h2 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h2><p>1.HTML 被 HTML 解析器解析成 DOM 树；</p><p>2.CSS  被 CSS 解析器解析成 CSSOM 树；</p><p>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</p><p>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</p><p>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210626143116.webp"></p><h2 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h2><p>在页面的生命周期中，网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p><h2 id="重排比重绘大："><a href="#重排比重绘大：" class="headerlink" title="重排比重绘大："></a>重排比重绘大：</h2><p>大，在这个语境里的意思是：谁能影响谁？</p><ul><li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li><li>重排：重新生成布局，重新排列元素。</li></ul><p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。</p><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p><h2 id="重排-reflow-："><a href="#重排-reflow-：" class="headerlink" title="重排(reflow)："></a>重排(reflow)：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p><p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p><h3 id="下面情况会发生重排："><a href="#下面情况会发生重排：" class="headerlink" title="下面情况会发生重排："></a>下面情况会发生重排：</h3><ul><li>页面初始渲染，这是开销最大的一次重排</li><li>添加/删除可见的DOM元素</li><li>改变元素位置</li><li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li><li>改变元素内容，比如文字数量，图片大小等</li><li>改变元素字体大小</li><li>改变浏览器窗口尺寸，比如resize事件发生时</li><li>激活CSS伪类（例如：<code>:hover</code>）</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><table><thead><tr><th>常见引起重排属性和方法</th><th>–</th><th>–</th><th>–</th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border-width</td><td>border</td><td>position</td></tr><tr><td>overflow</td><td>font-size</td><td>vertical-align</td><td>min-height</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>clientTop</td><td>clientLeft</td></tr><tr><td>offsetWudth</td><td>offsetHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>scrollIntoView()</td><td>scrollTo()</td><td>getComputedStyle()</td><td></td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewIfNeeded()</td><td></td><td></td></tr></tbody></table><h3 id="重排影响的范围："><a href="#重排影响的范围：" class="headerlink" title="重排影响的范围："></a>重排影响的范围：</h3><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;/h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;/h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h2 id="重绘-Repaints"><a href="#重绘-Repaints" class="headerlink" title="重绘(Repaints):"></a>重绘(Repaints):</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p><h3 id="常见的引起重绘的属性："><a href="#常见的引起重绘的属性：" class="headerlink" title="常见的引起重绘的属性："></a>常见的引起重绘的属性：</h3><table><thead><tr><th>属性：</th><th>–</th><th>–</th><th>–</th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td>background-size</td><td></td></tr></tbody></table><h2 id="重排优化建议："><a href="#重排优化建议：" class="headerlink" title="重排优化建议："></a>重排优化建议：</h2><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li></ul><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><h4 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h4><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var left = 10;</span><br><span class="line">var top = 10;</span><br><span class="line">el.style.left = left + &quot;px&quot;;</span><br><span class="line">el.style.top = top + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">// 当top和left的值是动态计算而成时...</span><br><span class="line">// better </span><br><span class="line">el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br><span class="line"></span><br><span class="line">// better</span><br><span class="line">el.className += &quot; className&quot;;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h4><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// bad 强制刷新 触发四次重排+重绘</span><br><span class="line">div.style.left = div.offsetLeft + 1 + &#x27;px&#x27;;</span><br><span class="line">div.style.top = div.offsetTop + 1 + &#x27;px&#x27;;</span><br><span class="line">div.style.right = div.offsetRight + 1 + &#x27;px&#x27;;</span><br><span class="line">div.style.bottom = div.offsetBottom + 1 + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span><br><span class="line">var curLeft = div.offsetLeft;</span><br><span class="line">var curTop = div.offsetTop;</span><br><span class="line">var curRight = div.offsetRight;</span><br><span class="line">var curBottom = div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left = curLeft + 1 + &#x27;px&#x27;;</span><br><span class="line">div.style.top = curTop + 1 + &#x27;px&#x27;;</span><br><span class="line">div.style.right = curRight + 1 + &#x27;px&#x27;;</span><br><span class="line">div.style.bottom = curBottom + 1 + &#x27;px&#x27;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h4 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h4><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h4 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h4><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h4 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h4><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">  * 根据上面的结论</span><br><span class="line">  * 将 2d transform 换成 3d</span><br><span class="line">  * 就可以强制开启 GPU 加速</span><br><span class="line">  * 提高动画性能</span><br><span class="line">  */</span><br><span class="line">  div &#123;</span><br><span class="line">    transform: translate3d(10px, 10px, 0);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何在浏览器中查看页面渲染时间"><a href="#如何在浏览器中查看页面渲染时间" class="headerlink" title="如何在浏览器中查看页面渲染时间"></a>如何在浏览器中查看页面渲染时间</h2><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210626143902.webp"></p><ul><li>蓝色: 网络通信和HTML解析</li><li>黄色: JavaScript执行</li><li>紫色: 样式计算和布局，即重排</li><li>绿色: 重绘</li></ul><p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。</p><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图：</p><p><img src="https://raw.githubusercontent.com/andylinwenqin/Picgo/main/img/20210711144643.webp"></p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</li><li>CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://segmentfault.com/a/1190000017491520">掌握浏览器重绘(repaint)重排(reflow))-前端进阶</a></p><p><a href="https://csstriggers.com/">csstriggers</a></p><p><a href="https://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/">CSS硬件加速的好与坏</a></p><p>本文来自<a href="https://juejin.cn/post/6844904083212468238">齐小神的重排重绘</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重排-reflow-和重绘-repaint&quot;&gt;&lt;a href=&quot;#重排-reflow-和重绘-repaint&quot; class=&quot;headerlink&quot; title=&quot;重排(reflow)和重绘(repaint)&quot;&gt;&lt;/a&gt;重排(reflow)和重绘(repaint)</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="性能优化" scheme="https://andylinwenqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CSS性能优化</title>
    <link href="https://andylinwenqin.github.io/2021/06/26/CSS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://andylinwenqin.github.io/2021/06/26/CSS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-06-26T06:19:07.000Z</published>
    <updated>2021-06-26T06:32:24.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提高性能的方法有哪些"><a href="#提高性能的方法有哪些" class="headerlink" title="提高性能的方法有哪些?"></a>提高性能的方法有哪些?</h2><ol><li>合并css文件，如果页面加载10个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。</li><li>减少css嵌套，最好不要嵌套三层以上。</li><li>不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。</li><li>建立公共样式类，把相同样式提取出来作为公共类使用。</li><li>减少通配符*或者类似[hidden=”true”]这类选择器的使用，挨个查找所有…这性能能好吗？</li><li>巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。</li><li>拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。</li><li>不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。</li><li>少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。</li><li>cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。</li><li>善后工作，css压缩(在线压缩工具 YUI Compressor)</li><li>GZIP压缩，是一种流行的文件压缩算法。</li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="避免使用-import，外部的css文件中使用-import会使得页面在加载时增加额外的延迟。"><a href="#避免使用-import，外部的css文件中使用-import会使得页面在加载时增加额外的延迟。" class="headerlink" title="避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。"></a>避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。</h3><p>首先，使用@import引入css会影响浏览器的并行下载。使用@import引用的css文件只有在引用它的那个css文件被下载，解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析，构建render tree等一系列操作，这就导致浏览器无法并行下载<br>所需的样式文件。<br>其次，多个@import会导致下载顺序紊乱，在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件优先于@import下载，并且打乱甚至破坏@import自身的并行下载。<br>所以不要使用这一方法，使用link标签就行了。</p><h3 id="避免过分重排"><a href="#避免过分重排" class="headerlink" title="避免过分重排"></a>避免过分重排</h3><ul><li>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow</li><li>浏览器根据定义好的样式来计算，并将元素放到该出现的位置上，这个过程叫做reflow</li><li>页面上任何一个节点触发来reflow，会导致他的子节点和祖先节点重新渲染</li><li>导致reflow发生的情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 改变窗口的大小  </span><br><span class="line">2. 改变文字的大小</span><br><span class="line">3. 添加 删除样式表</span><br><span class="line">4. 内容的改变 输入框输入内容也会</span><br><span class="line">5. 伪类的激活</span><br><span class="line">6. 操作class属性</span><br><span class="line">7. 脚本操作dom js改变css类</span><br><span class="line">8. 计算offsetWidth和offsetHeight</span><br><span class="line">9. 设置style属性</span><br><span class="line">10.改变元素的内外边距 </span><br></pre></td></tr></table></figure><ul><li>常见重排元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 大小有关的 width,height,padding,margin,border-width,border,min-height</span><br><span class="line">2. 布局有关的 display,top,position,<span class="built_in">float</span>,left,right,bottom</span><br><span class="line">3. 字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</span><br><span class="line">4. 隐藏有关的 overflow,overflow-x,overflow-y</span><br></pre></td></tr></table></figure><ul><li>减少reflow对性能的影响的建议</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 不要一条条的修改dom的样式，预先定义好class，然后修改dom的classname</span><br><span class="line">2. 不要修改影响范围较大的dom</span><br><span class="line">3. 为动画元素使用绝对定位</span><br><span class="line">4. 不要table布局，因为一个很小的改动会造成整个table重新布局</span><br><span class="line">5. 避免设置大量的style属性，通过设置style属性改变节点样式的话，每一次设置都会触发一次reflow，所以最好使用class属性</span><br><span class="line">6. 如果css里面有计算表达式，每次都会重新计算一遍，触发一次reflow</span><br></pre></td></tr></table></figure><h3 id="repaint"><a href="#repaint" class="headerlink" title="repaint"></a>repaint</h3><ol><li>当一个元素的外观被改变，但是布局没有改变的情况</li><li>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素</li><li>常见的重绘元素</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 颜色 color,background</span><br><span class="line">- 边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</span><br><span class="line">- 背景有关 background,backgound-image,background-position,background-repeat,background-size</span><br></pre></td></tr></table></figure><h3 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h3><ol><li>css动画启用GPU加速，应用GPU的图形性能对浏览器中的一些图形操作交给GPU完成。canvas2D，布局合成，css3转换，css3d变换，webGL，视频</li><li>2d加速</li><li>3d加速</li></ol><h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><p>性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著<br>文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p><h3 id="去除无用CSS"><a href="#去除无用CSS" class="headerlink" title="去除无用CSS"></a>去除无用CSS</h3><p>虽然文件压缩能够降低文件大小，但css文件压缩通常只会去除无用的空格，这样就限制来css文件的压缩比例。如果压缩后的文件仍然超过来预期的大小，可以试着找到并删除代码中无用的css。<br>一般情况下，会存在这两种无用的CSS代码：</p><ol><li>不同元素或者其他情况下的重复代码，</li><li>整个页面内没有生效的CSS代码</li></ol><h3 id="有选择地使用选择器"><a href="#有选择地使用选择器" class="headerlink" title="有选择地使用选择器"></a>有选择地使用选择器</h3><p>css选择器的匹配是从右向左进行的，这一策略导致来不同种类的选择器之间的性能也存在差异。相比于 #markdown-content-h3,显然使用 #markdown.content h3时，浏览器生成渲染树所要花费的时间更多。因为后者需要先找到DOM中的所有h3元素，再过滤掉祖先元素不是.content的，最后过滤掉.content不是#markdown的。试想，页面中的元素更多，那么匹配所要花费的时间代价自然更高。<br>显得浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微，此外不同选择器在不同浏览器中的性能表现也不统一，在编写css的时候无法兼顾每种浏览器，鉴于这两点，在使用选择器时，尽量记住以下几点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 保持简单，不要使用嵌套过多过于复杂的选择器</span><br><span class="line">2. 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</span><br><span class="line">3. 不要使用类选择器和ID选择器修饰元素标签，如：h3<span class="comment">#markdown-content，这一多此一举，还会降低效率</span></span><br><span class="line">4. 不要为了追求速度而放弃可读性和可维护性</span><br></pre></td></tr></table></figure><p>TIPS：为什么css选择器是从右向左匹配的？<br>css中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得css选择器在不匹配的时候效率更高。</p><h3 id="减少使用昂贵的属性"><a href="#减少使用昂贵的属性" class="headerlink" title="减少使用昂贵的属性"></a>减少使用昂贵的属性</h3><p>在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价，而页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写css时，应该尽量减少使用昂贵属性，如:<br>box-shadow, border-radius, filter, 透明度, :nth-child等<br>当然并不是不要使用这些属性，这些都是经常使用的属性，只是这里可以作为一个了解。当有其他方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，这一网站的性能会在不知不觉中得到一定的提升。</p><h3 id="硬件加速的好坏"><a href="#硬件加速的好坏" class="headerlink" title="硬件加速的好坏"></a>硬件加速的好坏</h3><ol><li>仅仅依靠GPU还是不行的，许多动画还是需要CPU的介入，连接cpu和GPU的总带宽不是无限的，所以需要注意数据在cpu和GPU之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输。</li><li>一个重点是了解创建的合成层的数量，每一个层都对应来一个GPU纹理，太多的层会消耗很多内存。</li><li><code>**chrome://flags/#composited-layer-borders**</code>观察的地址。</li><li>每一个dom元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层</li><li>另一个重点是保持GPU和CPU之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给GPU。</li><li>因为为了高性能，动画开始之后避免层的更新也是非常重要的，避免动画进行中其他层一直更新导致拥堵。</li><li>也就是使用这些css属性来实现动画：transformation, opacity, filter</li><li>使用性能工具检测优化的合理性，timeline检测优化是否合理，还需要实现自动操作来做性能回归测试。</li><li>检测层数和层更新次数是非常有用的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;提高性能的方法有哪些&quot;&gt;&lt;a href=&quot;#提高性能的方法有哪些&quot; class=&quot;headerlink&quot; title=&quot;提高性能的方法有哪些?&quot;&gt;&lt;/a&gt;提高性能的方法有哪些?&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;合并css文件，如果页面加载10个css文件,每个文件1k，</summary>
      
    
    
    
    
    <category term="面试" scheme="https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="CSS" scheme="https://andylinwenqin.github.io/tags/CSS/"/>
    
    <category term="性能优化" scheme="https://andylinwenqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
