{"meta":{"title":"Andylin's Blog","subtitle":"永无止境，奋斗不息","description":"个人知识积累","author":"林文钦","url":"https://andylinwenqin.github.io","root":"/andylin.github.io/"},"pages":[{"title":"","date":"2021-06-25T14:36:23.055Z","updated":"2021-06-25T14:36:23.055Z","comments":true,"path":"-data/link.json","permalink":"https://andylinwenqin.github.io/-data/link.json","excerpt":"","text":"null"},{"title":"about","date":"2021-06-26T07:20:25.000Z","updated":"2021-06-26T07:21:07.967Z","comments":true,"path":"about/index.html","permalink":"https://andylinwenqin.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-06-23T10:32:03.000Z","updated":"2021-06-25T15:28:00.560Z","comments":true,"path":"categories/index.html","permalink":"https://andylinwenqin.github.io/categories/index.html","excerpt":"","text":""},{"title":"时间轴","date":"2021-06-25T15:22:45.000Z","updated":"2021-06-25T15:28:30.333Z","comments":true,"path":"archives/index.html","permalink":"https://andylinwenqin.github.io/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-23T10:31:55.000Z","updated":"2021-06-25T14:40:33.896Z","comments":true,"path":"tags/index.html","permalink":"https://andylinwenqin.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-06-25T14:22:28.000Z","updated":"2021-06-25T14:40:58.893Z","comments":true,"path":"link/index.html","permalink":"https://andylinwenqin.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue框架面试总结","slug":"Vue框架面试总结","date":"2021-09-04T15:39:19.000Z","updated":"2021-09-04T16:23:07.768Z","comments":true,"path":"2021/09/04/Vue框架面试总结/","link":"","permalink":"https://andylinwenqin.github.io/2021/09/04/Vue%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"真实DOM和其解析流程(1). 构建DOM树:用HTML分析器，分析HTML元素，创建一棵DOM树; (2). 生成样式表，用css分析器，分析css文件和元素上的inline样式，生成页面的样式表; (3). 构建Render树: 将DOM树和样式表关联起来，构建一颗Render树(Attachment) 每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)，这些render对象最终会构建成一颗render树; (4). 确定节点坐标: 根据Render树结构，为每个Render树上的节点确定一个在显示屏上出现的精确坐标; (5). 绘制页面: 根据Render树和节点显示坐标，然后调用每个节点的paint方法，将它门绘制出来; 注意点: (1). 构建DOM树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个HTML文档解析完成之后才开始构建render树和布局; (2). Render树DOM树和CSS样式表这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析以及一边渲染; (3). CSS的解析是从右往左逆向解析的，嵌套标签越多，解析越慢; (4). 用我们传统的开发模式，原声JS操作DOM时，浏览器会从构建DOM树开始从头到尾执行一边流程，在一次操作中，我们需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会立即马上执行流程，最终执行10次，这样会导致页面卡顿并且影响用户体验; Virtual DOM虚拟DOM的好处： 虚拟DOM就是为了解决浏览器性能问题而被设计出来的，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attach到DOM树上，再进行后续操作，避免大量无谓的计算量，所以用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制 比较两颗虚拟DOM树的差异 - diff算法 diff算法用来比较virtual dom树的差异，如果两颗树完全比较，那么diff算法的时间复杂度位O(n^3)，但是在前端当中，会很少跨越层级地移动DOM元素，所以virtual dom只会对同一层级的元素进行对比，这样算法复杂度就可以达到O(n) (1).深度优先遍历记录差异; (2). 差异类型; 节点替换：节点改变了，例如将上面的 div 换成 h1; 顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换； 属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除； 文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”; (3). 列表对比算法 子节点的对比算法，例如:p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动 Vue与React的区别(1). Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能而React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染; (2). Vue支持双向绑定，而React的数据流一直提倡单向数据流，他称之为 onChange/setState()模式。; (3). 模版渲染方式不同 React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现; SPA单页面应用其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。 优 点: 减轻服务端的压力，可维护性高 缺点: 首次加载速度慢，搜索引擎优化效果不好 为什么首屏时间慢，SEO 差？单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。 SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。 多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。 MVVM模型MVVM是Model-View-ViewModel缩写，也就是把MVC中的contorller演变成ViewModel,Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。 介绍下Vue的响应式数据Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅) Vue3.x响应式数据原理 Vue3.x该用proxy代替Object.defineProperty. 因为Proxy可以直接监听对象和数组的变化 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？ 我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。 Vue2.x中如何监测数组变化​ 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控，这样就实现了监测数组变化。 nextTick实现原理在下次DOM更新循环结束之后执行延迟回调，nextTick主要使用了宏任务和微任务，根据执行环境分别尝试采用(1).promise;(2).MutationObserver;(3).setImmediate;(4).如果以上都不行采用setTimeout定义一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 Vue的生命周期 Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模版，挂载Dom,渲染, 更新 再渲染， 销毁等一系列过程，我们称这个为vue的生命周期。 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段: 初始化，运行中，销毁 (1). 实例，组件通过new Vue()创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候数据还没有挂载，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 (2). 挂载数据，绑定事件等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发update函数，在这里可以再渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以再这里初始数据的获取 (3). 接下里开始实例或者组件对应的模版，编译模版为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染，在这里也可以更改数据，不会触发update，这里是渲染前最后一次更改数据的机会，不会触发其他钩子函数，一般可以在这里做初始数据的获取 (4). 接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据，真实dom都已经处理好了，事件已经挂载好了，可以在这里操作真实dom等事情； (5). 当组件或实例的数据更改之后，会立即执行beforeUpdate,然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事 (6). 当更新完成后，执行updated，数据已经更新完成，dom也重新render完成，可以操作更新后的虚拟dom (7). 当经过某种途径调用$destory方法之后，立即执行beforeDestroy,一般在这里做一些善后工作，例如清除计时器，清除非指令绑定的事件等 (8). 组件的数据绑定，监听去掉后只剩下dom空壳，这个时候执行destoryed,在这里做善后工作也可以 嵌套组件的生命周期的执行顺序： vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted 更改组件数据 修改子组件的数据 1vm.beforeCreate ——&gt; vm.created ——&gt; vm.beforeMount ——&gt; son.beforeCreate ——&gt; son.created ——&gt; son.beforeMount ——&gt; son.mounted ——&gt; vm.mounted ——&gt; son.beforeUpdate ——&gt; son.updated Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。 当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它 Vue的父组件和子组件生命周期钩子函数执行顺序加载渲染过程 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程 父 beforeUpdate -&gt; 父 updated 销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 在哪个生命周期内调用异步请求 可以在钩子函数created，beforeMount, mounted中进行调用，因为在这三个钩子函数中，data已经创建，可以将服务端返回的数据进行赋值， 在什么阶段才能访问操作DOM 在钩子函数mounted被调用前，Vue已经将编译号的模版挂载到页面上，所以在mounted中可以访问操作DOM created和mounted的区别created: 在模版渲染成html前调用，即挂载数据和绑定事件等等，此时是无法对html的dom节点进行操作的，此时更改数据不会触发update函数 mounted: 在模版渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作，此时更改数据会触发update函数 Vue双向绑定的原理vue数据双向绑定事通过数据劫持结合发布者-订阅者模式的方式来实现的。vue通过Object.defineProperty()这个方法重新定义了对象获取属性值(get)和设置属性值(set)。 Object.defineProperty()的第一个缺陷，无法监听数组变化，第二个缺陷是只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历 需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对 应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己 ，自身必须有一个 update() 方法，待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。 MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变 更的双向绑定效果。 v-model本质上是一个父子通信组件的语法糖，通过props和$emit实现 v-show和v-if的区别v-if: 是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块 v-show: 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的‘display’属性进行切换 所以v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景 v-for中 key 值的作用在列表渲染过程中，key可以提高列表渲染的效率，提高页面的性能，因为v-for更新已渲染的元素列表时，默认用就地复用的原则对列表进行修改，他会根据key的值去判断某个值是否修改，如果修改了key，则重新渲染这一项，否则复用之前的元素。 父子组件的通信父传子: 通过v-on绑定一个变量名称，在子组件中用props进行接收 子传父: 在子组件中绑定一个方法，将参数传入之后通过$emit()传递出去， $emit()里的参数是父组件中定义的方法名称以及参数 为什么组件里的data必须是函数而不是对象？ 因为组件在Vue中是可以重复调用的，那么如果这个组件被多次调用并且data是对象的话，所有这个组件的实例会共同share一份data这样就会造成数据的泄漏，并且组件中的数据会对不上号，可能实例a的数据应用在了实例b上， 所以如果data是函数，就能确保每一个实例都有一份自己的data,使得统一组件的不同实例间的data不会互相影响。 怎样理解Vue的单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 Vue中key的作用 key是为Vue中vnode的唯一标记，通过key，我们的diff操作可以更加准确，更快速，Vue的diff过程可以概括为: oldCh和newCh各有两个头尾的变量oldStartIndex, oldEndIndex和newStartIndex, newEndIndex，新旧节点会两两对比，即一共有四种比较方式, 如果以上4种都没有匹配，如果设置了key，就会用key再进行比较，在比较的过程中，遍历会往中间靠，一旦StartIndex &gt; EndIndex表明oldCh和newCh至少一个已经遍历完了，就会结束比较(如果没有key,4种都没有匹配成功就会将newStartIndex所在的节点直接生成新的节点且插入到原有的root的子节点中) VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。 所以key是Vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确，更快速 新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。 Vue2.x和Vue3.x渲染器的diff不同处简单来说，diff算法的过程 (1). 同级比较，再比较子节点;(2). 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除);(3). 比较都有子节点的情况;(4). 递归比较子节点; 正常Diff两个树的时间复杂度时O(N ^ 3),但实际情况下我们很少会进行跨层级的移动DOM,所以Vue将Diff进行优化，从O(N^3) -&gt; O(N)只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较 vue2 vu3算法区别Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。 Vue3的diff算法在创建VNode时就确定其类型1，以及在mounted/patch的过程中采用位运算来判断一个VNode的类型，在这个基础上再配合核心的Diff算法 diffdiff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点： 首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换； 在vnode没有文本节点的情况下，进入子节点的 diff； 当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff； 若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中； 若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点； 若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。 Vue事件绑定原理原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。 watch中deep和immediate的作用？deep，默认值是 false，代表是否深度监听。immediate:true代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。 Vue模版编译原理简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段： 生成AST树 优化 codegen 首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。 Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。 编译的最后一步是将优化后的AST树转换为可执行的代码。 Vue-router Vue-router是什么？有哪些组件？ Vue-router是Vue.js官方的路由管理器，它和Vue.js的核心深度集成，让构建单页面应用变得易如反掌 共有三个组件分别是&lt;router-link&gt;, &lt;router-view&gt;和&lt;keep-alive&gt;(vue2.0提供) Vue-router有几种钩子函数？具体时什么以及参数 (1). 前置守卫 在进入这个路由之前;(2). 全局解析守卫;(3). 后置钩子 ;(4). 路由独享的钩子;(5). 组件内的导航钩子 导航解析流程 (1). 导航被触发; (2). 在失活的组件里调用beforeRouteLeave守卫; (3). 调用全局的beforeEach守卫; (4). 在重用的组件里调用beforeRouteUpdate守卫; (5). 在路由配置里调用beforeEnter; (6). 解析异步路由组件; (7). 在被激活的组件里调用beforeRouterEnter; (8). 调用全局的beforeResolve守卫; (9). 导航被确认; (10). 调用全局的afterEach钩子; (11). 触发DOM更新; (12). 调用beforeRouterEnter守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入; $route和$router的区别是什么？router为vue-router的实例，是一个全局路由对象，包含了路由跳转的方法，钩子函数等 route是路由信息对象和跳转的路由对象，每一个路由都一个route对象，是一个局部对象，包含path, params, hash, query, fullpath, matched, name等路由信息参数 Vue-router传参方式(1). 直接调用$router.push实现携带参数的跳转; 12345678910this.$router.push(&#123;path: `/describe/$&#123;id&#125;`&#125;)// 对应的路由配置&#123; path: &#x27;/describe/:id&#x27;, name: &#x27;Describe&#x27;, component: Describe&#125;this.$route.params.id (2).父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。 this.$router.push(&#123; name: &#39;Describe&#39;, params: &#123; id: id &#125; &#125;) &#123; path: &#39;/describe/:id&#39;, name: &#39;Describe&#39;, component: Describe &#125; this.$route.params.id (3). 父组件：使用path来匹配路由，然后通过query来传递参数; 1234567891011121314this.$router.push(&#123; path: &#x27;/describe&#x27;, query: &#123; id: id &#125;&#125;)&#123; path: &#x27;/describe&#x27;, name: &#x27;Describe&#x27;, component: Describe&#125;this.$route.query.id Vue-router的跳转方式(1). router-link;(2). this.$router.push();(3). this.$router.replace();(4). this.$router.go();(5). this.$router.forward();(6). this.$router.back(); VuexVue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取新的state的值，重新渲染Vue componments,界面随之更新 vuex为什么需要用 mutation 这些来修改 state 数据，而不是直接更改 Vuex 单向数据流有关，因为需要知道数据修改的来源。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"vue","slug":"vue","permalink":"https://andylinwenqin.github.io/tags/vue/"}]},{"title":"v-bind","slug":"v-bind","date":"2021-09-04T12:04:21.000Z","updated":"2021-09-04T15:27:40.967Z","comments":true,"path":"2021/09/04/v-bind/","link":"","permalink":"https://andylinwenqin.github.io/2021/09/04/v-bind/","excerpt":"","text":"Class 与 Style 绑定 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定 HTML Class观看本节视频讲解 对象语法我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据 property isActive 的 truthiness。 你可以在对象中传入更多字段来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class attribute 共存。当有如下模板： 1234&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt; 和如下 data： 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 1&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; 当 isActive 或者 hasError 变化时，class 列表将相应地更新。例如，如果 hasError 的值为 true，class 列表将变为 &quot;static active text-danger&quot;。 绑定的数据对象不必内联定义在模板里： 1234567&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, &#x27;text-danger&#x27;: false &#125;&#125; 渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式： 12345678910111213&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27; &#125; &#125;&#125; 数组语法我们可以把一个数组传给 v-bind:class，以应用一个 class 列表： 12345&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &#x27;active&#x27;, errorClass: &#x27;text-danger&#x27;&#125; 渲染为： 1&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 如果你也想根据条件切换列表中的 class，可以用三元表达式： 1&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt; 这样写将始终添加 errorClass，但是只有在 isActive 是 truthy[1] 时才添加 activeClass。 不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法： 1&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt; 用在组件上 这个章节假设你已经对 Vue 组件有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。 当在一个自定义组件上使用 class property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。 例如，如果你声明了这个组件： 123Vue.component(&#x27;my-component&#x27;, &#123; template: &#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;&#125;) 然后在使用它的时候添加一些 class： 1&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt; HTML 将被渲染为： 1&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt; 对于带数据绑定 class 也同样适用： 1&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt; 当 isActive 为 truthy[1] 时，HTML 将被渲染成为： 1&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt; 绑定内联样式对象语法v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： 12345&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &#x27;red&#x27;, fontSize: 30&#125; 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &#x27;red&#x27;, fontSize: &#x27;13px&#x27; &#125;&#125; 同样的，对象语法常常结合返回对象的计算属性使用。 数组语法v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 自动添加前缀当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值 2.3.0+ 从 2.3.0 起你可以为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如： 1&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt; 这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。 译者注[1] truthy 不是 true，详见 MDN 的解释。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"CSS动画","slug":"CSS动画","date":"2021-09-04T08:42:38.000Z","updated":"2021-09-04T09:30:02.012Z","comments":true,"path":"2021/09/04/CSS动画/","link":"","permalink":"https://andylinwenqin.github.io/2021/09/04/CSS%E5%8A%A8%E7%94%BB/","excerpt":"","text":"CSS动画和实现方法 css3颜色渐变CSS 渐变使您可以显示两种或多种指定颜色之间的平滑过渡。 CSS 定义了两种渐变类型： 线性渐变（向下/向上/向左/向右/对角线） 径向渐变（由其中心定义） 语法1background-image: linear-gradient(direction, color-stop1, color-stop2, ...); 实例123#grad &#123; background-image: linear-gradient(to bottom right, red, yellow);&#125; 效果 使用角度如果希望对渐变角度做更多的控制，您可以定义一个角度，来取代预定义的方向（向下、向上、向右、向左、向右下等等）。值 0deg 等于向上（to top）。值 90deg 等于向右（to right）。值 180deg 等于向下（to bottom）。 实例123#grad &#123; background-image: linear-gradient(-90deg, red, yellow);&#125; 使用透明度CSS 渐变还支持透明度，也可用于创建渐变效果。 如需添加透明度，我们使用 rgba() 函数来定义色标。 rgba() 函数中的最后一个参数可以是 0 到 1 的值，它定义颜色的透明度：0 表示全透明，1 表示全彩色（无透明）。 下面的例子展示了从左开始的线性渐变。它开始完全透明，然后过渡为全色红色： 实例123#grad &#123; background-image: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1));&#125; css3使用animation属性实现背景颜色动态渐变的效果首先我们来看一下CSS3关键帧动画的基础知识 让我们先了解逐渐改变元素的动画！在CSS 3 animation属性中，您可以设置关键帧并绘制详细的运动。关于动画的时间和时机、无限的循环，只有CSS就可以指定了！ 什么是关键帧？关键帧（传递点）是在动画中定义更改的帧。我们@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，您需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。 @keyframes规则的名称声明为“ @keyframes +任意名称 ”。我将写入0％到100％的关键帧信息。0％表示开始动画，100％表示结束时间。0％from，100％可以用to替换。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。 12345@keyframes name &#123; 0% &#123; background: red; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: pink; &#125;&#125; animation相关属性animation-name（动画名） @keyframes指定中定义的名称。如果未指定此项，则不会执行动画。此外，如果指定的动画名称与任何关键帧都不匹配，则不会执行该关键帧。 animation-duration（动画持续时间） 通过“秒+ s”指定执行一个动画的时间长度。例如，“5秒”持续5秒。如果为0，则不会执行。即使指定了负值，也会将其视为0。 animation-timing-function（动画定时功能） 指定动画的时间以及如何继续。您可以通过调整动画进度速度的比例来表达平滑运动。 ease（初期値） ease-in ease-out ease-in-out linear animation-delay（动画延迟） 读取元素时，从“元素编号+ s”指定“动画开始”的时间。例如，“5秒”持续5秒。初始值0将立即执行。 animation-iteration-count（动画迭代计数） 指定使用数字重复动画的次数。infinite要指定无限循环，请指定。 animation-direction（动画方向） 指定重复动画的方向。 normal …正常方向播放（初始值） alternate …在正常和偶数时间以相反方向重新生成奇数次（返回并返回…） reverse…向后播放 alternate-reverse…反向播放 animation-play-state（动画播放状态） 指定动画暂停（paused）和播放（running）。但是，似乎没有太多使用。 animation-fill-mode（动画填充模式） 指定播放动画之前和之后的状态。 none（默认值） forwards..播放后保持最后一个关键帧的状态 backwards…在播放前应用第一个关键帧的状态 both … forwards ……向前和向后都应用 属性总结animation属性允许您分别指定每个属性的值，用空格分隔。项目可以省略，但动画名称必须在执行前写入。建议按以下顺序列出。 animation-name（动画名） animation-duration（动画持续时间） animation-timing-function（动画定时功能） animation-delay（动画延迟） animation-iteration-count（动画迭代计数） animation-direction（动画方向） animation-fill-mode（动画填充模式） animation-play-state（动画播放状态） 123body &#123; animation: test 5s ease 1s infinite forwards;&#125; 下面我们来看看背景颜色改变的具体内容 在了解了基础的知识之后，我们来详细看看具体的实现方法。首先，将关键帧的名称设置为“bg - color”，并将背景颜色设置为从0到100％的过渡。如果将相同的颜色设置为0％和100％，则在循环动画时它会平滑移动。我们还将描述您为基于Webkit的浏览器启用的版本。 1234567891011121314151617@-webkit-keyframes bg-color &#123; 0% &#123; background-color: #e74c3c; &#125; 20% &#123; background-color: #f1c40f; &#125; 40% &#123; background-color: #1abc9c; &#125; 60% &#123; background-color: #3498db; &#125; 80% &#123; background-color: #9b59b6; &#125; 100% &#123; background-color: #e74c3c; &#125;&#125;@keyframes bg-color &#123; 0% &#123; background-color: #e74c3c; &#125; 20% &#123; background-color: #f1c40f; &#125; 40% &#123; background-color: #1abc9c; &#125; 60% &#123; background-color: #3498db; &#125; 80% &#123; background-color: #9b59b6; &#125; 100% &#123; background-color: #e74c3c; &#125;&#125; 由于此时指定整个网页的背景颜色，body以animation指定属性。值为“关键帧名称”，bg-color“更改”在10秒内添加，“，10s”指定无限循环infinite。不要忘记webkit的版本。background-color让我们指定基本背景颜色作为背景色，为动画不起作用的情况做准备。 12345body &#123; background-color: #e74c3c; animation: bg-color 10s infinite; -webkit-animation: bg-color 10s infinite;&#125; 完整代码123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; background-color: #e74c3c; animation: bg-color 10s infinite; -webkit-animation: bg-color 10s infinite; &#125; @-webkit-keyframes bg-color &#123; 0% &#123; background-color: #e74c3c; &#125; 20% &#123; background-color: #f1c40f; &#125; 40% &#123; background-color: #1abc9c; &#125; 60% &#123; background-color: #3498db; &#125; 80% &#123; background-color: #9b59b6; &#125; 100% &#123; background-color: #e74c3c; &#125; &#125; @keyframes bg-color &#123; 0% &#123; background-color: #e74c3c; &#125; 20% &#123; background-color: #f1c40f; &#125; 40% &#123; background-color: #1abc9c; &#125; 60% &#123; background-color: #3498db; &#125; 80% &#123; background-color: #9b59b6; &#125; 100% &#123; background-color: #e74c3c; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;andyLin博客&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 最终效果 画一个三角形实现一个简单的三角形使用CSS盒模型中的border（边框）即可实现如下所示的三角形： CSS实现简单三角形 实现原理：首先来看在为元素添加border时，border的样子；假设有如下代码： 1234567&lt;div&gt;&lt;/div&gt;div &#123; width: 50px; height: 50px; border: 2px solid orange;&#125; 效果图： border的一般使用 这是我们平常使用border最普遍的情况——往往只给border一个较小的宽度（通常为1-2px）；然而这样的日常用法就会容易让大家对border的形成方式产生误解，即认为元素的border是由四个矩形边框拼接而成。 然而事实并不是这样。实际上，元素的border是由三角形组合而成，为了说明这个问题，我们可以增大border的宽度，并为各border边设置不同的颜色： 123456div &#123; width: 50px; height: 50px; border: 40px solid; border-color: orange blue red green;&#125; 效果图： border的形成方式 既然如此，那么更进一步，把元素的内容尺寸设置为0会发生什么情况呢？ 123456div &#123; width: 0; height: 0; border: 40px solid; border-color: orange blue red green;&#125; 效果图： 元素内容尺寸为0 我们将惊奇地发现，此时元素由上下左右4个三角形“拼接”而成；那么，为了实现最终的效果，即保留最下方的三角形，还应该怎么做？很简单，我们只需要把其它border边的颜色设置为白色或透明色： 123456div &#123; width: 0; height: 0; border: 40px solid; border-color: transparent transparent red;&#125; Duang~ 最终的简单三角形就绘制出来了。同理，如果想要得到其它边上的三角形，只需要将剩余的border边颜色设置为白色或透明色即可。 不过，被“隐藏”的上border仍然占据着空间，要想使得绘制出的三角形尺寸最小化，还需要将上border的宽度设置为0（其它情况同理）： 1234567div &#123; width: 0; height: 0; border-width: 0 40px 40px; border-style: solid; border-color: transparent transparent red;&#125; 出自 CSS绘制三角形—border法","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"}]},{"title":"watch和computed","slug":"watch和computed","date":"2021-09-04T07:31:54.000Z","updated":"2021-09-04T15:38:06.425Z","comments":true,"path":"2021/09/04/watch和computed/","link":"","permalink":"https://andylinwenqin.github.io/2021/09/04/watch%E5%92%8Ccomputed/","excerpt":"","text":"计算属性computed： 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化 computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed 如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。 侦听属性watch： 不支持缓存，数据变，直接会触发相应的操作； watch支持异步； 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 当一个属性发生变化时，需要执行对应的操作；一对多； 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数： watch和computed的区别和应用场景（面试版）计算属性`computed`和监听器`watch`都可以观察属性的变化从而做出响应，不同的是: 计算属性`computed`更多是作为缓存功能的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，`computed`不会立即重新计算生成新的值，而是先标记为脏数据，当下次`computed`被获取的时候，才会进行重新计算并返回; 而监听器`watch`并不具备缓存性，监听器`watch`提供一个监听函数，当监听的属性发生变化时，会立即执行该函数 异步请求就用`watch` computed: 是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时，才会重新计算computed的值 watch: 更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续的操作 应用场景: (1).当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可利用computed的缓存特性，避免每次获取值时，都要重新计算; (2). 当我们需要在数据变化时执行异步或者开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的; immediate：组件加载立即触发回调函数执行 123456789watch: &#123; firstName: &#123; handler(newName, oldName) &#123; this.fullName = newName + &#x27; &#x27; + this.lastName; &#125;, // 代表在wacth里声明了firstName这个方法之后立即执行handler方法 immediate: true &#125;&#125; deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler 123456789watch: &#123; obj: &#123; handler(newName, oldName) &#123; console.log(&#x27;obj.a changed&#x27;); &#125;, immediate: true, deep: true &#125;&#125; watch和computed的区别 watch computed 定义格式 必须监听存在的属性(data、props、computed) 不能和data定义的变量相同 异步 支持异步操作 不支持异步 开销 适合一些开销较大的操作 适合做一些简单依赖的计算 对于computed能做的 watch都可以做，至于选择哪个去做，都应该去看使用场景 一、使用场景第一个输入框+第二个输入框 进行拼接 &lt;input type=&quot;text&quot; v-model=&quot;num1&quot; name=&quot;&quot; id=&quot;&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;num2&quot; name=&quot;&quot; id=&quot;&quot;&gt;= &#123;&#123;num3&#125;&#125; &#123;&#123;res&#125;&#125; 监听12345678watch:&#123; res()&#123; this.num3= this.num1+this.num2 &#125;, num2()&#123; this.num3= this.num1+this.num2 &#125; &#125;, 计算属性12345computed: &#123; res() &#123; return this.num1+this.num2 &#125;&#125;, 从代码量来看 显然更适合 用计算属性去做，而使用watch 就要检测两个值的变化 稍微繁琐了些 但是 watch 可以做一些异步的事情 并且可以设置改变多个值 这是计算属性做不到的 二、缓存关于缓存问题 个人感觉 这两个并不能比，可以用computed和methods去比 方法&#123;&#123;res()&#125;&#125; &#123;&#123;res()&#125;&#125; methods: &#123; res() &#123; console.log(&#39;方法被执行了&#39;); return this.num1+this.num2 &#125; &#125;, 如果视图上多个使用这个方法 每个调用都会执行 计算属性 而计算属性不同，只有当值发生改变的时候他才会执行，如果上次没有改变他会取从缓存拿值 123456789&#123;&#123;res&#125;&#125;&#123;&#123;res&#125;&#125; computed: &#123; res() &#123; console.log(&#x27;计算属性执行了&#x27;); return this.num1+this.num2 &#125;&#125;,","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"属性选择器","slug":"属性选择器","date":"2021-09-04T06:36:46.000Z","updated":"2021-09-04T07:31:58.660Z","comments":true,"path":"2021/09/04/属性选择器/","link":"","permalink":"https://andylinwenqin.github.io/2021/09/04/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"属性选择器 CSS 属性选择器通过已经存在的属性名或属性值匹配元素。 123456789101112131415161718192021222324/* 存在title属性的&lt;a&gt; 元素 */a[title] &#123; color: purple;&#125;/* 存在href属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */a[href=&quot;https://example.org&quot;] &#123; color: green;&#125;/* 存在href属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */a[href*=&quot;example&quot;] &#123; font-size: 2em;&#125;/* 存在href属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */a[href$=&quot;.org&quot;] &#123; font-style: italic;&#125;/* 存在class属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */a[class~=&quot;logo&quot;] &#123; padding: 2px;&#125; 语法 [attr] 表示带有以 attr 命名的属性的元素。 [attr=value] 表示带有以 attr 命名的属性，且属性值为 value 的元素。 [attr~=value] 表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 value。 [attr|=value] 表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（”-“为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。 [attr^=value] 表示带有以 attr 命名的属性，且属性值是以 value 开头的元素。 [attr$=value] 表示带有以 attr 命名的属性，且属性值是以 value 结尾的元素。 [attr*=value] 表示带有以 attr 命名的属性，且属性值至少包含一个 value 值的元素。 [*attr* *operator* *value* i] 在属性选择器的右方括号前添加一个用空格隔开的字母 i（或 I），可以在匹配属性值时忽略大小写（支持 ASCII 字符范围之内的字母）。 [*attr* *operator* *value* s] 在属性选择器的右方括号前添加一个用空格隔开的字母 s（或 S），可以在匹配属性值时区分大小写（支持 ASCII 字符范围之内的字母）。 示例CSS12345678910111213141516171819202122232425262728a &#123; color: blue;&#125;/* 以 &quot;#&quot; 开头的页面本地链接 */a[href^=&quot;#&quot;] &#123; background-color: gold;&#125;/* 包含 &quot;example&quot; 的链接 */a[href*=&quot;example&quot;] &#123; background-color: silver;&#125;/* 包含 &quot;insensitive&quot; 的链接,不区分大小写 */a[href*=&quot;insensitive&quot; i] &#123; color: cyan;&#125;/* 包含 &quot;cAsE&quot; 的链接，区分大小写 */a[href*=&quot;cAsE&quot; s] &#123; color: pink;&#125;/* 以 &quot;.org&quot; 结尾的链接 */a[href$=&quot;.org&quot;] &#123; color: red;&#125;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"}]},{"title":"虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误","slug":"虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误","date":"2021-08-23T07:11:19.000Z","updated":"2021-08-23T09:16:08.111Z","comments":true,"path":"2021/08/23/虚拟机安装linux-centos7系统-及-mysql8（老版本）配置出现的错误/","link":"","permalink":"https://andylinwenqin.github.io/2021/08/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux-centos7%E7%B3%BB%E7%BB%9F-%E5%8F%8A-mysql8%EF%BC%88%E8%80%81%E7%89%88%E6%9C%AC%EF%BC%89%E9%85%8D%E7%BD%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"","text":"虚拟机安装linux centos7系统 及 mysql8（老版本）配置出现的错误 VMware安装虚拟机centos7的步骤，截图讲解安装前准备以下路径下载centOS7镜像：https://mirrors.aliyun.com/cent 安装虚拟机的步骤1.点击“创建虚拟机” 2.点击“下一步” 3.点击“下一步” 4.选择“稍后安装操作系统”，然后“下一步” 5.选择Linux—&gt;&gt;版本号CentOS–&gt;&gt;下一步 6.填写“虚拟机名称”以及选择存放路径 ，然后点击下一步 7.选择处理器数显 默认是1 我这里选项2，然后“下一步” 8.选择内存，我这里选着2，默认是1 然后下一步 9.选择网络类型 10.控制器类型 11.磁盘类型 12.选着“创建新虚拟机” 13.这里磁盘大小，随便多少都行，5GB也行，磁盘存储单文件或者多文件都行，然后点击下一步 14。点击“下一步” 15。选自定义，然后选择刚才下载的镜像，然后点击“关闭” 16.点击“完成” 17.点击“开始此虚拟机” 18.等待安装中 19.选择键盘操作语言，我选择“中文简体”，然后点击“继续” 然后选择“软件选择” 然后顺便你选择 我闲着图形界面，点击“完成” 20 点击 选择时间 然后选择亚洲–上海时间，———》点击完成 21.选分区 22.选着网络配置 首先要打开网卡，然后查看是否能获取到IP地址 23.点击“开始安装” 24.点击设置“密码” 填写密码，点击完成 这里也可以创建用户，但是我创建用户，然后等待安装中 25.安装完成，点击重启 26.点击重启后，点击然后接受–完成 然后完成配置 设置用户名 安装成功 网络配置1.在终端中切换目录 ：cd /etc/sysconfig/network-scripts/ 2.在查看当前目录的文件：ls -a 3.输入su 切换到根目录root中，输入根目录的密码，点击Enter键 4.输入vi ifcfg-ens33 打开网络配置文件点击“i”进入可编辑文件 将ONBOOT=no改为ONBOOT=yes，即可配置开机自启动。多增加这几行 IPADDR=192.168.117.128(ip地址) NETMASK=255.255.255.0(子网掩码) GATEWAY=192.168.117.13(默认路由) DNS1=114.114.114.114(dns) 按ESC后，再输入:wq，按Enter键，即可保存并退出编辑。 退出到命令行界面，然后输入重启命令reboot，重启一下系统即可。 测试外网成功 ping baidu.com Linux环境(Centos 7)安装MySQL数据库1.卸载mariadb查看是否已安装mariadb # yum list installed mariadb* 系统中已经安装mariadb，进行卸载。 # yum remove mariadb* 查看是否卸载成功 # yum list installed mariadb* 删除mariadb配置文件 # rm -f /etc/my.cnf 删除mariadb数据目录 # rm -rf /var/lib/mysql/ 2.下载MySQL 使用rpm来安装MySQL因为CentOS 7默认安装的数据库是Mariadb,所以使用YUM命令是无法安装MySQL的，只会更新Mariadb。使用rpm来进行安装。可以在mysql的repo源仓库右键复制指定版本的数据库。 1# wget http://repo.mysql.com/mysql80-community-release-el7-1.noarch.rpm 安装mysql80-community-release-el7-1.noarch.rpm包 1# sudo rpm -ivh mysql80-community-release-el7-1.noarch.rpm 安装完成后会在 /etc/yum.repos.d文件夹里面获得两个文件：mysql-community.repo &amp;&amp; mysql-community-source.repo 使用yum安装mysql服务 1# sudo yum install mysql-server 如果显示以下内容说明安装成功 Complete! 检查是否已经设置为开机启动MySQL服务 1# systemctl list-unit-files|grep mysqld 如果显示 则表示已经设置为开机启动，如果没有设置为开机启动则执行 1# systemctl enable mysqld.service 查看MySQL是否启动未启动则执行启动服务命令 12345查看是否启动MySQL服务# ps -ef|grep mysql启动服务# systemctl start mysqld.service 初始化MySQL 1# mysqld --initialize 查看MySQL初始默认密码 1# grep &#x27;temporary password&#x27; /var/log/mysqld.log 复制 root@localhost: 后面的密码。登录mysql，并粘贴默认密码 因为MySQL8.0的更改，导致必须要重置密码 1alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;12345678&#x27;; 如果设置密码时候出现提示 ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 代表需要降低policy的等级后在执行 1set global validate_password.policy=0; 开启MySQL远程连接 12345use mysql;#修改root账户权限update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;#刷新权限flush privileges; 到此完成mysql基本安装和配置 快拍一个虚拟机快照啊 登录mysql和退出mysqllinux中登录mysql的方式是 1mysql -u root -h 127.0.0.1 -p； 退出MySQL 输入 exit 摁enter 安装pip1.通过yum -y install python-pip命令进行安装提示没有可用软件包 python-pip 2、接着执行：yum -y install epel-release python-pip命令 3、最后在次执行：yum -y install python-pip即可成功 4、然后可通过pip -V查看版本 5、然后通过：pip install –upgrade pip –user进行升级 6、然后在执行：pip install –upgrade pip 7、此时在pip -V看版本即可升级成功 mysql(老版本)配置问题及解决方法1、缺少libmysqlclient.so.18 发生服务器错误： Error loading MySQLdb module: libmysqlclient.so.18: cannot open shared object file: No such file or directory 问题原因：这个错误出现的原因是找不到 libmysqlclient.so.18 这个文件，根本原因是，一般我们使用的mysql都是自己从新安装的，不是系统自带的，所以在我们安装我们自己的mysql的时候，会把删除原来的mysql，此时会连带这删掉这个文件，32的目录是 /usr/lib/mysql/，64位的为 /usr/lib64/mysql/下面有这个文件。 解决： 1、解决问题的关键是，在找一台未装过mysql的服务器，然后把此文件夹下面的 libmysqlclient.so.18.0.0 文件拷贝到此服务器的这个目录中，然后做软连接。 ​ 我选择更好的方法: 1sudo wget -O /usr/lib/libmysqlclient.so.18 http://files.directadmin.com/services/es_7.0_64/libmysqlclient.so.18 直接下载缺失文件到对应位置 2、然后 vi /etc/ld.so.conf 后面增加一条记录：/usr/lib64/mysql （libmysqlclient.so.18 和libmysqlclient.so.18.0.0所在目录） 3、运行 ldconfig 命令，让其生效。 ok,完美解决。 2.Django启动服务器时，报错mysql的2059错误的解决办法。启动方式为如下： python manage.py runserver 0.0.0.0:8000 经过一番查询，调试，最终发现了问题所在。主要就是mysql8.0的问题。目前最新的mysql8.0对用户密码的加密方式为caching_sha2_password, django暂时还不支持这种新增的加密方式。只需要将用户加密方式改为老的加密方式即可。 解决步骤：1.登录mysql，连接用户为root。 mysql -u root -p 2.执行命令查看加密方式 use mysql;select user,plugin from user where user=’root’; 3.执行命令修改加密方式 alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘yourpassword’ 4.属性权限使配置生效 flush privileges 其中遇到两个小问题 1.Your password does not satisfy the current policy requirements密码策略问题异常信息 不符合正确密码规范 解决办法： 1、查看 mysql 初始的密码策略，输入语句 “ SHOW VARIABLES LIKE ‘validate_password%’; ” 进行查看 2、首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，输入设值语句 “ set global validate_password_policy=LOW; ” 进行设值， 3、当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，输入设值语句 “ set global validate_password_length=6; ” 进行设值， 4、现在可以为 mysql 设置简单密码了，只要满足六位的长度即可，输入修改语句 “ ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; ” 可以看到修改成功，表示密码策略修改成功了！！！ 关于 mysql 密码策略相关参数；1）、validate_password_length 固定密码的总长度；2）、validate_password_dictionary_file 指定密码验证的文件路径；3）、validate_password_mixed_case_count 整个密码中至少要包含大/小写字母的总个数；4）、validate_password_number_count 整个密码中至少要包含阿拉伯数字的个数；5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；关于 validate_password_policy 的取值：0/LOW：只验证长度；1/MEDIUM：验证长度、数字、大小写、特殊字符；2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数； 2.Operation ALTER USER failed for ‘root‘@’localhost’先登录mysql 1mysql -u root -p 输入密码 1mysql&gt; use mysql; 1mysql&gt; select user,host from user; 12345678910+------------------+-----------+| user | host |+------------------+-----------+| root | % || admin | localhost || mysql.infoschema | localhost || mysql.session | localhost || mysql.sys | localhost || zhangj | localhost |+------------------+-----------+ 注意root，host是’%’ 你可能执行的是: 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;; 改成: 1ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;","categories":[],"tags":[{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"},{"name":"Linux","slug":"Linux","permalink":"https://andylinwenqin.github.io/tags/Linux/"}]},{"title":"Vue组件传值","slug":"Vue组件传值","date":"2021-08-19T15:31:21.000Z","updated":"2021-09-04T05:22:52.460Z","comments":true,"path":"2021/08/19/Vue组件传值/","link":"","permalink":"https://andylinwenqin.github.io/2021/08/19/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/","excerpt":"","text":"Vue组件传值 先看一张总结图 方法一 父组件向子组件传值 （props传参）父组件 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是父组件&lt;/div&gt; &lt;Son str=&quot;字符串&quot; :num=&quot;5&quot; :obj=&quot;&#123; name: &#x27;对象信息&#x27; &#125;&quot; :func=&quot;() =&gt; &#123;this.list()&#125;&quot; :arr=&quot;arr&quot; &gt;&lt;/Son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Son from &#x27;./son&#x27; export default &#123; name: &#x27;Father&#x27;, components: &#123; Son &#125;, data() &#123; return &#123; arr: [1, 2, 3], &#125; &#125;, methods: &#123; list() &#123; console.log(&#x27;list&#x27;) &#125;, &#125;, &#125;&lt;/script&gt; 子组件 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;Son&#x27;, props: &#123; arr: Array, //定义参数类型 num: Number, str: String, str2: &#123; type: String, default: &#x27;默认是字符串&#x27;, //定义默认值 &#125;, func: &#123; type: Function, require: false, // 定义参数是否必须值 &#125;, obj: &#123; type: Object, require: false, &#125;, &#125;, created() &#123; console.log(this.str) //字符串 console.log(this.str2) //默认字符串 console.log(this.num) //5 console.log(this.arr) //[1,2,3] console.log(this.func()) // list console.log(this.obj) // name:&#x27;对象信息&#x27; &#125;, &#125;&lt;/script&gt; 方法二 子组件向父组件传值 （事件传递）父组件 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是父组件&lt;/div&gt; &lt;Son @func=&quot;speak&quot; &gt;&lt;/Son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Son from &#x27;./son&#x27; export default &#123; name: &#x27;Father&#x27;, components: &#123; Son &#125;, methods: &#123; speak(msg) &#123; console.log(msg) //我是子组件发送的消息 &#125;, &#125;, &#125;&lt;/script&gt; 子组件 12345678910111213&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;Son&#x27;, mounted() &#123; this.$emit(&#x27;func&#x27;, &#x27;我是子组件发送的消息！&#x27;) &#125;, &#125;&lt;/script&gt; 方法三 事件监听父组件 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是父组件&lt;/div&gt; &lt;Son ref=&quot;son&quot; &gt;&lt;/Son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Son from &#x27;./son&#x27; export default &#123; name: &#x27;Father&#x27;, components: &#123; Son &#125;, mounted() &#123; this.$refs[&#x27;son&#x27;].$on(&#x27;func&#x27;,(msg)=&gt;&#123; console.log(msg); //我是子组件传递的消息 &#125;) &#125; &#125;&lt;/script&gt; 子组件 12345678910111213141516&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;Son&#x27;, methods: &#123; sendMsg() &#123; this.$emit(&#x27;func&#x27;, &#x27;我是子组件传递的消息！&#x27;) &#125;, &#125;, &#125;&lt;/script&gt; 方法四 消息发布与订阅安装pubsub-js插件: npm install pubsub-js -s //可实现全局参数传递 组件A 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是A组件&lt;/div&gt; &lt;button @click=&quot;sendMsg&quot;&gt;Send&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import pubsub from &#x27;pubsub-js&#x27; export default &#123; name: &#x27;A&#x27;, methods: &#123; sendMsg() &#123; pubsub.publishSync(&#x27;sendMsg&#x27;, &#x27;这是A组件发布的消息！&#x27;) &#125;, &#125;, &#125;&lt;/script&gt; 组件B 12345678910111213141516&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是B组件&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import pubsub from &#x27;pubsub-js&#x27; export default &#123; name: &#x27;B&#x27;, mounted() &#123; pubsub.subscribe(&#x27;sendMsg&#x27;, (e, msg) =&gt; &#123; console.log(e, msg) //sendMsg 这是A组件发布的消息！ &#125;) &#125;, &#125;&lt;/script&gt; publishSync 同步发送消息 publish 同步发送消息 subscribe 订阅消息 unsubscribe 卸载特定订阅消息 clearAllSubscriptions 清除所有订阅消息 方法五 非父子组件传值 （EventBus传参）在main.js中挂载全局EventBus 1.Vue.prototype.$EventBus = new Vue() 组件A 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;我是A组件&lt;/div&gt; &lt;button @click=&quot;sendMsg&quot;&gt;send&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Son from &#x27;./son&#x27; export default &#123; name: &#x27;A&#x27;, methods: &#123; sendMsg() &#123; this.$EventBus.$emit(&#x27;sendMsg&#x27;,&#x27;这是A组件发送的消息！&#x27;) &#125; &#125; &#125;&lt;/script&gt; 组件B 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;div&gt;我是组件B&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; name: &quot;B&quot;, mounted()&#123; this.$EventBus.$on(&#x27;sendMsg&#x27;,(msg)=&gt;&#123; console.log(msg);//这是组件A发送的消息！ &#125;) &#125;, &#125;&lt;/script&gt; 通过挂载全局Vue对象传递参数 方法六 路由间传值i.使用问号传值A页面跳转B页面时使用 this.$router.push(’/B?name=danseek’) B页面可以使用 this.$route.query.name 来获取A页面传过来的值 上面要注意router和route的区别 ii.使用冒号传值配置如下路由： 12345&#123; path: &#x27;/b/:name&#x27;, name: &#x27;b&#x27;, component: () =&gt; import( &#x27;../views/B.vue&#x27;) &#125;, 在B页面可以通过 this.$route.params.name 来获取路由传入的name的值 iii.使用父子组件传值由于router-view本身也是一个组件，所以我们也可以使用父子组件传值方式传值，然后在对应的子页面里加上props，因为type更新后没有刷新路由，所以不能直接在子页面的mounted钩子里直接获取最新type的值，而要使用watch。 1&lt;router-view :type=&quot;type&quot;&gt;&lt;/router-view&gt; 12345678910// 子页面......props: [&#x27;type&#x27;]......watch: &#123; type()&#123; // console.log(&quot;在这个方法可以时刻获取最新的数据:type=&quot;,this.type) &#125;,&#125;, 方法七 Vuex原文链接vue组件传值的11种方式","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"},{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"}]},{"title":"文本换行省略","slug":"文本换行","date":"2021-08-19T15:28:19.000Z","updated":"2021-08-19T15:30:57.108Z","comments":true,"path":"2021/08/19/文本换行/","link":"","permalink":"https://andylinwenqin.github.io/2021/08/19/%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/","excerpt":"","text":"vue 将一大串文字分两行显示，超出用省略号表示 众所周知，通过css设置文字强制不换行超出用省略号表示很简单： 123white-space: nowrap; 文本强制不换行；text-overflow:ellipsis; 文本溢出显示省略号；overflow:hidden; 溢出的部分隐藏； 但是如果要想显示两行，超出用省略号表示要怎么写呢？ 12345overflow: hidden;-webkit-line-clamp: 2;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical; -webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：1，display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。2，-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。3，text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"},{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"}]},{"title":"flex布局设置单个元素靠右","slug":"flex布局设置单个元素靠右","date":"2021-08-19T12:45:02.000Z","updated":"2021-08-19T15:26:40.563Z","comments":true,"path":"2021/08/19/flex布局设置单个元素靠右/","link":"","permalink":"https://andylinwenqin.github.io/2021/08/19/flex%E5%B8%83%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9D%A0%E5%8F%B3/","excerpt":"","text":"flex布局设置单个元素靠右父元素布局12display: flex;align-items: center; 方法一12flex: 1;text-align: right; 方法二1margin-left: auto;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"},{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"}]},{"title":"下拉刷新 触底刷新","slug":"Vue下拉刷新 触底刷新","date":"2021-08-10T13:34:26.000Z","updated":"2021-09-04T05:23:04.447Z","comments":true,"path":"2021/08/10/Vue下拉刷新 触底刷新/","link":"","permalink":"https://andylinwenqin.github.io/2021/08/10/Vue%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%20%E8%A7%A6%E5%BA%95%E5%88%B7%E6%96%B0/","excerpt":"","text":"下拉刷新 触底刷新 一、前言下拉刷新和上拉加载这两种交互方式通常出现在移动端中 本质上等同于PC网页中的分页，只是交互形式不同 开源社区也有很多优秀的解决方案，如iscroll、better-scroll、pulltorefresh.js库等等 这些第三方库使用起来非常便捷 我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用 二、实现原理上拉加载及下拉刷新都依赖于用户交互 最重要的是要理解在什么场景，什么时机下触发交互动作 上拉加载首先可以看一张图 上拉加载的本质是页面触底，或者快要触底时的动作 判断页面触底我们需要先了解一下下面几个属性 scrollTop：滚动视窗的高度距离window顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值 clientHeight:它是一个定值，表示屏幕可视区域的高度； scrollHeight：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示body所有元素的总长度(包括body元素自身的padding) 综上我们得出一个触底公式： 1scrollTop + clientHeight &gt;= scrollHeight 简单实现123456789let clientHeight = document.documentElement.clientHeight; //浏览器高度let scrollHeight = document.body.scrollHeight;let scrollTop = document.documentElement.scrollTop; let distance = 50; //距离视窗还用50的时候，开始触发；if ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123; console.log(&quot;开始加载数据&quot;);&#125; 下拉刷新下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作 关于下拉刷新的原生实现，主要分成三步： 监听原生touchstart事件，记录其初始位置的值，e.touches[0].pageY； 监听原生touchmove事件，记录并计算当前滑动的位置值与初始位置值的差值，大于0表示向下拉动，并借助CSS3的translateY属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值； 监听原生touchend事件，若此时元素滑动达到最大值，则触发callback，同时将translateY重设为0，元素回到初始位置 举个例子： Html结构如下： 1234567891011&lt;main&gt; &lt;p class=&quot;refreshText&quot;&gt;&lt;/p &gt; &lt;ul id=&quot;refreshContainer&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;li&gt;555&lt;/li&gt; ... &lt;/ul&gt;&lt;/main&gt; 监听touchstart事件，记录初始的值 12345678910var _element = document.getElementById(&#x27;refreshContainer&#x27;), _refreshText = document.querySelector(&#x27;.refreshText&#x27;), _startPos = 0, // 初始的值 _transitionHeight = 0; // 移动的距离_element.addEventListener(&#x27;touchstart&#x27;, function(e) &#123; _startPos = e.touches[0].pageY; // 记录初始位置 _element.style.position = &#x27;relative&#x27;; _element.style.transition = &#x27;transform 0s&#x27;;&#125;, false); 监听touchmove移动事件，记录滑动差值 12345678910111213_element.addEventListener(&#x27;touchmove&#x27;, function(e) &#123; // e.touches[0].pageY 当前位置 _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值 if (_transitionHeight &gt; 0 &amp;&amp; _transitionHeight &lt; 60) &#123; _refreshText.innerText = &#x27;下拉刷新&#x27;; _element.style.transform = &#x27;translateY(&#x27;+_transitionHeight+&#x27;px)&#x27;; if (_transitionHeight &gt; 55) &#123; _refreshText.innerText = &#x27;释放更新&#x27;; &#125; &#125; &#125;, false); 最后，就是监听touchend离开的事件 1234567_element.addEventListener(&#x27;touchend&#x27;, function(e) &#123; _element.style.transition = &#x27;transform 0.5s ease 1s&#x27;; _element.style.transform = &#x27;translateY(0px)&#x27;; _refreshText.innerText = &#x27;更新中...&#x27;; // todo...&#125;, false); 从上面可以看到，在下拉到松手的过程中，经历了三个阶段： 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作 下拉到一定值时，显示松手释放后的操作提示 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作 触底刷新12345678910111213141516171819202122data() &#123; return &#123; containerHeight: 0, innerHeight: 0, &#125;;&#125;,methods: &#123; scrollBottom() &#123; this.innerHeight = document.body.scrollHeight let scrollTop = document.documentElement.scrollTop; // console.log(&quot;触发&quot;,scrollTop,this.containerHeight,this.innerHeight) if (scrollTop + this.containerHeight &gt;= this.innerHeight - 1) &#123; // console.log(&#x27;触底了&#x27;); this.heightListInit() &#125; &#125;,&#125;mounted() &#123; this.containerHeight = document.documentElement.clientHeight this.innerHeight = document.body.scrollHeight window.addEventListener(&#x27;scroll&#x27;, this.scrollBottom);&#125;,","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"},{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"}]},{"title":"声网视频和音频的学习","slug":"声网视频和音频的学习","date":"2021-08-09T15:20:23.000Z","updated":"2021-08-09T16:23:08.939Z","comments":true,"path":"2021/08/09/声网视频和音频的学习/","link":"","permalink":"https://andylinwenqin.github.io/2021/08/09/%E5%A3%B0%E7%BD%91%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"声网 产品概述Agora 互动直播（Interactive Live Streaming Premium）可以实现一对多，多对多的音视频互动直播。 Agora 互动直播不同于视频通话。视频通话不区分主播和观众，所有用户都可以发言并看见彼此；互动直播的用户分为主播和观众，只有主播可以自由发言，且被其他用户看见。详见通信和直播场景有什么区别。 加入和离开频道Agora Web SDK 使用 [AgoraRTCClient](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象来管理一个本地用户在目标频道内的行为。在加入目标频道之前，你需要先创建一个 AgoraRTCClient 对象。 创建 AgoraRTCClient 对象调用 [AgoraRTC.createClient](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 即可创建 AgoraRTCClient 对象。在创建 AgoraRTCClient 时，你需要指定使用的编码格式（codec）以及频道场景（mode）。 1234const client = AgoraRTC.createClient(&#123; codec: &quot;vp8&quot;, mode: &quot;rtc&quot;,&#125;); 选择视频编码格式codec 设置支持 &quot;vp8&quot;（VP8）和 &quot;h264&quot;（H.264）两种视频编码格式。该设置只会影响发布端的视频编码格式，对于订阅端来说只要其支持该格式的解码，都能正常完成订阅。 举例来说，桌面端 Chrome 58 及以上版本既支持 VP8 也支持 H.264，而 Safari 12.1 以下版本不支持 VP8 编解码；如果频道中有两个主播分别发布了 VP8 和 H.264 的视频流，使用桌面端 Chrome 58 的观众可以解码这两个主播的视频，使用 Safari 12.1 以下版本浏览器的观众只能解码 H.264 的视频流。 不同浏览器和不同设备对这两种编解码格式支持都不同。下表列出不同浏览器所支持的编解码格式作为参考： 浏览器 VP8 H.264 桌面端 Chrome 58+ ✔ ✔ Firefox 56+ ✔ ✔* Safari 12.1+ ✔ ✔ Safari &lt; 12.1 ✘ ✔ Android Chrome 58+ ✔ ?* 选择频道场景频道场景（mode）是 Agora 为了对不同的实时音视频场景进行针对性算法优化而提供的一种设置选项。SDK 支持两种频道场景：&quot;rtc&quot;（通信场景） 和 &quot;live&quot;（直播场景）。 通信场景 &quot;rtc&quot;（通信场景）适用于频道内所有用户需要相互交流且用户总数不太多的场景，如多人会议和在线聊天。 直播场景 &quot;live&quot;（直播场景）适用于发布端很少但是订阅端很多的场景，这种场景下 SDK 定义了两种用户角色：观众（默认）和主播。主播能够发送和接收音视频，观众不能发送、只能接收音视频。你可以通过设置 createClient 的 [role](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/clientconfig.html#role) 参数来指定用户角色，也可以调用 [setClientRole](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#setclientrole) 来动态修改用户角色。 加入频道创建 AgoraRTCClient 对象后，就可以调用 [AgoraRTCClient.join](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 加入频道。 该方法为异步方法，使用时需要配合 Promise 或 async/await。 注意 join 方法的第四个参数 uid 的设置。不传入任何值时，Agora 会为这个加入的本地用户自动分配一个 Number 型的用户 ID 作为其唯一的身份标识。你也可以通过该参数自行指定一个 Number 型的用户 ID。 请确保频道内用户 ID 的唯一性。Agora 建议你在业务层面避免用户使用相同的 ID 加入一个频道。 12345// 自动分配数字 UIDconst uid = await client.join(&quot;APPID&quot;, &quot;CHANNEL&quot;, &quot;TOKEN&quot;);// 指定数字 UIDawait client.join(&quot;APPID&quot;, &quot;CHANNEL&quot;, &quot;TOKEN&quot;, 393939); 离开频道调用 [AgoraRTCClient.leave](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave) 可以离开当前频道。该方法可以在任何时候调用，包括正在加入频道时或者正在重连时。 该方法为异步方法，使用时需要配合 Promise 或 async/await。 调用 leave 后，SDK 会立刻销毁与当前频道相关的对象，包括订阅的远端用户对象、远端轨道对象、记录连接状态的对象等。如果需要再次加入频道，在调用 leave 后再调用 join 即可。 1await client.leave(); 频道内的连接状态详见[频道连接状态管理](https://docs.agora.io/cn/Interactive Broadcast/channel_connection_web_ng?platform=Web)。 错误处理在加入频道的过程中，因为 SDK 使用不当或者网络异常等原因，可能会抛出以下错误： INVALID_PARAMS: 提供的参数错误，比如提供了格式非法的 Token。 INVALID_OPERATION: 非法操作。该错误通常是重复加入频道引起的，请确保重复加入时先调用 leave。 OPERATION_ABORTED: 加入被中止，表示在 join 方法成功之前就调用了 leave 方法。 UNEXPECTED_RESPONSE: Agora 服务器返回了非预期的响应，通常是因为 App ID 或 Token 鉴权失败，例如开启了 App 证书却未传入 Token。 UID_CONFLICT: 创建了多个 AgoraRTCClient 对象，且重复使用了同一个用户 ID。 创建本地轨道对象本文仅适用于 Agora Web SDK 4.x 版本。 本文详细介绍如何使用 Agora Web SDK 创建本地的音视频轨道对象。 在介绍具体的 API 之前，你需要了解本地轨道对象的一些设计细节。Agora Web SDK 使用了面向对象的设计模式，使用 [LocalTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html) 这一个基础的抽象类来描述所有的本地轨道对象，它定义了本地轨道对象的公共方法和行为，所有的本地轨道对象都继承于 LocalTrack。 publish 方法只要求发布的对象是 LocalTrack ，所以无论通过什么方式创建的本地轨道对象，都满足 publish 方法的参数要求。 基于 LocalTrack，SDK 定义了 [LocalAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 和 [LocalVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html)，分别代表本地音频轨道对象和本地视频轨道对象。这两个类分别针对音视频不同的特性增加了不同的方法，比如 LocalAudioTrack 增加了获取和控制音量的方法、LocalVideoTrack 增加了设置美颜功能的方法。 最后，根据不同的应用场景和创建方式， SDK 基于 LocalAudioTrack 和 LocalVideoTrack 提供了更上层的本地轨道类。比如继承自 LocalVideoTrack 的 CameraVideoTrack，这个类表明这个本地视频轨道是来自于摄像头采集的视频，所以这个类增加了控制摄像头、调整分辨率等方法。 下图展示了这几个类之间的关系： 创建轨道SDK 支持通过以下方式创建本地轨道对象。 使用麦克风和摄像头最常用的方法是直接通过麦克风或者摄像头采集的音视频来创建本地轨道对象，SDK 提供了三种方法： [createCameraVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack)：使用摄像头采集的视频来创建本地视频轨道，返回一个 [CameraVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 对象。 [createMicrophoneAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack)：使用麦克风采集的音频来创建本地音频轨道，返回一个 [MicrophoneAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 对象。 [createMicrophoneAndCameraTracks](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks)：同时使用麦克风和摄像头采集的音视频创建本地轨道，返回一个包含 [CameraVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 和 [MicrophoneAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 的列表。 如果使用 createMicrophoneAndCameraTracks 创建本地轨道，因为音频和视频采集是一次完成的，所以只要摄像头和麦克风其中一个无法完成采集就会导致整个采集的失败，SDK 会抛出错误，详见[错误处理](https://docs.agora.io/cn/Interactive Broadcast/create_local_track_web_ng?platform=Web#error)。如果分别调用 createCameraVideoTrack 和 createMicrophoneAudioTrack ，其中一个采集失败不会影响另外一个。请根据你的实际需求选用合适的方法。 12345678// 采集摄像头const cameraTrack = await AgoraRTC.createCameraVideoTrack();// 采集麦克风const microphoneTrack = await AgoraRTC.createMicrophoneAudioTrack();// 同时采集摄像头和麦克风const [microphoneTrack, cameraTrack] = await AgoraRTC.createMicrophoneAndCameraTracks(); 调用以上方法时你可以传入一个配置参数来控制采集的行为，详细的参数定义可以参考 [CameraVideoTrackInitConfig](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/cameravideotrackinitconfig.html) 或者 [MicrophoneAudioTrackInitConfig](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/microphoneaudiotrackinitconfig.html)。 以上方法均为异步方法，使用时需要配合 Promise 或 async/await。 使用屏幕画面SDK 提供 [createScreenVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 方法来创建屏幕共享轨道，这个方法会返回 LocalVideoTrack 对象。由于 LocalVideoTrack 只实现了视频轨道对象的基础方法，因此通过屏幕创建的轨道无法像摄像头轨道那样控制分辨率或切换设备。 1const screenTrack = await AgoraRTC.createScreenVideoTrack(); 该方法为异步方法，使用时需要配合 Promise 或 async/await。 如果你需要在 Electron 或较老版本的 Chrome 上使用屏幕共享，或者希望在共享屏幕的同时分享音频，可以参考[屏幕共享](https://docs.agora.io/cn/Interactive Broadcast/screensharing_web_ng)。 使用本地或在线的音频文件SDK 提供 [createBufferSourceAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 方法来通过本地或者在线的音频文件创建本地音频轨道对象。通过该方法创建的对象类型为 BufferSourceAudioTrack，该对象继承自 LocalAudioTrack，在其基础上增加了控制音频文件播放行为的方法，比如暂停播放、跳转播放、循环播放等。 你可以使用这个方法实现混音或者播放音效的功能，详见[播放音效/混音](https://docs.agora.io/cn/Interactive Broadcast/audio_effect_mixing_web_ng)。 该方法为异步方法，使用时需要配合 Promise 或 async/await。 12345678const audioFileTrack = await AgoraRTC.createBufferSourceAudioTrack(&#123; source: &quot;https://web-demos-static.agora.io/agora/smlt.flac&quot;,&#125;);// 在播放之前先调用该方法读取音频文件audioFileTrack.startProcessAudioBuffer();audioFileTrack.play(); 使用自定义方式如果你熟悉 WebRTC 或者 MediaStreamTrack 相关的 API，你可以通过自己实现采集来完成 MediaStreamTrack 的创建，然后通过 [createCustomAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 或者 [createCustomVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 方法将 MediaStreamTrack 对象转换成 SDK 内部的 LocalAudioTrack 或者 LocalVideoTrack 对象。 1234567// 通过自己实现采集获取 `MediaStreamTrack` 对象const customMediaStreamTrack = getMediaStreamTrackFromXXX(/* .. */);// 创建自定义的视频轨道const customTrack = AgoraRTC.createCustomVideoTrack(&#123; mediaStreamTrack: customMediaStreamTrack,&#125;); 启用和禁用本地轨道创建好本地的轨道对象后，如果想要暂时关闭麦克风或摄像头，你可以禁用该轨道。SDK 提供 [LocalTrack.setEnabled](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 方法来启用或者禁用本地轨道对象。 该方法为异步方法，使用时需要配合 Promise 或 async/await。 调用 setEnabled(true) 禁用本地轨道后，该轨道会停止本地播放。如果该轨道已经发布，发布也会停止，此时远端会收到 user-unpublished 回调；调用 setEnabled(true) 后，SDK 会自动重新发布轨道。 根据本地轨道类型的不同，调用 setEnabled 后会有一些不同的行为： 通过设备采集创建的本地轨道（CameraVideoTrack/MicrophoneAudioTrack）：当调用 setEnabled(false) 后，会停止采集并释放其占用的设备。如果摄像头或麦克风有指示灯，此时指示灯会熄灭。当调用 setEnabled(true) 后，会自动恢复采集。 通过其他方式创建的本地轨道：当调用 setEnabled(false) 后，会默认编码黑屏帧（视频轨道）或者静音包（音频轨道）。当调用 setEnabled(true) 后，会自动恢复正常编码。 123456789const videoTrack = await AgoraRTC.createCameraVideoTrack();// 暂时关闭摄像头采集await videoTrack.setEnabled(false);// ...// 恢复摄像头采集await videoTrack.setEnabled(true); 错误处理在创建本地音视频对象的过程中，由于不同设备和浏览器之间的差异，SDK 可能在调用上述方法时抛出异常。以下是调用创建轨道的方法时可能会遇到的错误： NOT_SUPPORTED: 使用的功能在当前浏览器上不支持。 MEDIA_OPTION_INVALID: 指定的采集参数无法被满足，一般是因为设备不支持指定的分辨率或帧率。 DEVICE_NOT_FOUND: 找不到指定的采集设备。 PERMISSION_DENIED: 用户拒绝授予访问摄像头/麦克风的权限，或者屏幕共享选择共享源时，用户没有选择共享源，并关闭了选择窗口。 CONSTRAINT_NOT_SATISFIED: 浏览器不支持指定的采集选项。 SHARE_AUDIO_NOT_ALLOWED: 屏幕共享分享音频时用户没有勾选分享音频。 发布和订阅本文仅适用于 Agora Web SDK 4.x 版本。 本文详细介绍如何使用 Agora Web SDK 发布和取消发布本地音视频，以及订阅和取消订阅远端音视频。 发布音视频完成本地轨道的创建并且成功加入频道后，就可以调用 [AgoraRTCClient.publish](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish) 将本地的音视频数据发布到当前频道，以供频道中的其他用户订阅。 123456789const localAudioTrack = ...;const localVideoTrack = ...;// 你可以多次调用 publish 发布多个轨道await client.publish(localAudioTrack);await client.publish(localVideoTrack);// 也可以一次性将需要发布的轨道一起发布await client.publish([localAudioTrack, localVideoTrack]); 关于发布，注意事项如下： 同一时间只能发布一个视频轨道。 可以同时发布多个音频轨道，SDK 会自动混音。 Safari 12 之前的版本不支持混音，无法使用此特性。 可以多次调用该方法来发布不同的轨道，但是不能重复发布同一个轨道对象。 该方法为异步方法，使用时需要配合 Promise 或 async/await。 错误处理在发布过程中，可能因为网络环境或者 SDK 使用不当抛出以下错误： INVALID_OPERATION: 非法操作，说明在加入频道成功之前就调用了 publish 方法。 OPERATION_ABORTED: 发布被中止，可能是因为在发布成功之前就主动调用 leave 离开了频道。 INVALID_LOCAL_TRACK: 参数错误，传入了非法的 LocalTrack 对象。 CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS: 不允许同时发布多个视频轨道。 NOT_SUPPORTED: 发布了多个音频轨道，但是浏览器不支持混音。 UNEXPECTED_RESPONSE: 收到了 Agora 服务器异常的返回，发布轨道失败。建议保留日志，联系 Agora 技术支持。 NO_ICE_CANDIDATE: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 FAQ。 取消发布音视频成功发布本地轨道后，如果想取消发布，可以调用 [AgoraRTCClient.unpublish](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish)。 12345678910// 发布音视频await client.publish([localAudioTrack, localVideoTrack]);// 取消发布视频，此时音频还在正常发布await client.unpublish(localVideoTrack);// 也可以一次将所有正在发布的轨道全部取消发布await client.unpublish();// 或者批量取消发布await client.unpublish([localAudioTrack, localVideoTrack]); 关于取消发布，注意事项如下： 该方法可以多次调用。你可以使用 publish 和 unpublish 实现发布和取消发布某个本地轨道。 该方法为异步方法，使用时需要配合 Promise 或 async/await。 订阅音视频当远端用户成功发布音视频轨道之后，SDK 会触发 [user-published](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件。这个事件携带两个参数：远端用户对象（user）和远端发布的媒体类型（mediaType）。此时，你可以调用 [AgoraRTCClient.subscribe](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 发起订阅。 该方法为异步方法，使用时需要配合 Promise 或者 async/await。 123456789101112131415client.on(&quot;user-published&quot;, async (user, mediaType) =&gt; &#123; // 发起订阅 await client.subscribe(user, mediaType); // 如果订阅的是音频轨道 if (mediaType === &quot;audio&quot;) &#123; const audioTrack = user.audioTrack; // 自动播放音频 audioTrack.play(); &#125; else &#123; const videoTrack = user.videoTrack; // 自动播放视频 videoTrack.play(DOM_ELEMENT); &#125;&#125;); 当订阅方法调用完成之后，你可以通过 user.audioTrack 和 user.videoTrack 获取相应的 [RemoteAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 和 [RemoteVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。 订阅和发布不同，每次订阅只能订阅一个音频或视频轨道。即使发布端同时发布了音频轨道和视频轨道，SDK 也会触发两次 user-published 事件：一次 user-published(audio)，一次 user-published(video)。按照上面的代码逻辑，会完成两次订阅。 处理 Autoplay 问题详见[处理浏览器的自动播放策略](https://docs.agora.io/cn/Interactive Broadcast/autoplay_policy_web_ng)。 错误处理在订阅过程中，因为网络环境等因素 SDK 可能抛出如下错误： INVALID_OPERATION: 非法操作，可能在加入频道成功之前就调用了 subscribe。 INVALID_REMOTE_USER: 传入了非法的远端用户对象，例如该用户不在频道内。 REMOTE_USER_IS_NOT_PUBLISHED：传入的远端用户没有发布 subscribe 方法中传入的媒体类型。 UNEXPECTED_RESPONSE: 收到了 Agora 服务器异常的返回，订阅失败。建议保留日志，联系 Agora 技术支持。 OPERATION_ABORTED: 操作中止，可能在订阅成功之前就调用 leave 离开了频道。 NO_ICE_CANDIDATE: 找不到本地网络出口，可能是网络防火墙或者启用了禁止 WebRTC 的浏览器插件。详见 FAQ。 取消订阅音视频你可以通过 [AgoraRTCClient.unsubscribe](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe) 取消订阅远端的音视频。 12345678// 订阅目标用户的音视频await client.subscribe(user, &quot;audio&quot;);await client.subscribe(user, &quot;video&quot;);// 取消订阅视频await client.unsubscribe(user, &quot;video&quot;);// 也可以取消订阅当前用户的所有媒体类型await client.unsubscribe(user); 关于取消订阅，注意事项如下： 取消订阅成功后，SDK 会释放相应的 RemoteTrack 对象。一旦远端轨道对象被释放，SDK 会自动移除视频的播放元素，音频播放也会停止。 如果远端用户主动取消发布，本地会收到 user-unpublished 回调，收到该回调时 SDK 会自动释放相应的 RemoteTrack 对象，你无需再调用 unsubscribe。 该方法为异步方法，使用时需要配合 Promise 或 async/await。 api文档参考Agora Web SDK 是通过 HTML 网页加载的 JavaScript 和 Typescript 库。你可以使用 Agora Web SDK 在网页浏览器中调用 API 建立连接，控制音视频通话和直播服务。 请务必使用 HTTPS 协议或者 localhost，否则 SDK 无法正常工作。 [全局模块](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#全局模块) [AgoraRTC](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html) 是 Agora Web SDK 中所有可调用方法的入口，主要包含以下方法。 [核心方法](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#核心方法) 方法 描述 [createClient](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 创建本地客户端 [本地音视频采集](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#本地音视频采集) 方法 描述 [createMicrophoneAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack) 通过麦克风创建一个音频轨道对象 [createCameraVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack) 通过摄像头创建一个视频轨道对象 [createMicrophoneAndCameraTracks](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneandcameratracks) 同时创建麦克风音频轨道和摄像头视频轨道 [createScreenVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 通过屏幕共享创建一个视频轨道对象 [createBufferSourceAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 通过音频文件创建一个音频轨道对象 [createCustomAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 创建一个自定义的音频轨道对象 [createCustomVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 创建一个自定义的视频轨道对象 [媒体设备查询](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#媒体设备查询) 方法 描述 [getDevices](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getdevices) 获取媒体设备列表 [getCameras](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getcameras) 获取摄像头列表 [getMicrophones](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getmicrophones) 获取麦克风列表 [getPlaybackDevices](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getplaybackdevices) 获取音频播放设备列表 [getElectronScreenSources](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getelectronscreensources) 获取 Electron 屏幕共享源列表 [日志管理](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#日志管理) 方法 描述 [enableLogUpload](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#enablelogupload) 打开日志上传功能 [disableLogUpload](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#disablelogupload) 关闭日志上传功能 [setLogLevel](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#setloglevel) 设置日志等级 [全局事件回调](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#全局事件回调) 回调 描述 [onCameraChanged](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#oncamerachanged) 视频采集设备状态变化回调 [onMicrophoneChanged](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onmicrophonechanged) 音频采集设备状态变化回调 [onAudioAutoplayFailed](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#onaudioautoplayfailed) 音频轨道自动播放失败回调 [其他](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#其他) 方法 描述 [checkSystemRequirements](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#checksystemrequirements) 检测浏览器兼容性 [getSupportedCodec](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#getsupportedcodec) 获取支持的编码格式 [createChannelMediaRelayConfiguration](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createchannelmediarelayconfiguration) 创建跨频道媒体流转发的配置对象 AgoraRTCClient 类调用 [createClient](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 创建一个本地客户端对象 [AgoraRTCClient](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html)，代表一个通话中的本地用户。AgoraRTCClient 类提供音视频通话的核心功能，主要包含以下方法。 方法 描述 [join](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 加入频道 [leave](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#leave) 离开频道 [publish](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish) 发布本地音视频轨道 [unpublish](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unpublish) 取消发布本地音视频轨道 [subscribe](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 订阅远端用户的音视频轨道 [unsubscribe](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#unsubscribe) 取消订阅远端用户的音视频轨道 LocalTrack 类LocalTrack 是 Agora Web SDK 中定义本地音视频轨道的抽象类，可用于本地播放和发布。 SDK 通过不同的方式创建不同的 LocalTrack，返回不同的 LocalTrack 派生类对象。以下列举了所有的 LocalTrack 派生类以及所对应的创建方式。 [本地音频轨道](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#本地音频轨道) 根据创建方式的不同，本地音频轨道可分为以下三种。其中 LocalAudioTrack 派生自 LocalTrack，MicrophoneAudioTrack 和 BufferSourceAudioTrack 派生自 LocalAudioTrack。 本地音频轨道 描述 [LocalAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 最基础的本地音频轨道对象，包含了基础的本地音频控制，如播放、设置音量控制。 通过调用 [AgoraRTC.createCustomAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomaudiotrack) 创建。 [MicrophoneAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/imicrophoneaudiotrack.html) 本地麦克风音频轨道对象，比 [LocalAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制麦克风的方法。 通过调用 [AgoraRTC.createMicrophoneAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack) 创建。 [BufferSourceAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ibuffersourceaudiotrack.html) 通过读取音频数据源创建的本地音频轨道，比基础的 [LocalAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 多一些控制音频数据源的方法。 通过调用 [AgoraRTC.createBufferSourceAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createbuffersourceaudiotrack) 创建。 [本地视频轨道](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#本地视频轨道) 根据创建方式的不同，本地视频可分为以下两种。其中 LocalVideoTrack 派生自 LocalTrack，CameraVideoTrack 派生自 LocalVideoTrack。 本地视频轨道 描述 [LocalVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html) 最基础的本地视频轨道对象，包含了基础的本地视频控制，如播放、美颜。 通过调用 [AgoraRTC.createCustomVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcustomvideotrack) 或 [AgoraRTC.createScreenVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createscreenvideotrack) 创建。 [CameraVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/icameravideotrack.html) 本地摄像头视频轨道对象，比 [LocalVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalvideotrack.html) 多一些控制摄像头和编码参数的方法。 通过调用 [AgoraRTC.createCameraVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack) 创建。 RemoteTrack 类RemoteTrack 是 Agora Web SDK 中用于定义远端音视频轨道的抽象类。 在实际操作中，你需要先调用 [AgoraRTCClient.subscribe](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#subscribe) 订阅远端用户，然后从远端用户对象 [AgoraRTCRemoteUser](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcremoteuser.html) 中获取派生自 RemoteTrack 的 [RemoteAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iremoteaudiotrack.html) 对象和 [RemoteVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iremotevideotrack.html) 对象。 [引入方式](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#引入方式) 如果你通过 &lt;script&gt; 的方式引入 Agora Web SDK，可以通过访问 [AgoraRTC.createClient](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createclient) 来获取导出的模块。 如果你通过 npm 或者模块化的方式引入 Agora Web SDK，可以通过以下方式访问 AgoraRTC: 12import AgoraRTC from &quot;agora-rtc-sdk-ng&quot;;console.log(AgoraRTC.createClient); [类型模块（适用于 Typescript）](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#类型模块（适用于-typescript）) 对于 Typescript 开发者，我们提供了 .d.ts 文件导出详细的类型定义。你可以查看 API 文档的 [Global](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/globals.html) 页面，该页面列出了所有 SDK 导出的模块和类型。 123import AgoraRTC, &#123; IAgoraRTCClient &#125; from &quot;agora-rtc-sdk-ng&quot;;const client: IAgoraRTCClient = AgoraRTC.createClient(); 错误码SDK 可能以下列方式抛出错误码： 对于异步方法，SDK 返回 Promise 来通知异步操作的结果，Promise 被 reject 时 SDK 会抛出相应的错误码。 同步方法调用失败时，SDK 直接抛出错误码。 SDK 内部运行过程中，也可能抛出一些网络相关的错误码。 你可参考本文了解这些错误码的详细含义及处理方法。 [通用错误码](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#通用错误码) 错误码 描述 处理方法 UNEXPECTED_ERROR 无法处理的、非预期的错误，通常这个错误会有具体的错误提示。 无 UNEXPECTED_RESPONSE 服务端返回了非预期的响应。 无 INVALID_PARAMS 非法参数。 根据具体提示确认操作，并根据文档传入正确的参数。 NOT_SUPPORTED 浏览器不支持。 参考浏览器支持情况。 INVALID_OPERATION 非法操作，通常是因为在当前状态不能进行该操作。 确认操作的先后顺序，比如发布前请确认已经加入频道。 OPERATION_ABORTED 操作中止，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。 通过 [AgoraRTCClient.on(“user-joined”)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。 WEB_SECURITY_RESTRICT 浏览器安全策略限制。 请确保 Web 页面运行在安全环境中。 NO_ACTIVE_STATUS Agora 项目未激活或被禁用。 请前往 Agora 控制台确认项目状态是否为启用。 [请求相关错误码](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#请求相关错误码) 网络连接 错误码 描述 处理方法 NETWORK_TIMEOUT 请求超时，通常是因为网络质量差或连接断开导致与 Agora 服务器通信失败。 通过 [AgoraRTCClient.on(“user-joined”)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_joined) 回调确认本地网络状况，并重试该操作。 NETWORK_RESPONSE_ERROR 响应错误，一般是状态码非法。 确认操作的参数是否正确，并根据文档传入正确的参数。 NETWORK_ERROR 无法定位的网络错误。 无 SDK 内部请求 错误码 描述 处理方法 WS_ABORT 请求 Agora 服务器过程中 WebSocket 断开。 监听 [AgoraRTCClient.on(“connection-state-change”)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 CONNECTED 后重试。 WS_DISCONNECT 请求 Agora 服务器前，WebSocket 就已经断开。 监听 [AgoraRTCClient.on(“connection-state-change”)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_connection_state_change) 事件，待连接状态变为 CONNECTED 后重试。 WS_ERR WebSocket 连接发生错误。 检查当前浏览器对 WebSocket 的支持情况。 [设备管理相关错误码](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#设备管理相关错误码) 错误码 描述 处理方法 ENUMERATE_DEVICES_FAILED 枚举本地设备失败，一般是由于浏览器限制。 无 DEVICE_NOT_FOUND 无法找到指定设备。 传入正确的设备 ID。 [Track 相关错误码](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#track-相关错误码) 错误码 描述 处理方法 TRACK_IS_DISABLED 轨道被禁用，通常因为轨道设置了 [Track.setEnabled(false)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled)。 对该轨道调用 [Track.setEnabled(true)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocaltrack.html#setenabled) 后再进行操作。 SHARE_AUDIO_NOT_ALLOWED 屏幕共享音频时终端用户没有点击分享音频。 要求终端用户在弹出的屏幕共享窗口中勾选分享音频。 CHROME_PLUGIN_NO_RESPONSE Chrome 屏幕共享插件无响应。 确认 [Chrome 屏幕共享插件](https://docs.agora.io/cn/Interactive Broadcast/chrome_screensharing_plugin)的状态或重新安装屏幕共享插件。 CHROME_PLUGIN_NOT_INSTALL Chrome 屏幕共享插件没有安装。 安装 [Chrome 屏幕共享插件](https://docs.agora.io/cn/Interactive Broadcast/chrome_screensharing_plugin)。 MEDIA_OPTION_INVALID 不支持的媒体采集的参数。 修改媒体采集参数或使用 SDK 预设的配置。 CONSTRAINT_NOT_SATISFIED 不支持的媒体采集的参数。 修改媒体采集参数或使用 SDK 预设的配置。 PERMISSION_DENIED 获取媒体设备权限被拒绝。 在弹出的获取设备权限窗口中选择允许。 FETCH_AUDIO_FILE_FAILED 下载在线音频文件失败。 填入正确的在线音频地址，并确保可以正常访问。 READ_LOCAL_AUDIO_FILE_ERROR 读取本地音频文件失败。 填入正确的本地音频文件路径。 DECODE_AUDIO_FILE_FAILED 音频文件解码失败，可能是因为音频文件的编码格式是浏览器 WebAudio 不支持的编码格式。 检查浏览器 WebAudio 是否支持音频文件的编码格式。 [Client 相关错误码](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#client-相关错误码) 加入频道 错误码 描述 处理方法 UID_CONFLICT 同一个频道内 UID 重复。 使用不同的 UID 进入频道。 INVALID_UINT_UID_FROM_STRING_UID String UID 分配服务返回了非法的 int UID。 使用不同的 UID 进入频道。 CAN_NOT_GET_PROXY_SERVER 无法获取云代理服务地址。 无 CAN_NOT_GET_GATEWAY_SERVER 无法获取 Agora 服务器地址。 无 发布/取消发布 错误码 描述 处理方法 INVALID_LOCAL_TRACK 传入了非法的 LocalTrack。 检查传入的 Track，并传入正确的 LocalTrack。 CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS 一个 Client 发布多个视频轨道。 一个 Client 同一时间只能发布一个视频轨道，如果想发布多个视频轨道请创建多个 Client。 订阅/取消订阅 错误码 描述 处理方法 INVALID_REMOTE_USER 非法的远端用户，可能是远端用户不在频道内或还未发布任何媒体轨道。 收到 [AgoraRTCClient.on(“user-published”)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published) 事件后再进行订阅操作。 REMOTE_USER_IS_NOT_PUBLISHED 远端用户已发布了音频或视频轨道，但不是与你的订阅操作所指定的类型不符。 请确保订阅操作传入的轨道类型需要与 [AgoraRTCClient.on(“user-published”)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_user_published)) 事件给出的类型一致，或者在订阅前通过 [AgoraRTCRemoteUser.hasVideo]{@link AgoraRTCRemoteUser.hasVideo} 和 [AgoraRTCRemoteUser.hasAudio]{@link AgoraRTCRemoteUser.hasAudio} 确认远端用户是否发布了该类型的轨道。 [推流到 CDN](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#推流到-cdn) 错误码 描述 处理方法 LIVE_STREAMING_TASK_CONFLICT 推流任务已经存在。 先调用 [Client.stopLiveStreaming](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#stoplivestreaming) 停止该推流任务再重新进行推流操作。 LIVE_STREAMING_INVALID_ARGUMENT 推流参数错误。 参考 [Client.startLiveStreaming](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#startlivestreaming) 的 API 文档检查推流操作的参数。 LIVE_STREAMING_INTERNAL_SERVER_ERROR 推流服务器内部错误。 重新进行推流操作，如果仍然失败，刷新页面重试。 LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED 推流 URL 被占用。 检查填入的 URL 是否被占用。 LIVE_STREAMING_CDN_ERROR 推流的目标 CDN 出现错误导致推流失败。 确认目标 CDN 的健康状况。 LIVE_STREAMING_INVALID_RAW_STREAM 推流超时。 确认目标流是否存在。 [跨频道连麦](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/index.html#跨频道连麦) 错误码 描述 CROSS_CHANNEL_WAIT_STATUS_ERROR 等待 [AgoraRTCClient.on(“channel-media-relay-state”)](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#event_channel_media_relay_state) 回调出错。 CROSS_CHANNEL_FAILED_JOIN_SRC 发起跨频道转发媒体流请求失败。 CROSS_CHANNEL_FAILED_JOIN_DEST 接受跨频道转发媒体流请求失败。 CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST 服务器接收跨频道转发媒体流失败。 CROSS_CHANNEL_SERVER_ERROR_RESPONSE 服务器响应出错。 官方实例本文仅适用于 Agora Web SDK 4.x 版本。如果你使用的是 3.x 或之前版本，请查看以下文档： [跑通视频直播示例项目](https://docs.agora.io/cn/Interactive Broadcast/run_demo_live_web?platform=Web) [实现音频直播](https://docs.agora.io/cn/Interactive Broadcast/start_live_audio_web?platform=Web) [实现视频直播](https://docs.agora.io/cn/Interactive Broadcast/start_live_web?platform=Web) 根据本文指导快速集成 Agora Web SDK 并在你自己的 app 里实现实时音视频直播。 由于浏览器的安全策略对除 127.0.0.1 以外的 HTTP 地址作了限制，Agora Web SDK 仅支持 HTTPS 协议或者 http://localhost（http://127.0.0.1）。请勿使用 HTTP 协议在 http://localhost（http://127.0.0.1） 之外访问你的项目。 开源示例项目我们在 GitHub 上提供一个开源的示例项目供你参考。 同时，你可以通过我们的在线 Web 应用快速体验 Agora 实现的音视频相关功能。 前提条件 可以连接到互联网的 Windows 或 macOS 计算机。如果你的网络环境部署了防火墙，请参考[应用企业防火墙限制](https://docs.agora.io/cn/Agora Platform/firewall?platform=Web)以正常使用 Agora 服务。 计算机搭载 2.2 GHz Intel 第二代 i3/i5/i7 处理器或同等性能的其他处理器。 物理音视频采集设备，如内置摄像头和麦克风。 安装最新稳定版 Chrome 浏览器。 有效的 Agora [开发者账号](https://docs.agora.io/cn/Agora Platform/sign_in_and_sign_up?platform=Web)。 获取 SDK选择如下任意一种方法获取 Agora Web SDK： 方法 1. 使用 npm 获取 SDK使用该方法需要先安装 npm，详见 npm 快速入门。 运行安装命令： 1npm install agora-rtc-sdk-ng --save 在你的项目的 JavaScript 代码中加入以下代码，引入这个模块： 12import AgoraRTC from &quot;agora-rtc-sdk-ng&quot;const client = AgoraRTC.createClient(&#123; mode: &quot;rtc&quot;, codec: &quot;vp8&quot; &#125;); 如果你使用 TypeScript, 还可以引入 SDK 中的类型对象： 12import AgoraRTC, &#123; IAgoraRTCClient &#125; from &quot;agora-rtc-sdk-ng&quot;const client: IAgoraRTCClient = AgoraRTC.createClient(&#123; mode: &quot;rtc&quot;, codec: &quot;vp8&quot; &#125;); 方法 2. 使用 CDN 方法获取 SDK该方法无需下载安装包。在项目 HTML 文件中，添加如下代码： 1&lt;script src=&quot;https://download.agora.io/sdk/release/AgoraRTC_N-4.6.2.js&quot;&gt;&lt;/script&gt; 方法 3. 手动下载 SDK [下载](https://docs.agora.io/cn/Interactive Broadcast/downloads?platform=Web) Agora Web SDK 4.x 版本 SDK 包。 将下载下来的 .js 文件保存到项目文件所在的目录下。 在项目文件中，将如下代码添加到 HTML 中： 1&lt;script src=&quot;./AgoraRTC_N-4.6.2.js&quot;&gt;&lt;/script&gt; 在方法 2 和方法 3 中，SDK 都会在全局导出一个 AgoraRTC 对象，直接访问这个对象即可操作 SDK。 在我们的示例项目中，为方便起见，我们选择第二种方法，直接使用 CDN 链接。 现在，我们已经将 Agora Web SDK 集成到项目中了。下一步我们要调用 Agora Web SDK 提供的核心 API。 常用对象在使用 Agora Web SDK 时，你会经常用到以下三种对象： [AgoraRTCClient](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html) 对象，代表一个本地客户端。AgoraRTCClient 类的方法提供了音视频通话的主要功能，例如加入频道、发布音视频轨道等。 [LocalTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/ilocalaudiotrack.html) 对象和 [RemoteTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iremotetrack.html) 对象，代表本地和远端的音视频轨道对象，用于播放等音视频相关的控制。 音视频流由音视频轨道构成。在 Agora Web SDK 中，我们通过操作音视频轨道对象来控制音视频流的行为。 基本流程一次简单的音视频直播的步骤一般如下： 根据项目的 App ID 创建一个本地客户端 AgoraRTCClient 对象， 调用 AgoraRTCClient.setClientRole 设置用户角色。 通过 AgoraRTCClient.join 加入到一个指定的频道中。 通过麦克风采集的音频创建一个 MicrophoneAudioTrack 对象（本地音频轨道对象）；通过摄像头采集的视频创建一个 CameraVideoTrack 对象（本地视频轨道对象）。 通过 AgoraRTCClient.publish 将创建的本地音视频轨道对象发布到频道中。 当有其他用户加入频道并且也发布音视频轨道时： SDK 会触发 client.on(&quot;user-published&quot;) 事件，在这个事件回调函数的参数中你可以拿到远端用户对象 AgoraRTCRemoteUser，表示这个用户刚刚发布了音视频轨道。 通过 AgoraRTCClient.subscribe 订阅获取到的 AgoraRTCRemoteUser。 订阅完成后，访问 AgoraRTCRemoteUser.audioTrack 和 AgoraRTCRemoteUser.videoTrack 即可获取到 RemoteAudioTrack（远端音频轨道对象）和 RemoteVideoTrack（远端视频轨道对象）。 下图展示了基础的音视频直播的 API 调用。注意图中的方法是对不同的对象调用的。 为方便起见，我们预定义了两个变量和一个函数，下面的所有示例代码都包裹在这个函数中。此步骤不是必须的，你可以根据你的项目有其他的实现。 1234567891011121314151617181920212223242526var rtc = &#123; // 用来放置本地客户端。 client: null, // 用来放置本地音视频频轨道对象。 localAudioTrack: null, localVideoTrack: null,&#125;;var options = &#123; // 替换成你自己项目的 App ID。 appId: &quot;&lt;YOUR APP ID&gt;&quot;, // 传入目标频道名。 channel: &quot;demo_channel_name&quot;, // 如果你的项目开启了 App 证书进行 Token 鉴权，这里填写生成的 Token 值。 token: null, // 设置频道内的用户角色，可设为 &quot;audience&quot; 或 &quot;host&quot; role: &quot;audience&quot;&#125;;async function startBasicLive() &#123; /** * 接下来的代码写在这里。 */&#125;startBasicLive(); 1. 创建本地客户端1rtc.client = AgoraRTC.createClient(&#123; mode: &quot;live&quot;, codec: &quot;vp8&quot; &#125;); 调用 createClient 方法创建本地客户端对象。需注意 mode 和 codec 这两个参数的设置： mode 用于设置[频道场景](https://docs.agora.io/cn/Agora Platform/terms?platform=All Platforms#channel-profile)。Agora Web SDK 会根据使用场景的不同实行不同的优化策略。 一对一或多人通话中，建议设为 &quot;rtc&quot;，使用通信场景。 互动直播中，建议设为 &quot;live&quot;，使用直播场景。 codec 用于设置浏览器使用的编解码格式。如果你需要使用 Safari 12.1 及之前版本，将该参数设为 &quot;h264&quot;；其他情况我们推荐使用 &quot;vp8&quot;。 2. 设置用户角色直播频道有两种用户角色：主播和观众，默认的角色为观众。直播频道内的用户，只能看到主播的画面、听到主播的声音。 设置频道场景为直播后，你可以调用 setClientRole 方法设置用户角色。 12// Role 的值可以是 &quot;host&quot; 或者 &quot;audience&quot;。client.setClientRole(options.role); 加入频道后，如果你想切换用户角色，也可以调用 setClientRole 方法。 3. 加入目标频道1const uid = await rtc.client.join(options.appId, options.channel, options.token, null); 调用 join 加入目标频道。该方法返回一个 Promise，当返回 resolve 时表示加入频道成功，返回 reject 时表示加入频道出现错误。我们可以利用 async/await 极大地简化我们的代码。 调用 join 方法时你需要注意以下参数： appid: 你的 App ID。详见[创建 Agora 项目](https://docs.agora.io/cn/Interactive Broadcast/run_demo_video_call_web?platform=Web##1-创建-agora-项目)和[获取 App ID](https://docs.agora.io/cn/Interactive Broadcast/run_demo_video_call_web?platform=Web#appid)。 channel: 频道名，长度在 64 字节以内的字符串。在我们的示例项目中，channel 的值设为 demo_channel_name。 token: （可选）如果你的 Agora 项目开启了 App 证书，你需要在该参数中传入一个 Token，详见[使用 Token](https://docs.agora.io/cn/Agora Platform/token?platform=All Platforms#使用-token)。 在测试环境，我们推荐使用控制台生成临时 Token，详见[获取临时 Token](https://docs.agora.io/cn/Agora Platform/token?platform=All Platforms%23get-a-temporary-token#获取临时-token)。 在生产环境，我们推荐你在自己的服务端生成 Token，详见 生成 Token 在我们的示例项目中，为了叙述方便，没有开启 App 证书，所以不需要校验 Token，token 的值为 null。如果你启用了 App 证书，请确保上面传入的 channel 值和生成 Token 时传入的 channel 值保持一致。 uid：用户 ID，频道内每个用户的 UID 必须是唯一的。你可以填 null，Agora 会自动分配一个 UID 并在 join 的结果中返回。 更多的 API 介绍和注意事项请参考 [AgoraRTCClient.join](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#join) 接口中的参数描述。 4. 创建并发布本地音视频轨道当用户角色设为主播时，成功加入频道后，就可以创建并发布本地音视频轨道了。 如果用户角色设为观众，跳过该步骤。 12345678// 通过麦克风采集的音频创建本地音频轨道对象。rtc.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();// 通过摄像头采集的视频创建本地视频轨道对象。rtc.localVideoTrack = await AgoraRTC.createCameraVideoTrack();// 将这些音视频轨道对象发布到频道中。await rtc.client.publish([rtc.localAudioTrack, rtc.localVideoTrack]);console.log(&quot;publish success!&quot;); 我们先调用 createMicrophoneAudioTrack 通过麦克风采集的音频创建本地音频轨道对象，调用 createCameraVideoTrack 通过摄像头采集的视频创建本地视频轨道对象；然后调用 publish 方法，将这些本地音视频轨道对象当作参数即可将音视频发布到频道中。 以上方法都会返回 Promise，resolve 时代表成功，reject 时代表失败。我们使用 async/await 来让代码逻辑更清晰。 由于加入频道和创建本地音视频轨道没有依赖关系，你可以利用 Promise.all 同时执行这些异步操作。 详细的参数设置（如采集设备和编码参数）请参考相关 API 文档： [createMicrophoneAudioTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createmicrophoneaudiotrack) [createCameraVideoTrack](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartc.html#createcameravideotrack) [publish](https://docs.agora.io/cn/Interactive Broadcast/API Reference/web_ng/interfaces/iagorartcclient.html#publish) 5. 订阅远端用户当远端用户发布音视频轨道时，SDK 会触发 client.on(&quot;user-published&quot;) 事件。我们需要通过 client.on 监听该事件并在回调中订阅新加入的远端用户。 我们建议在创建客户端对象之后立即监听事件，以避免错过任何事件。放在这里介绍是因为叙述顺序。 在 createClient 后下一行插入以下代码，监听 client.on(&quot;user-published&quot;) 事件，当有远端用户发布时开始订阅，并在订阅后自动播放远端音视频轨道对象。 123456789101112131415161718192021222324252627282930313233rtc.client.on(&quot;user-published&quot;, async (user, mediaType) =&gt; &#123; // 开始订阅远端用户。 await rtc.client.subscribe(user, mediaType); console.log(&quot;subscribe success&quot;); // 表示本次订阅的是视频。 if (mediaType === &quot;video&quot;) &#123; // 订阅完成后，从 `user` 中获取远端视频轨道对象。 const remoteVideoTrack = user.videoTrack; // 动态插入一个 DIV 节点作为播放远端视频轨道的容器。 const playerContainer = document.createElement(&quot;div&quot;); // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。 playerContainer.id = user.uid.toString(); playerContainer.style.width = &quot;640px&quot;; playerContainer.style.height = &quot;480px&quot;; document.body.append(playerContainer); // 订阅完成，播放远端音视频。 // 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。 remoteVideoTrack.play(playerContainer); // 也可以只传入该 DIV 节点的 ID。 // remoteVideoTrack.play(playerContainer.id); &#125; // 表示本次订阅的是音频。 if (mediaType === &quot;audio&quot;) &#123; // 订阅完成后，从 `user` 中获取远端音频轨道对象。 const remoteAudioTrack = user.audioTrack; // 播放音频因为不会有画面，不需要提供 DOM 元素的信息。 remoteAudioTrack.play(); &#125;&#125;); 你需要注意 user-published 事件的第二个参数 mediaType, 代表远端用户当前发布的媒体类型： audio: 远端用户发布了音频轨道。 video: 远端用户发布了视频轨道。 当远端用户取消发布或离开频道时，SDK 会触发 client.on(&quot;user-unpublished&quot;) 事件。此时我们需要销毁刚刚动态创建的 DIV 节点。 在刚刚监听 client.on(&quot;user-published&quot;) 事件的代码下一行插入以下代码，监听 client.on(&quot;user-unpublished&quot;) 事件。 12345678rtc.client.on(&quot;user-unpublished&quot;, (user, mediaType) =&gt; &#123; if (mediaType === &quot;video&quot;) &#123; // 获取刚刚动态创建的 DIV 节点。 const playerContainer = document.getElementById(user.uid.toString()); // 销毁这个节点。 playerContainer.remove(); &#125;&#125;); 6. 离开频道通过以下步骤离开频道： 销毁创建的本地音视频轨道，解除网页对摄像头和麦克风的访问。 手动销毁之前动态创建的 DIV 节点。 调用 leave 离开频道。 123456789101112131415async function leaveCall() &#123; // 销毁本地音视频轨道。 rtc.localAudioTrack.close(); rtc.localVideoTrack.close(); // 遍历远端用户。 rtc.client.remoteUsers.forEach(user =&gt; &#123; // 销毁动态创建的 DIV 节点。 const playerContainer = document.getElementById(user.uid); playerContainer &amp;&amp; playerContainer.remove(); &#125;); // 离开频道。 await rtc.client.leave();&#125; 在不同的产品设计中，离开频道可以既不销毁本地流，也不销毁动态创建的 DIV 节点。这些操作不是必须的，根据您自己的情况调整代码。 项目代码AgoraRTC_Audio.vue js核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267&lt;script&gt; import AgoraRTC from &quot;agora-rtc-sdk-ng&quot; export default &#123; name: &#x27;AgoraRTC_Audio&#x27;, props: &#123; uid: &#123; default: null, type: Number &#125;, status: &#123; default: true, type: Boolean &#125;, channel: String, token: String, appId: &#123; type: String, default: &#x27;f4e2f949feaf400583aa1872ffeed2eb&#x27;, &#125;, videoContainerId: String, classroomRole: Number &#125;, data() &#123; return &#123; loading: false, client: null, localAudioTrack: null, localVideoTrack: null, remoteUsers: &#123;&#125;, localStream: null, publishStatus: false, checkDeviceTime: 5, fun: &#123; &#x27;audioinput&#x27;: true, &#x27;videoinput&#x27;: true, &#125; &#125;; &#125;, methods: &#123; async deviceCheck()&#123; console.log(&#x27;deviceCheck&#x27;) AgoraRTC.onMicrophoneChanged = (info) =&gt; &#123; console.log(&quot;microphone changed!&quot;, info.state, info.device); &#125;; let res = &#123; code: 0, msg: &#x27;&#x27; &#125; let devices = await this.getDevices() console.log(devices) if(!Object.keys(devices).length)&#123; res.code = 1 res.msg = this.GLOBAL.errorMsg.main[&#x27;mic device is not fount&#x27;] &#125;else&#123; let &#123;audioinput, videoinput&#125; = devices let audioId = audioinput.deviceId; let videoId = videoinput.deviceId; let audioTrack = await AgoraRTC.createMicrophoneAudioTrack(&#123; microphoneId: audioId &#125;) let videoTrack = await AgoraRTC.createCameraVideoTrack(&#123;cameraId: videoId&#125;); let status = await this.deviceCheckAction(audioTrack, videoTrack) if(!status)&#123; res.code = 0 res.msg = this.GLOBAL.errorMsg.main[&#x27;have mic no volume&#x27;] &#125; &#125; return res &#125;, async getDevices()&#123; let devices = await AgoraRTC.getDevices() console.log(devices) devices = devices || [] let &#123;fun&#125; = this let funDe = &#123;&#125; for(var i in devices)&#123; let &#123;kind&#125; = devices[i] if(!fun[kind] || funDe[kind]) continue funDe[kind] = devices[i] &#125; return funDe &#125;, deviceCheckAction(audioTrack)&#123; let promise = new Promise(success =&gt; &#123; let t = this.checkDeviceTime * 1000 let num = t, status = false let interval = setInterval(() =&gt; &#123; num = num - 1000 const level = audioTrack.getVolumeLevel(); if(level &gt; 0)&#123; status = true &#125; console.log(&quot;local stream audio level&quot;, level); if(t &lt;= 0 || status)&#123; clearInterval(interval) success(true) return &#125; &#125;, 1000); this.GLOBAL.timeoutGet(t).then(() =&gt; &#123; if(!status) success(false) &#125;) &#125;) return promise &#125;, async pageInit()&#123; this.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack(); this.localVideoTrack = await AgoraRTC.createCameraVideoTrack(); this.client = AgoraRTC.createClient(&#123; mode: &quot;rtc&quot;, codec: &quot;vp8&quot; &#125;) this.eventInit() // 订阅自己的视频 if(this.localVideoTrack) this.localVideoTrack.play(this.getVideoContainerId(&#123;uid: this.uid&#125;)) await this.join() // 发布 await this.publishCon(); return true &#125;, async pageInitS()&#123; this.client = AgoraRTC.createClient(&#123; mode: &quot;rtc&quot;, codec: &quot;vp8&quot; &#125;) this.eventInit() await this.join() await this.publishCon(); return true &#125;, async join()&#123; let res = await this.client.join(this.appId, this.channel, this.token, this.uid); console.log(&#x27;join status&#x27;) console.log(res) return res &#125;, async renewToken(token)&#123; token = token || this.token let res = await this.client.renewToken(token) &#125;, getVideoContainerId(user)&#123; // let &#123;videoContainerId&#125; = this // if(videoContainerId) return videoContainerId // const playerContainer = document.createElement(&quot;div&quot;); // // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。 // playerContainer.id = user.uid.toString(); // playerContainer.style.width = &quot;640px&quot;; // playerContainer.style.height = &quot;480px&quot;; // document.body.append(playerContainer); // return playerContainer.id return `$&#123;user.uid&#125;_user_video` &#125;, eventInit()&#123; this.client.on(&quot;user-published&quot;, async (user, mediaType) =&gt; &#123; console.log(&#x27;user-published&#x27;) // 开始订阅远端用户。 await this.client.subscribe(user, mediaType); console.log(&quot;subscribe success&quot;); console.log(mediaType) // 表示本次订阅的是音频。 if (mediaType === &quot;audio&quot;) &#123; // 订阅完成后，从 `user` 中获取远端音频轨道对象。 const remoteAudioTrack = user.audioTrack; // 播放音频因为不会有画面，不需要提供 DOM 元素的信息。 remoteAudioTrack.play(); &#125; // 表示本次订阅的是视频。 if (mediaType === &quot;video&quot;) &#123; // 订阅完成后，从 `user` 中获取远端视频轨道对象。 const remoteVideoTrack = user.videoTrack; // // 动态插入一个 DIV 节点作为播放远端视频轨道的容器。 // const playerContainer = document.createElement(&quot;div&quot;); // // 给这个 DIV 节点指定一个 ID，这里指定的是远端用户的 UID。 // playerContainer.id = user.uid.toString(); // playerContainer.style.width = &quot;640px&quot;; // playerContainer.style.height = &quot;480px&quot;; // document.body.append(playerContainer); // // 订阅完成，播放远端音视频。 // // 传入 DIV 节点，让 SDK 在这个节点下创建相应的播放器播放远端视频。 // remoteVideoTrack.play(playerContainer); // // 也可以只传入该 DIV 节点的 ID。 let id = this.getVideoContainerId(user) remoteVideoTrack.play(id); &#125; &#125;); //远端用户或主播加入频道回调 this.client.on(&#x27;user-joined&#x27;, user =&gt; &#123; console.log(&#x27;用户加入频道&#x27;) console.log(user) &#125;) //远端用户离线回调 this.client.on(&#x27;user-left&#x27;, user =&gt; &#123; console.log(&#x27;用户离开频道&#x27;) console.log(user) &#125;) //报告频道内正在说话的远端用户及其音量的回调 this.client.on(&#x27;volume-indicator&#x27;, data =&gt; &#123; console.log(data) &#125;) //token过期回调 this.client.on(&#x27;token-privilege-did-expire&#x27;, e =&gt; &#123; console.log(&#x27;token 失效&#x27;) this.$emit(&#x27;tokenInvalid&#x27;) &#125;) //token 即将过期(30s) this.client.on(&quot;token-privilege-will-expire&quot;, async () =&gt;&#123; console.log(&#x27;token 即将 失效&#x27;) this.$emit(&#x27;tokenWillInvalid&#x27;) // await client.renewToken(token); &#125;); //异常回调 this.client.on(&#x27;exception&#x27;, this.handlError) &#125;, handlError(e)&#123; console.log(&#x27;agroa error&#x27;) console.log(e) &#125;, async publishCon()&#123; console.log(this.status) if(!this.status) return this.publish() &#125;, async unpublish()&#123; // if(!this.client || !this.publishStatus) return if(!this.client) return console.log(&#x27;unpublish&#x27;) await this.client.unpublish(this.localAudioTrack); this.publishStatus = false &#125;, async publish()&#123; // if(!this.client || this.publishStatus) return if(!this.client) return console.log(&#x27;publish&#x27;) await this.client.publish([this.localAudioTrack, this.localVideoTrack]); console.log(&quot;publish success!&quot;); this.publishStatus = true return true &#125;, async leave()&#123; if(!this.client || !this.client.leave || !this.localAudioTrack || !this.localAudioTrack.close) return // 销毁本地音频轨道。 this.localAudioTrack.close(); this.localVideoTrack.close(); // 离开频道。 await this.client.leave(); &#125;, async bannedVoiceSet(status)&#123; status = status || this.status status ? this.publish() : this.unpublish() &#125;, &#125;, watch: &#123; status: &#123; handler(val)&#123; this.bannedVoiceSet(val) &#125;, deep: true, immediate: true &#125;, &#125;, &#125;&lt;/script&gt; 应用文件代码 123456789101112131415161718192021222324import AgoraRTCAudioVue from &#x27;../../components/AgoraRTC_Audio4.vue&#x27;async agoraInit()&#123; if(this.agoraDisabled)&#123; console.log(&#x27;不开启语音&#x27;) return false &#125; // console.log(&#x27;开启语音&#x27;) let status = await this.deviceCheckOpen() // this.agoraStatus = status // if(!status) return await this.agoraToekInit() if(this.agoraChannelName &amp;&amp; this.agoraToken)&#123; // 开启视频 if(this.classroomRole == 0)&#123; console.log(&quot;teacher&quot;) await this.$refs[&#x27;AgoraRTCAudioVue&#x27;].pageInit() &#125;else&#123; console.log(&quot;student&quot;) await this.$refs[&#x27;AgoraRTCAudioVue&#x27;].pageInitS() &#125; this.micStatusSet(true) &#125;&#125;, 在各个文件中进行带调用完成加入，发布，订阅，销毁等主要功能","categories":[],"tags":[{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"}]},{"title":"小程序问题与解决","slug":"小程序问题与解决","date":"2021-07-25T08:54:42.000Z","updated":"2021-08-02T02:47:02.206Z","comments":true,"path":"2021/07/25/小程序问题与解决/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/","excerpt":"","text":"小程序问题 小程序app.js和首页的index.js的调用顺序首先一个小程序打开一定是先执行app.js中的onlaunch函数，之后才会去执行index.js中的onload函数，但是为什么我们使用wx.login时候将一些获取到的token之类的放到APP.globalData中出现，index.js获取不到信息的问题呢？ 因为但凡是个请求获取，就需要时间，在onlaunch中发起了请求但是回调函数还未返回，index.js页面就开始请求，此时就有可能会出现(看那个执行快)找不到APP.globalData中的数据的问题。 这种情况最好的解决办法就是封装到app.js中，第二个函数放在第一个函数的回调中，确保数据成功拿到了在执行第二个函数。保证函数的顺序性。当然也可以用 setTimeout()强制延缓第二个函数执行时间，很不推荐这种方法。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序基础API的使用","slug":"小程序基础API的使用","date":"2021-07-17T14:14:41.000Z","updated":"2021-07-18T11:13:36.185Z","comments":true,"path":"2021/07/17/小程序基础API的使用/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80API%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"基础API的使用 路由wx.switchTab(Object object)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的 tabBar 页面的路径 (代码包路径)（需在 app.json 的 tabBar 字段定义的页面），路径后不能带参数。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123456789101112// app.json&#123; &quot;tabBar&quot;: &#123; &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;,&#123; &quot;pagePath&quot;: &quot;other&quot;, &quot;text&quot;: &quot;其他&quot; &#125;] &#125;&#125; 123wx.switchTab(&#123; url: &#x27;/index&#x27;&#125;) wx.reLaunch(Object object)关闭所有页面，打开到应用内的某个页面 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的应用内页面路径 (代码包路径)，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’ success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123wx.reLaunch(&#123; url: &#x27;test?id=1&#x27;&#125;) 123456// testPage(&#123; onLoad (option) &#123; console.log(option.query) &#125;&#125;) wx.redirectTo(Object object)关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 ‘path?key=value&amp;key2=value2’ success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123wx.redirectTo(&#123; url: &#x27;test?id=1&#x27;&#125;) wx.navigateTo(Object object)保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 ‘path?key=value&amp;key2=value2’ events Object 否 页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.success 回调函数 属性 类型 说明 eventChannel EventChannel 和被打开页面进行通信 示例代码1234567891011121314151617wx.navigateTo(&#123; url: &#x27;test?id=1&#x27;, events: &#123; // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function(data) &#123; console.log(data) &#125;, someEvent: function(data) &#123; console.log(data) &#125; ... &#125;, success: function(res) &#123; // 通过eventChannel向被打开页面传送数据 res.eventChannel.emit(&#x27;acceptDataFromOpenerPage&#x27;, &#123; data: &#x27;test&#x27; &#125;) &#125;&#125;) 12345678910111213//test.jsPage(&#123; onLoad: function(option)&#123; console.log(option.query) const eventChannel = this.getOpenerEventChannel() eventChannel.emit(&#x27;acceptDataFromOpenedPage&#x27;, &#123;data: &#x27;test&#x27;&#125;); eventChannel.emit(&#x27;someEvent&#x27;, &#123;data: &#x27;test&#x27;&#125;); // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据 eventChannel.on(&#x27;acceptDataFromOpenerPage&#x27;, function(data) &#123; console.log(data) &#125;) &#125;&#125;) wx.navigateBack(Object object) 以 Promise 风格 调用：支持 需要页面权限：小程序不能在插件页面中调用该接口，插件也不能在小程序页面中调用该接口 小程序插件：支持，需要小程序基础库版本不低于 2.1.0 在小程序插件中使用时，只能在当前插件的页面中调用 微信 Windows 版：支持 微信 Mac 版：支持 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。 参数 属性 类型 默认值 必填 说明 delta number 1 否 返回的页面数，如果 delta 大于现有页面数，则返回到首页。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码12345678910111213141516// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码// 此处是A页面wx.navigateTo(&#123; url: &#x27;B?id=1&#x27;&#125;)// 此处是B页面wx.navigateTo(&#123; url: &#x27;C?id=1&#x27;&#125;)// 在C页面内 navigateBack，将返回A页面wx.navigateBack(&#123; delta: 2&#125;) 跳转wx.navigateToMiniProgram(Object object)打开另一个小程序 参数 属性 类型 默认值 必填 说明 appId string 是 要打开的小程序 appId path string 否 打开的页面路径，如果为空则打开首页。path 中 ? 后面的部分会成为 query，在小程序的 App.onLaunch、App.onShow 和 Page.onLoad 的回调函数或小游戏的 wx.onShow 回调函数、wx.getLaunchOptionsSync 中可以获取到 query 数据。对于小游戏，可以只传入 query 部分，来实现传参效果，如：传入 “?foo=bar”。 extraData object 否 需要传递给目标小程序的数据，目标小程序可在 App.onLaunch，App.onShow 中获取到这份数据。如果跳转的是小游戏，可以在 wx.onShow、wx.getLaunchOptionsSync 中可以获取到这份数据数据。 envVersion string release 否 要打开的小程序版本。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.envVersion 的合法值 值 说明 最低版本 develop 开发版 trial 体验版 release 正式版 使用限制需要用户触发跳转从 2.3.0 版本开始，若用户未点击小程序页面任意位置，则开发者将无法调用此接口自动跳转至其他小程序。 需要用户确认跳转从 2.3.0 版本开始，在跳转至其他小程序前，将统一增加弹窗，询问是否跳转，用户确认后才可以跳转其他小程序。如果用户点击取消，则回调 fail cancel。 无需声明跳转名单，不限跳转数量（众测中） 从2020年4月24日起，使用跳转其他小程序功能将无需在全局配置中声明跳转名单，调用此接口时将不再校验所跳转的 AppID 是否在 navigateToMiniProgramAppIdList 中。 从2020年4月24日起，跳转其他小程序将不再受数量限制，使用此功能时请注意遵守运营规范。 运营规范平台将坚决打击小程序盒子等互推行为，使用此功能时请严格遵守《微信小程序平台运营规范》，若发现小程序违反运营规范将被下架处理。 关于调试 在开发者工具上调用此 API 并不会真实的跳转到另外的小程序，但是开发者工具会校验本次调用跳转是否成功。详情 开发者工具上支持被跳转的小程序处理接收参数的调试。详情 示例代码1234567891011wx.navigateToMiniProgram(&#123; appId: &#x27;&#x27;, path: &#x27;page/index/index?id=123&#x27;, extraData: &#123; foo: &#x27;bar&#x27; &#125;, envVersion: &#x27;develop&#x27;, success(res) &#123; // 打开成功 &#125;&#125;) wx.navigateBackMiniProgram(Object object)返回到上一个小程序。只有在当前小程序是被其他小程序打开时可以调用成功 注意：微信客户端 iOS 6.5.9，Android 6.5.10 及以上版本支持 参数 属性 类型 默认值 必填 说明 extraData Object {} 否 需要返回给上一个小程序的数据，上一个小程序可在 App.onShow 中获取到这份数据。 详情。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码12345678wx.navigateBackMiniProgram(&#123; extraData: &#123; foo: &#x27;bar&#x27; &#125;, success(res) &#123; // 返回成功 &#125;&#125;) wx.exitMiniProgram(Object object)退出当前小程序。必须有点击行为才能调用成功。 参数 属性 类型 默认值 必填 说明 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 数据缓存wx.setStorageSync(string key, any data) 以 Promise 风格 调用：支持 小程序插件：支持，需要小程序基础库版本不低于 1.9.6 wx.setStorage 的同步版本 参数string key本地缓存中指定的 key any data需要存储的内容。只支持原生类型、Date、及能够通过JSON.stringify序列化的对象。 示例代码1234wx.setStorage(&#123; key:&quot;key&quot;, data:&quot;value&quot;&#125;) 123try &#123; wx.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;)&#125; catch (e) &#123; &#125; wx.setStorage(Object object) 以 Promise 风格 调用：支持 小程序插件：支持，需要小程序基础库版本不低于 1.9.6 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 参数 属性 类型 默认值 必填 说明 key string 是 本地缓存中指定的 key data any 是 需要存储的内容。只支持原生类型、Date、及能够通过JSON.stringify序列化的对象。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码1234wx.setStorage(&#123; key:&quot;key&quot;, data:&quot;value&quot;&#125;) 123try &#123; wx.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;)&#125; catch (e) &#123; &#125; wx.getStorage(Object object)从本地缓存中异步获取指定 key 的内容。缓存相关策略请查看 存储。 参数 属性 类型 默认值 必填 说明 key string 是 本地缓存中指定的 key success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.success 回调函数 属性 类型 说明 data any key对应的内容 示例代码123456wx.getStorage(&#123; key: &#x27;key&#x27;, success (res) &#123; console.log(res.data) &#125;&#125;) 12345678try &#123; var value = wx.getStorageSync(&#x27;key&#x27;) if (value) &#123; // Do something with return value &#125;&#125; catch (e) &#123; // Do something when catch error&#125; wx.getStorageInfo(Object object)异步获取当前storage的相关信息。缓存相关策略请查看 存储。 参数 属性 类型 默认值 必填 说明 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.success 回调函数 属性 类型 说明 keys Array. 当前 storage 中所有的 key currentSize number 当前占用的空间大小, 单位 KB limitSize number 限制的空间大小，单位 KB 示例代码1234567wx.getStorageInfo(&#123; success (res) &#123; console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize) &#125;&#125;) 12345678try &#123; const res = wx.getStorageInfoSync() console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize)&#125; catch (e) &#123; // Do something when catch error&#125; wx.clearStorage(Object object)清理本地数据缓存。缓存相关策略请查看 存储。 参数 属性 类型 默认值 必填 说明 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123456wx.clearStorage()try &#123; wx.clearStorageSync()&#125; catch(e) &#123; // Do something when catch error&#125;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序登录接口的更新","slug":"小程序登录接口的更新","date":"2021-07-17T04:19:31.000Z","updated":"2021-07-17T14:16:19.525Z","comments":true,"path":"2021/07/17/小程序登录接口的更新/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/","excerpt":"","text":"获取用户信息（2021.4.28微信更新） wx.login调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。 object.success 回调函数 属性 类型 说明 code string 用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 auth.code2Session，使用 code 换取 openid、unionid、session_key 等信息 示例代码123456789101112131415wx.login(&#123; success (res) &#123; if (res.code) &#123; //发起网络请求 wx.request(&#123; url: &#x27;https://example.com/onLogin&#x27;, data: &#123; code: res.code &#125; &#125;) &#125; else &#123; console.log(&#x27;登录失败！&#x27; + res.errMsg) &#125; &#125;&#125;) 实际使用代码1234567891011121314151617wx.login(&#123; success: res =&gt; &#123; that.globalData.code = res.code console.log(glo.copy(res)) let u = &#x27;https://golaxy.weiqiai.com:8080/user/authorize&#x27; that.getData(u, &#123; js_code: res.code &#125;) .then(function (r) &#123; console.log(glo.copy(r)) that.globalData.openId = r.openid let session_key = r.session_key; let u = &#x27;https://golaxy.weiqiai.com:8080/user/getUserInfo&#x27; &#125;, function () &#123; success(false) &#125;) // 发送 res.code 到后台换取 openId, sessionKey, unionId &#125;&#125;) 拿到了openId等信息 wx.getUserProfile获取用户信息。页面产生点击事件（例如 button 上 bindtap 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo。该接口用于替换 wx.getUserInfo， 这个函数只能通过点击事件触发 object.success 回调函数 属性 类型 说明 最低版本 userInfo UserInfo 用户信息对象 2.10.4 rawData string 不包括敏感信息的原始数据字符串，用于计算签名 2.10.4 signature string 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，详见 用户数据的签名验证和加解密 2.10.4 encryptedData string 包括敏感数据在内的完整用户信息的加密数据，详见 用户数据的签名验证和加解密 2.10.4 iv string 加密算法的初始向量，详见 用户数据的签名验证和加解密 2.10.4 cloudID string 敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据，详细见云调用直接获取开放数据 2.10.4 示例代码在开发者工具中预览效果 123456789101112&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;userinfo&quot;&gt; &lt;block wx:if=&quot;&#123;&#123;!hasUserInfo&#125;&#125;&quot;&gt; &lt;button wx:if=&quot;&#123;&#123;canIUseGetUserProfile&#125;&#125;&quot; bindtap=&quot;getUserProfile&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;/block&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334Page(&#123; data: &#123; userInfo: &#123;&#125;, hasUserInfo: false, canIUseGetUserProfile: false, &#125;, onLoad() &#123; if (wx.getUserProfile) &#123; this.setData(&#123; canIUseGetUserProfile: true &#125;) &#125; &#125;, getUserProfile(e) &#123; // 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认 // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗 wx.getUserProfile(&#123; desc: &#x27;用于完善会员资料&#x27;, // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写 success: (res) =&gt; &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125;, getUserInfo(e) &#123; // 不推荐使用getUserInfo获取用户信息，预计自2021年4月13日起，getUserInfo将不再弹出弹窗，并直接返回匿名的用户个人信息 this.setData(&#123; userInfo: e.detail.userInfo, hasUserInfo: true &#125;) &#125;,&#125;) 实际使用代码123456789101112wx.getUserProfile(&#123; desc: &#x27;test&#x27;,&#125;).then(res =&gt; &#123; let userInfo = res.userInfo || &#123;&#125; wx.setStorageSync(&#x27;userInfo&#x27;, userInfo) // that.globalData.userInfo = userInfo this.userInfoSet() success(userInfo) // that.globalData.loged = true&#125;).catch(function (reason) &#123; console.log(reason);&#125;); 个人理解虽然微信这个变动让很多小程序开发者苦不堪言，但是还是很方便的，之前的方式是wx.login获取code给wx.getUserInfo去拿取session_key和openid，然后传给后端，后端去请求用户个人信息，对此很多程序员都封装了组件，类似套娃的方法去实现。 在这次更新后，wx.getUserProfile取缔wx.getUserInfo，wx.getUserProfile必须用点击事件触发例如bindtap(),之前的’套娃组件‘也都要废弃，改成了更加简单的方式，封装一个函数，在app.js页面一开始调用wx.login获取openid。然后在写一个button点击事件bindtap()调用wx.getUserProfile获取以下信息 然后前端在调用接口传个后端存进数据库","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"单工,半双工,全双工三者区别","slug":"单工-半双工-全双工三者区别","date":"2021-07-11T07:10:38.000Z","updated":"2021-07-11T07:15:35.137Z","comments":true,"path":"2021/07/11/单工-半双工-全双工三者区别/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/11/%E5%8D%95%E5%B7%A5-%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%85%A8%E5%8F%8C%E5%B7%A5%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/","excerpt":"","text":"单工 半双工 全双工三者区别 单工单工就是指A只能发信号，而B只能接收信号，通信是单向的，就象灯塔之于航船-灯塔发出光信号而航船只能接收信号以确保自己行驶在正确的航线上。 半双工（Half Duplex）半双工就是指A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。最典型的例子就象我们在影视作品中看到的对讲机一样： 007：呼叫总部，请求支援，OVER 总部：收到，增援人员将在5分钟内赶到，OVER 007：要5分钟这么久？！要快呀！OVER 总部：„„ 在这里，每方说完一句话后都要说个OVER，然后切换到接收状态，同时也告之对方-你可以发言了。如果双方同时处于收状态，或同时处于发状态，便不能正常通信了。 全双工 （Full Duplex）全双工比半双工又进了一步。在A给B发信号的同时，B也可以给A发信号。典型的例子就是打电话。A：我跟你说呀„„B：你先听我说，情况是这样的„„A和B在说的同时也能听到对方说的内容，这就是全双工。 相关链接原文链接","categories":[],"tags":[{"name":"通信机制","slug":"通信机制","permalink":"https://andylinwenqin.github.io/tags/%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"}]},{"title":"Stomp","slug":"STOMP","date":"2021-07-06T11:12:57.000Z","updated":"2021-07-17T03:15:40.158Z","comments":true,"path":"2021/07/06/STOMP/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/06/STOMP/","excerpt":"","text":"学习血汗史查了各类资料花了整整三天才学通，又被跨域卡了一天，直到第五天才完完全全跑通，下一步学习emoji的表情包用法 stomp over websocket协议原理http协议http协议是单工的, 只能由client发请求再由server返回请求结果, 在http协议中server是不能主动发请求到client的. 大多数情况下http协议都是适用的, 但当遇到在线聊天, 股票行情这样需要实时获取取服务端信息的应用时, client需要频繁轮询server过程如下: client 建立连接client 问server有没有新的消息, 并根据返回结果进行处理client 关闭连接client 建立连接client 问server有没有新的消息, 并根据返回结果进行处理client 关闭连接… 为了拿到最新信息, client一直这样循环下去server如果一直没有新的消息, client的大多请求都是无效的, 效率低下. 为了提高效率需要有一种协议可以让server主动发消息给client.这样就不需要client频繁轮询, 只要server有新消息就会主动推送给client. 这种协议就是websocket协议(效果：服务端主动向客户端发送信息). websocket协议webSocket协议是基于TCP的一种网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。在webscoket协议中, client利用http来建立tcp连接, 建立tcp连接之后, client与server就可以基于tcp连接来愉快的进行通信了. 那么webscoket如何利用http建立连接的呢? 先看一个经典图示 建立连接client与server是利用http的一次request, response来建立连接的.其中http request消息体如下: 1234567GET /echo HTTP/1.1Host:jingxu.test.com:8100Origin:http://jingxu.test.com:8099Sec-WebSocket-Extensions:permessage-deflate; client_max_window_bitsSec-WebSocket-Key:rVX0XFeQzA9QVXXEfjm0yw==Sec-WebSocket-Version:13Upgrade:websocket 其中前三个header:Get, Host, Origin都是http协议之前就有, 不多做解释, 主要解释一下后面这几个headerSec-WebSocket-Extensions: 用于对websocket协议进行扩展. 比如websocket协议本身不支持压缩, 但可以通过Sec-WebSocket-Extensions中的permessage-deflate来协商压缩.Sec-WebSocket-Key:client随机生成的一段key. 详情之后response中Sec-WebSocket-Accept的解释.Sec-WebSocket-Version:协议的版本号Upgrade:通过http的Upgrade对协议进行切换. 告诉server, 建立连接后用websocket协议. http response消息体如下: 12345Connection:upgradeDate:Mon, 04 Dec 2017 10:05:18 GMTSec-WebSocket-Accept:q3dUKg4lRGCqqRhGIvmE7sH8Yuc=Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits=15Upgrade:websocket Connection与Date都是http协议之前就有的header, 主要解释一下后面的.Sec-WebSocket-Accept:对应于request中的Sec-WebSocket-Key.server会根据request中的Sec-WebSocket-Key的值来生成response中的Sec-WebSocket-Accept的值.具体的算法是根据Sec-WebSocket-Key与协议中已定义的一个guid “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”进行拼接再对结果进行sha1, 再对sha1的结果进行base64, 最后得到Sec-WebSocket-Accept的值. client通过验证server返回的Sec-WebSocket-Accept的值, 来确定两件事情:server理解websocket协议.如果server不理解, 那么server不会返回正确的Sec-WebSocket-Accept.如果server没有返回正确的Sec-WebSocket-Accept, 那么建立websocket连接失败. server返回的response是对于client的此次reuqest的响应而不是之前的缓存.主要是防止有些缓存服务器返回缓存的response. 发送数据现在websocket连接已经建立, 由于websocket没有规范payload的格式, 所以应用需要自己去定义payload的格式. websocket的payload可以是文本也可以是二进制.应用一般会选择用文本.这个文本是什么格式websocket协议本身并没有规定, 由应用自己来定. 比如我要请求发送消息这个接口, 那么我的payload可以写成: /send | params=我是消息 这里我自己定义了一个格式, 中坚线之前的是要调用的地址, 中竖线之后是参数.由于格式是自己定义的, 所以在服务端我也需要自己写代码来解析这个格式.把/send路由到相应的处理方法. 那有没有一种统一的协议呢? 统一的标准呢?因为这样就会有相应的已经实现的库来解析路由, 而不用自己去写, 自己去定义格式. 这个统一的协议就是stomp协议(一个基于webSocket的通信协议或者说一种标准). stomp协议stomp是一个用于client之间进行异步消息传输的简单文本协议, 全称是Simple Text Oriented Messaging Protocol. 对于stomp协议来说, client分为消费者client与生产者client两种. server是指broker, 也就是消息队列的管理者. stomp协议并不是为websocket设计的, 它是属于消息队列的一种协议, 和amqp, jms平级.只不过由于它的简单性恰巧可以用于定义websocket的消息体格式.stomp协议很多mq都已支持, 比如rabbitmq, activemq. 很多语言也都有stomp协议的解析client库. 可以这么理解, websocket结合stomp相当于一个面向公网对用户比较友好的一种消息队列. stomp协议中的client分为两角色: 生产者: 通过SEND命令给某个目的地址(destination)发送消息. 消费者: 通过SUBSCRIBE命令订阅某个目的地址(destination), 当生产者发送消息到目的地址后, 订阅此目的地址的消费者会即时收到消息. stomp协议的结构与http结构相似, 结构如下: 12345COMMANDheader1:value1 header2:value2 Body^@ 其中^@代表null结尾. 与http相似有三部分组成: 命令, header, 消息体.命令与header使用utf-8格式, body可以是二进制也可以是文本. 命令有SEND, SUBSCRIBE, MESSAGE, CONNECT, CONNECTED等. header类似http有content-length, content-type等.消息体类似http可以是二进制也可以是文本. 下面例举一些主要命令和http, websocket类似, 首先要确认双方都懂stomp这个协议, 通过建立连接来确认.由于我们已经建立了webscoket连接, 接下来我只需要在webscoket连接的基础上建立stomp连接. 将以下内容写到websocket的payload中, 来发送建立stomp连接请求 12345CONNECTaccept-version:1.2host:stomp.github.org^@ stomp协议并不与websocket协议耦合, 比如双方建立了tcp连接, 那么完成可以在tcp连接上建立stomp连接, 也就是将上述内容写到tcp的payload中. server收到后回复, 同样以下内容是在server回复的websocket的消息体中 1234CONNECTEDversion:1.2 ^@ 这样一个stomp连接就建立了, 协议版本为1.2. 由于stomp连接是一个长连接, stomp协议定义了发送心跳来监测stomp连接是否存活. 在CONNECT命令消息中加入heart-beat心跳header来建立连接就开启了心跳: 123456CONNECT accept-version:1.2 heart-beat:&lt;cx&gt;,&lt;cy&gt; host:stomp.github.org ^@ 12345CONNECTED version:1.2heart-beat:&lt;sx&gt;,&lt;sy&gt;^@ 其中&lt;cx&gt;, &lt;cy&gt;, &lt;sx&gt;, &lt;sy&gt;分别代表一个以毫秒为单位的数字. client发送的CONNECT命令消息中的&lt;cx&gt;,&lt;cy&gt;分别代表: &lt;cx&gt;:client能保证的发送心跳的最小间隔, 如果是0代表client不发送心跳.&lt;cy&gt;:client希望收到server心跳的间隔, 如果是0代表client不希望收到server的心跳.与client类似, server发送的CONNECTED命令消息中的,分别代表: &lt;sx&gt;:server能保证的发送心跳的最小间隔, 如果是0代表server不发送心跳. &lt;sy&gt;:server希望收到client心跳的间隔, 如果是0代表server不希望收到client的心跳 如果在建立连接时没有心跳header, 默认当作heart-beat:0,0. 也就是不发心跳, 也不希望对方发心跳. 加入心跳header进行连接后, 最终协商得出发送心跳的频率的逻辑如下:对于client来说, 取与的最大值, 也就是说client会取client最小能发送的间隔与server希望client发送间隔的最大值来发送心跳.如果或中任何一个为0, client都不发送心跳. 类似, 对于server来说, 取与的最大值, 也就是说server取server最小能发送的间隔与client希望server发送间隔的最大值来发送心跳.如果或中任何一个为0, server都不发送心跳. 举个例子, 如下建立连接 123456CONNECTaccept-version:1.2heart-beat:1000,2000host:stomp.github.org^@123456 12345CONNECTEDversion:1.2heart-beat:3000,4000^@ 上述, client发送CONNECT命令消息中heart-beat为1000, 2000.解释为client最小能保证发送心跳间隔为1000毫秒, 希望server发送心跳间隔为2000毫秒 server回复的CONNECTED命令消息中heart-beat为3000,4000解释为server最小能保证发送心跳间隔为3000毫秒, 希望client发送心跳间隔为4000毫秒 最终的协商结果, client取自己能保证的最小心跳间隔1000毫秒与server希望client发送心跳间隔4000毫秒的最大值得出client会每4000毫秒发一次心跳, 同理, server取自己能保证的最小心跳间隔3000毫秒与client希望server发送心跳间隔2000毫秒的最大值得出server会每3000毫秒发一次心跳. client和server根据心跳来判定对方已经挂掉了的逻辑如下: 以server为例, 假设经过协商, client每10秒发送一个心跳. client必须在10秒以内给server至少发送一次数据, 不管是心跳还是正常数据.如果在10秒内client未发送数据, 那么server认为与client的stomp连接已经挂掉.现在连接已经建立, 接下来准备发送stomp消息. 发送消息发送消息使用SEND这个COMMAND, 如下: 123456SENDdestination:/topic/a content-type:text/plain hello world^@ 其中destination这个header的值为发送消息的目的地址.上述SEND命令消息的意思为, 给/topic/a这个目的地址发送一条类型为text/plain, 内容是hello world的消息.所有订阅/topic/a这个目的地址的消费者client都会收到hello world这条消息. stomp协议并没有规定destination的格式, 这个是由使用stomp协议的应用自己来定义.比如, /topic/a, /queue/a, queue.a, topic.a, topic-a, queue-a对于stomp协议来说都是正确的.应用可以自己规定不同的格式以及此格式代表的含义.比如, 应用自己可以定义以/topic打头的为发布订阅模式, 消息会被所有消费者client收到,以/queue打头的为负载平衡模式, 只会被一个消费都client收到. client发送SEND命令消息如何确保server收到了这条消息呢? 协议规定, 可以在SEND命令消息中加入receipt header. receipt header的值唯一确定一次send.server收到有receipt header的SEND命令消息后, 需要回复一个RECEIPT命令消息,里面会包含receipt-id header, receipt-id的值就是SEND命令消息中receipt header的值.这样当client收到了这条RECEIPT命令消息后, 就能确定server已收到SEND命令消息. 例如: 12345SENDdestination:/queue/areceipt:message-12345hello queue a^@12345 1234RECEIPTreceipt-id:message-12345^@ 接下来看一下消费者client如何订阅消息. 订阅消息订阅消息用SUBSCRIBE命令, 如下: 123456SUBSCRIBE id:0 destination:/topic/foo ack:client ^@ 上述代表client订阅/topic/foo这个目的地址.其中多了两个新的header: id与ack. 订阅中的id header此id能唯一确定一个订阅.一个client对于一个server可以订阅多次, 甚至对于同一个目的地址都可以订阅多次.为了唯一确定一次订阅, 协议规定必须包含id header, 此id要求在同一连接中唯一. 订阅中的ack headerack header告诉server, server如何确认client已经收到消息.有三个值: auto, client, client-individual auto表示当server发出消息后就立即确认client收到了消息. 也就是说当client收到消息后不会对server进行确认.client表示只有当server收到client的ack后才确认client收到了消息, 也就是说client需要对server发ack进行确认.这个确认是累积的, 意思是说收到某条消息的ack, 那么这条消息之前的所有的消息, server都认为client已收到.client-individual与client类似. 只不过不是累积的. 每收到一条消息都需要给server回复ack来确认. 有订阅消息, 那肯定有取消订阅消息. 取消订阅取消订阅用UNSUBSCRIBE这个命令 1234UNSUBSCRIBEid:0^@ 取消订阅相对来说比较简单只需要传一个id header.这个id header的值来自订阅时id header值. 这样server才能唯一确定到底要取消哪个订阅. 当有生产者client给目的地址发消息后, 首先server会收到消息, server收到消息后会把消息发送给所有订阅这个目的地址的client, 那么server是如何发送这个消息到消费都client的呢? server发送消息server发送消息用MESSAGE这个命令来给client发送消息, 如下 1234567MESSAGEsubscription:0message-id:007destination:/queue/acontent-type:text/plainhello queue a^@ message-id这个header的值能唯一确定一条消息subscription的值就是订阅时SUBSCRIBE命令中id header的值, 表示这条消息属于哪个订阅. 到此, 介绍了一些stomp常用的命令, 还有一些其他命令, 有兴趣可以查看stomp协议文档: 协议总结由于http是一个单工的协议, server不能主动发送消息给client, 导致http在处理实时性要求高的应用时效率不高. 为了提高效率, 我们使用了全双工的websocket协议, 可以让server主动推送消息. 又由于websocket协议是个底层协议, 不是应用层协议, 未对payload的格式进行规范, 导致我们需要自己定义消息体格式, 自己解析消息体, 成本高, 扩展性也不好, 所以我们引入了已被很多库和消息队列厂商实现的stomp协议, 将websocket协议与stomp协议结合. 我们再总结一下websocket与stomp的优点 websocket相对于http的优点:全双工. 相对于http协议只能由client发送消息. 全双工的websocket协议, server与client都可以发送消息.消息体更轻量. http的一个请求比websocket的请求大不少. 主要因为http的每次请求都要加很多的header. stomp over websocket相对于websocket的优点:不需要自己去规定消息的格式, 以及对消息的格式做解析.由于stomp是一个统一的标准, 有很多库与厂商都对stomp协议进行了支持. 拿来用就可以. 成本低, 扩展好.理论到此为止, 接下来我们一起了解下spring websocket是如何实现stomp over websocket协议的. Stomp使用文档(官方文档翻译版)STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议，它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。 创建STOMP客户端在web浏览器中使用普通的Web Socket STOMP javascript 客户端会使用ws://的URL与STOMP 服务端进行交互。 为了创建一个STOMP客户端js对象，你需要使用Stomp.client(url)，而这个URL连接着服务端的WebSocket的代理 12var url = &quot;ws://localhost:61614/stomp&quot;;var client = Stomp.client(url); Stomp.client(url, protocols)也可以用来覆盖默认的subprotocols。第二个参数可以是一个字符串或一个字符串数组去指定多个subprotocols。 在web浏览器中使用定制的WebSocket 浏览器提供了不同的WebSocket的协议，一些老的浏览器不支持WebSocket的脚本或者使用别的名字。默认下，stomp.js会使用浏览器原生的WebSocket class去创建WebSocket。 但是利用Stomp.over(ws)这个方法可以使用其他类型的WebSockets。这个方法得到一个满足WebSocket定义的对象。 例如，可以使用由SockJS实现的Websocket。 如果使用原生的Websockets就使用Stomp.client(url)，如果需要使用其他类型的Websocket（例如由SockJS包装的Websocket）就使用Stomp.over(ws)。除了初始化有差别，Stomp API在这两种方式下是相同的。 在node.js程序中 通过stompjs npm package同样也可以在node.js程序中使用这个库。 1npm install stompjs 在node.js app中，require这个模块：var Stomp = require(&#39;stompjs&#39;); 为了与建立在TCP socket的STOMP-broker连接，使用Stomp.overTCP(host, port)方法。 1var client = Stomp.overTCP(&#x27;localhost&#x27;, 61613); 为了与建立在Web Socket的STOMP broker连接，使用Stomp.overWS(url)方法。 1var client = Stomp.overWS(&#x27;ws://localhost:61614/stomp&#x27;); 除了初始化不同，无论是浏览器还是node.js环境下，Stomp API都是相同的。 连接服务端 一旦Stomp 客户端建立了，必须调用它的connect()方法去连接Stomp服务端进行验证。这个方法需要两个参数，用户的登录和密码凭证。这种情况下，客户端会使用Websocket打开连接，并发送一个CONNECT frame。 这个连接是异步进行的：你不能保证当这个方法返回时是有效连接的。为了知道连接的结果，你需要一个回调函数。 123var connect_callback = function() &#123; // called back after the client is connected and authenticated to the STOMP server&#125;; 但是如果连接失败会发生什么呢？ connect()方法接受一个可选的参数(error_callback)，当客户端不能连接上服务端时，这个回调函数error_callback会被调用，该函数的参数为对应的错误对象。 1234var error_callback = function(error) &#123; // display the error&#x27;s message header: alert(error.headers.message);&#125;; 在大多数情况下，connect()方法可接受不同数量的参数来提供简单的API： 123client.connect(login, passcode, connectCallback);client.connect(login, passcode, connectCallback, errorCallback);client.connect(login, passcode, connectCallback, errorCallback, host); login和passcode是strings，connectCallback和errorCallback则是functions。（有些brokers（代理）还需要传递一个host（String类型）参数。） 如果你需要附加一个headers头部，connect方法还接受其他两种形式的参数： 12client.connect(headers, connectCallback);client.connect(headers, connectCallback, errorCallback); header是map形式，connectCallback和errorCallback为functions。 需要注意：如果你使用上述这种方式，你需要自行在headers添加login、passcode（甚至host）： 1234567var headers = &#123; login: &#x27;mylogin&#x27;, passcode: &#x27;mypasscode&#x27;, // additional header &#x27;client-id&#x27;: &#x27;my-client-id&#x27;&#125;;client.connect(headers, connectCallback); 断开连接时，调用disconnect方法，这个方法也是异步的，当断开成功后会接收一个额外的回调函数的参数。如下所示。 123client.disconnect(function() &#123; alert(&quot;See you next time!&quot;);&#125;; 当客户端与服务端断开连接，就不会再发送或接收消息了。 Heart-beating(心跳) 如果STOMP broker(代理)接收STOMP 1.1版本的帧，heart-beating是默认启用的。 heart-beating也就是频率，incoming是接收频率，outgoing是发送频率。通过改变incoming和outgoing可以更改客户端的heart-beating(默认为10000ms)： 12345client.heartbeat.outgoing = 20000; // client will send heartbeats every 20000msclient.heartbeat.incoming = 0;// client does not want to receive heartbeats// from the server heart-beating是利用window.setInterval()去规律地发送heart-beats或者检查服务端的heart-beats。 发送消息 当客户端与服务端连接成功后，可以调用send()来发送STOMP消息。这个方法必须有一个参数，用来描述对应的STOMP的目的地。另外可以有两个可选的参数：headers，object类型包含额外的信息头部；body，一个String类型的参数。 12client.send(&quot;/queue/test&quot;, &#123;priority: 9&#125;, &quot;Hello, STOMP&quot;);// client会发送一个STOMP发送帧给/queue/test，这个帧包含一个设置了priority为9的header和内容为“Hello, STOMP”的body。 如果你想发送一个有body的信息，也必须传递headers参数。如果没有headers需要传递，那么就传&#123;&#125;即可。 1client.send(destination, &#123;&#125;, body); 订阅（Subscribe）和接收（receive）消息 为了在浏览器中接收消息，STOMP客户端必须先订阅一个目的地destination。 你可以使用subscribe()去订阅。这个方法有2个必需的参数：目的地(destination)，回调函数(callback)；还有一个可选的参数headers。其中destination是String类型，对应目的地，回调函数是伴随着一个参数的function类型。 1var subscription = client.subscribe(&quot;/queue/test&quot;, callback); subscribe()方法返回一个object，这个object包含一个id属性，对应这个这个客户端的订阅ID。 而unsubscribe()可以用来取消客户端对这个目的地destination的订阅。 默认情况下，如果没有在headers额外添加，这个库会默认构建一个独一无二的ID。在传递headers这个参数时，可以使用你自己的ID。 12var mysubid = &#x27;...&#x27;;var subscription = client.subscribe(destination, callback, &#123; id: mysubid &#125;); 这个客户端会向服务端发送一个STOMP订阅帧（SUBSCRIBE frame）并注册回调事件。每次服务端向客户端发送消息时，客户端都会轮流调用回调函数，参数为对应消息的STOMP帧对象（Frame object）。 subscribe()方法，接受一个可选的headers参数用来标识附加的头部。 12var headers = &#123;ack: &#x27;client&#x27;, &#x27;selector&#x27;: &quot;location = &#x27;Europe&#x27;&quot;&#125;;client.subscribe(&quot;/queue/test&quot;, message_callback, headers); 这个客户端指定了它会确认接收的信息，只接收符合这个selector : location = &#39;Europe&#39;的消息。 如果想让客户端订阅多个目的地，你可以在接收所有信息的时候调用相同的回调函数： 12345onmessage = function(message) &#123; // called every time the client receives a message&#125;var sub1 = client.subscribe(&quot;queue/test&quot;, onmessage);var sub2 = client.subscribe(&quot;queue/another&quot;, onmessage) 如果要中止接收消息，客户端可以在subscribe()返回的object对象调用unsubscribe()来结束接收。 123var subscription = client.subscribe(...);...subscription.unsubscribe(); 支持JSON STOMP消息的body必须为字符串。如果你需要发送/接收JSON对象，你可以使用JSON.stringify()和JSON.parse()去转换JSON对象。 确认(Acknowledgment) 默认情况，在消息发送给客户端之前，服务端会自动确认（acknowledged）。 客户端可以选择通过订阅一个目的地时设置一个ack header为client或client-individual来处理消息确认。 在下面这个例子，客户端必须调用message.ack()来通知服务端它已经接收了消息。 123456789var subscription = client.subscribe(&quot;/queue/test&quot;, function(message) &#123; // do something with the message ... // and acknowledge it message.ack(); &#125;, &#123;ack: &#x27;client&#x27;&#125;); ack()接受headers参数用来附加确认消息。例如，将消息作为事务(transaction)的一部分，当要求接收消息时其实代理（broker）已经将ACK STOMP frame处理了。 123var tx = client.begin();message.ack(&#123; transaction: tx.id, receipt: &#x27;my-receipt&#x27; &#125;);tx.commit(); 事务(Transactions) 可以在将消息的发送和确认接收放在一个事务中。 客户端调用自身的begin()方法就可以开始启动事务了，begin()有一个可选的参数transaction，一个唯一的可标识事务的字符串。如果没有传递这个参数，那么库会自动构建一个。这个方法会返回一个object。这个对象有一个id属性对应这个事务的ID，还有两个方法： commit()提交事务 abort()中止事务 在一个事务中，客户端可以在发送/接受消息时指定transaction id来设置transaction。 123456// start the transactionvar tx = client.begin();// send the message in a transactionclient.send(&quot;/queue/test&quot;, &#123;transaction: tx.id&#125;, &quot;message in a transaction&quot;);// commit the transaction to effectively send the messagetx.commit(); 如果你在调用send()方法发送消息的时候忘记添加transction header，那么这不会称为事务的一部分，这个消息会直接发送，不会等到事务完成后才发送。 123456var txid = &quot;unique_transaction_identifier&quot;;// start the transactionvar tx = client.begin();// oops! send the message outside the transactionclient.send(&quot;/queue/test&quot;, &#123;&#125;, &quot;I thought I was in a transaction!&quot;);tx.abort(); // Too late! the message has been sent 调试 有一些测试代码能有助于你知道库发送或接收的是什么，从而来调试程序。 客户端可以将其debug属性设置为一个函数，传递一个字符串参数去观察库所有的debug语句。默认情况，debug消息会被记录在在浏览器的控制台。 1234client.debug = function(str) &#123; // append the debug log to a #debug div somewhere in the page using JQuery: $(&quot;#debug&quot;).append(str + &quot;\\n&quot;);&#125;; 使用情况123var error_callback = function(error) &#123; 第一次连接失败和连接后断开连接都会调用这个函数&#125;; 关闭控制台调试数据：设置client.debug = null 就可以，stompjs会去检测debug是否是函数，不是函数就不会调用输出 个人实例跨域问题（之后专门写一个跨域）首先我没有后端，用的github现成的Java项目，所以需要做跨域请求，在Java中进行了跨域 12345678910/** * 注册STOMP的节点，并映射指定的url * * @param registry */@Overridepublic void registerStompEndpoints(StompEndpointRegistry registry) &#123; // 注册STOMP的endpoint，并指定使用SockJS协议 registry.addEndpoint(StompConstant.STOMP_ENDPOINT).setAllowedOrigins(&quot;*&quot;).withSockJS();&#125; 添加了.setAllowedOrigins(&quot;*&quot;)对所有端口开放 vue项目中做了 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; //配置跨域 &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8080&#x27;,// 实际访问地址和端口号 ws: true, changOrigin: true, //允许跨域 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27;// 使用/api代替Target &#125; &#125;, &#125; &#125;,&#125; 用/api替代实际访问地址 连接服务器并配置心跳1234567891011connect () &#123; var socket = new SockJS(&#x27;/api/xechat&#x27;); this.stompClient = Stomp.over(socket); // 配置stomp // 心跳 this.stompClient.heartbeat.outgoing = 30000; // 客户端不接受服务器心跳检测 this.stompClient.heartbeat.incoming = 0; // 订阅地址 this.sub();&#125;, CONNECT发送连接服务器请求，CONNECTED服务器返回连接情况 订阅服务器地址订阅了四个地址，并在连接成功后返回信息，进行广播 1234567891011121314151617181920212223242526272829303132333435sub () &#123; var _this = this; var user = this.createUser(); this.stompClient.connect(user, function connectCallback (frame) &#123; _this.uid = frame.headers[&#x27;user-name&#x27;]; console.log(&#x27;连接成功&#x27;) // 聊天室订阅 _this.stompClient.subscribe(&#x27;/topic/chatRoom&#x27;, function (data) &#123; console.log(&#x27;订阅成功&#x27;) _this.handleMessage(_this.getData(data.body)); &#125;); // 本地订阅 _this.stompClient.subscribe(&#x27;/user/&#x27; + _this.uid + &#x27;/chat&#x27;, function (data) &#123; _this.handleMessage(_this.getData(data.body)); &#125;); // 错误信息订阅 _this.stompClient.subscribe(&#x27;/user/&#x27; + _this.uid + &#x27;/error&#x27;, function (data) &#123; _this.getData(data.body); &#125;); // 聊天室动态订阅 _this.stompClient.subscribe(&#x27;/topic/status&#x27;, function (data) &#123; var obj = _this.getData(data.body); console.log(&#x27;看这里&#x27;) console.log(obj) _this.handleMessage(obj); _this.showOnlineNum(obj.onlineCount); &#125;); &#125;, function errorCallBack (error) &#123; alert(&#x27;请重新连接！&#x27;); _this.refresh(); &#125;);&#125;, 成功订阅并接受到广播信息 SUBSCRIBE订阅地址 实现进入效果 发送消息1234567891011121314sendMessage (pub, header, data) &#123; this.stompClient.send(pub, header, data);&#125;,//发送信息到聊天室sendToChatRoom () &#123; // 获取发送的内容 var content = document.getElementById(&#x27;sendTxt&#x27;).value; var data = &#123; &quot;message&quot;: content &#125;; var pub = &#x27;/chatRoom&#x27;; data = JSON.stringify(data); this.sendMessage(pub, &#123;&#125;, data);&#125;, SEND发送 MESSAGE接收到广播信息 实现效果 等待补充1.断开自动刷新连接服务器 2.中断订阅地址 3.对事务的理解 相关链接Stomp官方文档 StompJS使用文档总结 stomp over websocket协议原理与实现","categories":[],"tags":[{"name":"html&浏览器","slug":"html-浏览器","permalink":"https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"协议","slug":"协议","permalink":"https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"WebSocket","slug":"Web-Socket","date":"2021-07-02T04:11:54.000Z","updated":"2021-07-17T04:18:57.501Z","comments":true,"path":"2021/07/02/Web-Socket/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/02/Web-Socket/","excerpt":"","text":"WebSocket 教程 WebSocket 是一种网络通信协议，很多高级功能都需要它。 本文介绍 WebSocket 协议的使用方法。 为什么需要 WebSocket？初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 客户端的简单示例WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 123456789101112131415var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) &#123; console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;);&#125;;ws.onmessage = function(evt) &#123; console.log( &quot;Received Message: &quot; + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log(&quot;Connection closed.&quot;);&#125;; 客户端的 APIWebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket(&#x27;ws://localhost:8080&#x27;); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 webSocket.readyStatereadyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; webSocket.onopen实例对象的onopen属性，用于指定连接成功后的回调函数。 123ws.onopen = function () &#123; ws.send(&#x27;Hello Server!&#x27;);&#125; 如果要指定多个回调函数，可以使用addEventListener方法。 123ws.addEventListener(&#x27;open&#x27;, function (event) &#123; ws.send(&#x27;Hello Server!&#x27;);&#125;); webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。 12345678910111213ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener(&quot;close&quot;, function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); webSocket.onmessage实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 123456789ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener(&quot;message&quot;, function(event) &#123; var data = event.data; // 处理数据&#125;); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。 12345678910ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log(&quot;Received data string&quot;); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log(&quot;Received arraybuffer&quot;); &#125;&#125; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 1234567891011// 收到的是 blob 数据ws.binaryType = &quot;blob&quot;;ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = &quot;arraybuffer&quot;;ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; webSocket.send()实例对象的send()方法用于向服务器发送数据。 发送文本的例子。 1ws.send(&#x27;your message&#x27;); 发送 Blob 对象的例子。 1234var file = document .querySelector(&#x27;input[type=&quot;file&quot;]&#x27;) .files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 1234567// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); webSocket.bufferedAmount实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 12345678var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; webSocket.onerror实例对象的onerror属性，用于指定报错时的回调函数。 1234567socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener(&quot;error&quot;, function(event) &#123; // handle error event&#125;); 服务端的实现WebSocket 服务器的实现，可以查看维基百科的列表。 常用的 Node 实现有以下三种。 µWebSockets Socket.IO WebSocket-Node 具体的用法请查看它们的文档，这里不详细介绍了。 WebSocketd下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。 它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。 举例来说，下面是一个 Bash 脚本counter.sh。 123456789#!/bin/bashecho 1sleep 1echo 2sleep 1echo 3 命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。 1$ bash ./counter.sh 现在，启动websocketd，指定这个脚本作为服务。 1$ websocketd --port=8080 bash ./counter.sh 上面的命令会启动一个 WebSocket 服务器，端口是8080。每当客户端连接这个服务器，就会执行counter.sh脚本，并将它的输出推送给客户端。 12345var ws = new WebSocket(&#x27;ws://localhost:8080/&#x27;);ws.onmessage = function(event) &#123; console.log(event.data);&#125;; 上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。 有了它，就可以很方便地将命令行的输出，发给浏览器。 1$ websocketd --port=8080 ls 上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。 更多的用法可以参考官方示例。 Bash 脚本读取客户端输入的例子 五行代码实现一个最简单的聊天服务器 websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务greeter.js。 12345678process.stdin.setEncoding(&#x27;utf8&#x27;);process.stdin.on(&#x27;readable&#x27;, function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write(&#x27;data: &#x27; + chunk); &#125;&#125;); 启动这个脚本的命令如下。 1$ websocketd --port=8080 node ./greeter.js 官方仓库还有其他各种语言的例子。 参考链接 How to Use WebSockets WebSockets - Send &amp; Receive Messages Introducing WebSockets: Bringing Sockets to the Web 本文来自阮一峰的 WebSocker仅作为学习使用","categories":[],"tags":[{"name":"html&浏览器","slug":"html-浏览器","permalink":"https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"协议","slug":"协议","permalink":"https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"mini-vue","slug":"mini-vue","date":"2021-06-27T09:14:43.000Z","updated":"2021-09-04T05:33:38.088Z","comments":true,"path":"2021/06/27/mini-vue/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/mini-vue/","excerpt":"","text":"mini-vue 实现一个 mini-vue 之 vdomB 站传送门 (opens new window)vue 总共包含三大部分: 模板编译 虚拟 dom 响应式 api 这篇文章主要很简单的实现一下虚拟 dom 部分 #h 函数h 函数很简单,就是返回一个 js 对象. 1234567function h(tag, props, children) &#123; return &#123; tag, props, children, &#125;;&#125; mountmount 函数接受两个参数,第一个是虚拟节点也就是 h 函数生成的 vnode,第二个是要挂载到的真实 dom 节点. mount 的主要作用是将虚拟节点挂载到真实 dom 节点上,也不是很复杂. 123456789101112131415161718192021222324252627282930313233function mount(vnode, container) &#123; const &#123; tag, props, children &#125; = vnode; //这里要将生成的真实dom节点保存到vnode上 const el = (vnode.el = document.createElement(tag)); //添加dom属性 if (props) &#123; for (let key in props) &#123; const value = props[key]; if (key.startsWith(&quot;on&quot;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), value); &#125; else &#123; el.setAttribute(key, value); &#125; &#125; &#125; //添加子节点 if (children) &#123; if (Array.isArray(children)) &#123; children.forEach((child) =&gt; &#123; if (typeof child === &quot;string&quot;) &#123; el.append(child); &#125; else if (typeof child === &quot;object&quot;) &#123; //child是一个对象时,说明child是一个元素节点 //这时就要递归调用mount mount(child, el); &#125; &#125;); &#125; else &#123; el.append(children); &#125; &#125; container.append(el);&#125; patch虚拟 dom 部分里最复杂的就是 patch 函数,这个函数的作用是,比对两个虚拟节点, 进行 diff 算法,从而实现最小量更新,也就是尽可能的减少对真实 dom 的操作,因为操作真实 dom 的性能开销远大于操作 js 对象,这也是 vue 使用虚拟 dom 的原因之一. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function patch(n1, n2) &#123; if (n1.tag === n2.tag) &#123; //这个分支为新旧节点tag类型相同 //这里需要将真实dom节点el,在每次patch时向后传递,保证每次更新的都是 //这个节点. const el = (n2.el = n1.el); //diff props const oldProps = n1.props || &#123;&#125;; const newProps = n2.props || &#123;&#125;; //添加新的属性或更改原来已有但变化了的属性 for (let key in newProps) &#123; const oldValue = oldProps[key]; const newValue = newProps[key]; if (newValue !== oldValue) &#123; el.setAttribute(key, newValue); &#125; &#125; //移除新属性中没有的属性 for (let key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key); &#125; &#125; //diff children const oldChildren = n1.children; const newChildren = n2.children; //在diff children的时候,有四个主要分支 // 1.新老都是string // 2.新: array 老: string // 3.新: string 老: array // 4.新老都是array if (typeof newChildren === &quot;string&quot;) &#123; if (typeof oldChildren === &quot;string&quot;) &#123; //情况1 if (oldChildren !== newChildren) &#123; el.innerHTML = newChildren; &#125; &#125; else &#123; //情况3 el.innerHTML = newChildren; &#125; &#125; else if (typeof oldChildren === &quot;string&quot; &amp;&amp; Array.isArray(newChildren)) &#123; //情况2 el.innerHTML = &quot;&quot;; newChildren.forEach((child) =&gt; mount(child, el)); &#125; else if (Array.isArray(oldChildren) &amp;&amp; Array.isArray(newChildren)) &#123; //情况4 是最复杂的情况 //这里简单起见并没有真正实现vue中的diff算法,而是选取了一个低效但 //容易理解的算法,但其实vue中如果不给元素提供key的话,也会使用这个 //算法,这个算法在子元素的tag不会变的情况下非常高效,但如果tag会变 //则会因为不必要的创造和删除节点,而变得不那么高效. const minLength = Math.min(oldChildren.length, newChildren.length); for (let i = 0; i &lt; minLength; i++) &#123; patch(oldChildren[i], newChildren[i]); &#125; //老的children长度较小,则说明要添加节点 if (oldChildren.length === minLength) &#123; for (let i = minLength; i &lt; newChildren.length; i++) &#123; mount(newChildren[i], el); &#125; &#125; else &#123; //反之,则说明要删除节点 for (let i = minLength; i &lt; oldChildren.length; i++) &#123; el.removeChild(oldChildren[i].el); &#125; &#125; &#125; &#125; else &#123; //标签类型不同时需要用新节点替换节点 //这里并没有实现😂 //回头再补 &#125;&#125; 实现一个 mini-vue 之 reactive简单的实现一下 vue3 的响应式原理核心 Dep 类要理解 vue 响应式原理,首先要明白 Dep 类是干什么的. Dep 故名思意,就是依赖的意思. 为什么叫依赖,因为视图的变化,实际上是数据的变化所导致的. 所以现在数据就是视图的依赖. 现在我们假设视图的变化是由一个神奇的函数 render 的调用的结果也就是 view = render(data). 现在我们在 data 变化时想改变视图,就要手动调用这个函数,而响应式就是要避免这个操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243//Dep类的实例就是依赖class Dep &#123; constructor(value) &#123; //在构造函数里传入了value,这时dep同时也是数据的载体 this._value = value; //这里dep保存着它的订阅者,注意是set,意味着不能重复 this.subs = new Set(); &#125; //通过js特性对象数据访问器getter和setter, //进行订阅者的注册和依赖改变后副作用的执行,也就是发布 get value() &#123; //get时注册订阅者 this.depend(); return this._value; &#125; set value(newValue) &#123; this._value = newValue; //set后通知订阅者,执行副作用 this.notify(); &#125; depend() &#123; //这里的activeEffect为全局变量,指向当前要被注册的订阅者 if (activeEffect) &#123; this.subs.add(activeEffect); &#125; &#125; notify() &#123; //执行所有副作用,也就是订阅者 this.subs.forEach((sub) =&gt; sub()); &#125;&#125;let activeEffect = null;function watchEffect(effect) &#123; //这步赋值置空的操作,保证了只能在watchEffect中进行订阅者的注册 activeEffect = effect; effect(); activeEffect = null;&#125; Copied! 测试 12345678910const count = new Dep(1);watchEffect(() =&gt; &#123; console.log(count.value);&#125;);count.value++; // log 2count.value++; // log 3count.value++; // log 4count.value = 15; // log 15 reactive在 Dep 类中了解了 vue 中基本的响应式原理后,对 reactive-api 就好理解了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Dep类和当前要注册的订阅者//和上面的区别是,这里Dep不再是数据的载体//而只负责整个发布订阅过程let activeEffect = null;class Dep &#123; subs = new Set(); depend() &#123; if (activeEffect) &#123; this.subs.add(activeEffect); &#125; &#125; notify() &#123; this.subs.forEach((sub) =&gt; sub()); &#125;&#125;function watchEffect(effect) &#123; activeEffect = effect; effect(); activeEffect = null;&#125;//我们从上到下看//reactive接收一个原始的对象//返回一个原始对象的代理// Proxy(target, handler)function reactive(raw) &#123; return new Proxy(raw, reactiveHandlers);&#125;const reactiveHandlers = &#123; get(target, key, receiver) &#123; //依旧是get时进行订阅者的注册 //问题是我的dep从哪获取,这里暂时认为getDep帮我拿到了 //这个target和这个key对应的dep //这里为了简单起见,没有处理深层嵌套对象的响应式转换 const dep = getDep(target, key); dep.depend(); return Reflect.get(target, key, receiver); &#125;, set(target, key, value, receiver) &#123; //set时触发所有副作用 //同样需要获得对应的dep const dep = getDep(target, key); const ret = Reflect.set(target, key, value, receiver); dep.notify(); return ret; &#125;,&#125;;//最后我们看是如何获取对应的dep的/* 我们先搞明白一个对应关系 target是个对象,对应着一组key, value, dep的depend和notify操作,就是在对target[key], get和set时进行的,dep储存着所有订阅者,所以一个key 对应着一个dep,这个数据结构可以使用Map储存这一组key,value. 而前面我们知道,一个target对应着一组key,value,所以这个 数据结构也是一个Map(这里考虑到垃圾回收使用了WeakMap).*/const targetMap = new WeakMap();function getDep(target, key) &#123; if (!targetMap.has(target)) &#123; targetMap.set(target, new Map()); &#125; const depMap = targetMap.get(target); if (!depMap.has(key)) &#123; depMap.set(key, new Dep()); &#125; return depMap.get(key);&#125; 实现一个 mini-vue我们来执行最后一步,将前面的函数进行组合,得到最终可以运行的 mini-vue. 先将之前所有的代码复制过来. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//vdom部分function h(tag, props, children) &#123; return &#123; tag, props, children, &#125;;&#125;function mount(vnode, container) &#123; const &#123; tag, props, children &#125; = vnode; const el = (vnode.el = document.createElement(tag)); if (props) &#123; for (let key in props) &#123; const value = props[key]; if (key.startsWith(&quot;on&quot;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), value); &#125; else &#123; el.setAttribute(key, value); &#125; &#125; &#125; if (children) &#123; if (Array.isArray(children)) &#123; children.forEach((child) =&gt; &#123; if (typeof child === &quot;string&quot;) &#123; el.append(child); &#125; else if (typeof child === &quot;object&quot;) &#123; mount(child, el); &#125; &#125;); &#125; else &#123; el.append(children); &#125; &#125; container.append(el);&#125;function patch(n1, n2) &#123; if (n1.tag === n2.tag) &#123; const el = (n2.el = n1.el); //diff props const oldProps = n1.props || &#123;&#125;; const newProps = n2.props || &#123;&#125;; //添加新的属性或更改原来已有但变化了的属性 for (let key in newProps) &#123; const oldValue = oldProps[key]; const newValue = newProps[key]; if (newValue !== oldValue) &#123; el.setAttribute(key, newValue); &#125; &#125; //移除新属性中没有的属性 for (let key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key); &#125; &#125; //diff children const oldChildren = n1.children; const newChildren = n2.children; if (typeof newChildren === &quot;string&quot;) &#123; if (typeof oldChildren === &quot;string&quot;) &#123; if (oldChildren !== newChildren) &#123; el.innerHTML = newChildren; &#125; &#125; &#125; else if (typeof oldChildren === &quot;string&quot; &amp;&amp; Array.isArray(newChildren)) &#123; el.innerHTML = &quot;&quot;; newChildren.forEach((child) =&gt; mount(child, el)); &#125; else if (Array.isArray(oldChildren) &amp;&amp; Array.isArray(newChildren)) &#123; const minLength = Math.min(oldChildren.length, newChildren.length); for (let i = 0; i &lt; minLength; i++) &#123; patch(oldChildren[i], newChildren[i]); &#125; if (oldChildren.length === minLength) &#123; for (let i = minLength; i &lt; newChildren.length; i++) &#123; mount(newChildren[i], el); &#125; &#125; else &#123; for (let i = minLength; i &lt; oldChildren.length; i++) &#123; el.removeChild(oldChildren[i].el); &#125; &#125; &#125; &#125; else &#123; //replace &#125;&#125;//reactivity部分let activeEffect = null;class Dep &#123; subs = new Set(); depend() &#123; if (activeEffect) &#123; this.subs.add(activeEffect); &#125; &#125; notify() &#123; this.subs.forEach((sub) =&gt; sub()); &#125;&#125;function watchEffect(effect) &#123; activeEffect = effect; effect(); activeEffect = null;&#125;const targetMap = new WeakMap();function getDep(target, key) &#123; if (!targetMap.has(target)) &#123; targetMap.set(target, new Map()); &#125; const depMap = targetMap.get(target); if (!depMap.has(key)) &#123; depMap.set(key, new Dep()); &#125; return depMap.get(key);&#125;const reactiveHandlers = &#123; get(target, key, receiver) &#123; // dep const dep = getDep(target, key); dep.depend(); return Reflect.get(target, key, receiver); &#125;, set(target, key, value, receiver) &#123; const dep = getDep(target, key); const ret = Reflect.set(target, key, value, receiver); dep.notify(); return ret; &#125;,&#125;;function reactive(raw) &#123; return new Proxy(raw, reactiveHandlers);&#125; mountApp12345678910111213141516171819//component组件实例//container要挂载的dom元素function mountApp(component, container) &#123; let isMounted = false; let oldVdom; watchEffect(() =&gt; &#123; if (!isMounted) &#123; //第一次挂载 oldVdom = component.render(); mount(oldVdom, container); isMounted = true; &#125; else &#123; //数据变化,要进行更新 const newVdom = component.render(); patch(oldVdom, newVdom); oldVdom = newVdom; &#125; &#125;);&#125; 测试12345678910111213141516171819const App = &#123; data: reactive(&#123; count: 0, &#125;), render() &#123; return h(&quot;div&quot;, null, [ h( &quot;div&quot;, &#123; onClick: () =&gt; App.data.count++, &#125;, String(this.data.count) ), ]); &#125;,&#125;;//一个点击自增的计数器mountApp(App, document.getElementById(&quot;app&quot;));","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"Vue的diff算法","slug":"Vue的diff算法","date":"2021-06-27T08:49:57.000Z","updated":"2021-06-27T09:17:16.707Z","comments":true,"path":"2021/06/27/Vue的diff算法/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"Vue如何操作节点及diff算法 前言当数据发生变化时，vue是怎么更新节点的？要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。 我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。 diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。 virtual DOM和真实DOM的区别？virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的： 123&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 对应的virtual DOM（伪代码）： 123456var Vnode = &#123; tag: &#x27;div&#x27;, children: [ &#123; tag: &#x27;p&#x27;, text: &#x27;123&#x27; &#125; ]&#125;; （温馨提示：VNode和oldVNode都是对象，一定要记住） diff的比较方式？1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;456&lt;/span&gt;&lt;/div&gt; 上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图： diff流程图当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。 具体分析patch来看看patch是怎么打补丁的（代码只保留核心部分） 1234567891011121314151617function patch (oldVnode, vnode) &#123; // some code if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode) &#125; else &#123; const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) // 父元素 createEle(vnode) // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null &#125; &#125; // some code return vnode&#125; patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode 12345678910function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 )&#125; 不值得比较则用Vnode替换oldVnode 如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。 patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？ 1234567891011121314151617patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el&#x27;s children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125; 这个函数做了以下事情： 找到对应的真实dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 其他几个点都很好理解，我们详细来讲一下updateChildren updateChildren代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125;else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125;else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125;else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125;else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 图解updateChildren终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。 粉红色的部分为oldCh和vCh 我们将它们取出来并分别用s和e指针指向它们的头child和尾child 现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方 如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后 如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动 如果四种匹配没有一对是成功的，那么遍历oldChild，S挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将S对应的节点插入到dom中对应的oldS位置，oldS和S指针向中间移动。 再配个图 第一步 12oldS = a, oldE = d；S = a, E = b; oldS和S匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d 第二步 12oldS = b, oldE = d；S = c, E = b; oldS和E匹配，就将原本的b节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，此时dom的位置为：a d b 第三步 12oldS = d, oldE = d；S = c, E = d; oldE和E匹配，位置不变此时dom的位置为：a d b 第四步 123oldS++;oldE--;oldS &gt; oldE; 遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b 一次模拟完成。 这个匹配过程的结束有两个条件： oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据index添加到dom中去（如上图） S &gt; E表示vCh先遍历完，那么就在真实dom中将区间为[oldS, oldE]的多余节点删掉(本图第二第三步画错了应该对换位置) 下面再举一个例子，可以像上面那样自己试着模拟一下 当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码 123if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode)&#125; 就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。也将dom的所有补丁都打好啦。那么现在再回过去看updateChildren的代码会不会容易很多呢？ 总结以上为diff算法的全部过程，放上一张文章开始就发过的总结图，可以试试看着这张图回忆一下diff的过程。 参考资料本文摘抄自详解vue的diff算法 尤大的mini-vue","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"SPA单页面应用和多页应用优缺点","slug":"SPA单页面应用","date":"2021-06-27T08:42:42.000Z","updated":"2021-06-27T08:55:06.006Z","comments":true,"path":"2021/06/27/SPA单页面应用/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/","excerpt":"","text":"SPA单页应用 其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。 优 点: 减轻服务端的压力，可维护性高 缺点: 首次加载速度慢，搜索引擎优化效果不好 为什么首屏时间慢，SEO 差？单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。 SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。 多页应用多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"Promise","slug":"Promise","date":"2021-06-27T06:39:46.000Z","updated":"2021-06-27T08:54:58.524Z","comments":true,"path":"2021/06/27/Promise/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/Promise/","excerpt":"","text":"彻底弄懂 Promise 原理 Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。 基本过程： 初始化 Promise 状态（pending） 立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理 执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次） Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。 真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise. 链式调用先从 Promise 执行结果看一下，有如下一段代码： 123456789101112131415new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) resolve(&#123; test: 2 &#125;) reject(&#123; test: 2 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data)&#125;,(data1)=&gt;&#123; console.log(&#x27;result2&#x27;,data1)&#125;).then((data) =&gt; &#123; console.log(&#x27;result3&#x27;, data)&#125;)//result1 &#123; test: 1 &#125;//result3 undefined 显然这里输出了不同的 data。由此可以看出几点： 可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。 只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。 then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。 基于以上几点，我们先写个基于 PromiseA+ 规范的只含 resolve 方法的 Promise 模型: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Promise(fn)&#123; let state = &#x27;pending&#x27;; let value = null; const callbacks = []; this.then = function (onFulfilled)&#123; return new Promise((resolve, reject)=&gt;&#123; handle(&#123; //桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中 onFulfilled, resolve &#125;) &#125;) &#125; function handle(callback)&#123; if(state === &#x27;pending&#x27;)&#123; callbacks.push(callback) return; &#125; if(state === &#x27;fulfilled&#x27;)&#123; if(!callback.onFulfilled)&#123; callback.resolve(value) return; &#125; const ret = callback.onFulfilled(value) //处理回调 callback.resolve(ret) //处理下一个 promise 的resolve &#125; &#125; function resolve(newValue)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return state = &#x27;fulfilled&#x27;; value = newValue handelCb() &#125; setTimeout(fn,0) //基于 PromiseA+ 规范 &#125; function handelCb()&#123; while(callbacks.length) &#123; const fulfiledFn = callbacks.shift(); handle(fulfiledFn); &#125;; &#125; fn(resolve)&#125; 这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。 但是如果仅仅是例子中的情况，我们可以这样写： 1234567891011new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething console.log(&#x27;result3&#x27;)&#125;)//result1 &#123; test: 1 &#125;//result3 实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子： 12345678910111213141516171819202122new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething return test()&#125;).then((data) =&gt; &#123; console.log(&#x27;result2&#x27;, data)&#125;)function test(id) &#123; return new Promise(((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 2 &#125;) &#125;, 5000) &#125;))&#125;//基于第一个 Promise 模型，执行后的输出//result1 &#123; test: 1 &#125;//result2 Promise &#123;then: ƒ&#125; 用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下: 123456789101112131415161718192021222324function Promise(fn)&#123; ... function resolve(newValue)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return if(newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;))&#123; const &#123;then&#125; = newValue if(typeof then === &#x27;function&#x27;)&#123; // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve //相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调 then.call(newValue,resolve) return &#125; &#125; state = &#x27;fulfilled&#x27;; value = newValue handelCb() &#125; setTimeout(fn,0) &#125; ...&#125; 用这个模型，再测试我们的例子，就得到了正确的结果： 123456789101112131415161718192021new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething return test()&#125;).then((data) =&gt; &#123; console.log(&#x27;result2&#x27;, data)&#125;)function test(id) &#123; return new Promise(((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 2 &#125;) &#125;, 5000) &#125;))&#125;//result1 &#123; test: 1 &#125;//result2 &#123; test: 2 &#125; 显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。 显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。 我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。 基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表： Promise callback P1 [{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}] P2 (P1 调用 then 时产生) [{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}] P3 (P2 调用 then 时产生) [] P4 (执行c1中产生[调用 test ]) [{onFulfilled:p2resolve,resolve:p5resolve}] P5 (调用p2resolve 时，进入 then.call 逻辑中产生) [] 有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是： c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; [] 以上就是链式调用的原理了。 reject下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。 完整代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function Promise(fn)&#123; let state = &#x27;pending&#x27;; let value = null; const callbacks = []; this.then = function (onFulfilled,onRejected)&#123; return new Promise((resolve, reject)=&gt;&#123; handle(&#123; onFulfilled, onRejected, resolve, reject &#125;) &#125;) &#125; function handle(callback)&#123; if(state === &#x27;pending&#x27;)&#123; callbacks.push(callback) return; &#125; const cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled:callback.onRejected; const next = state === &#x27;fulfilled&#x27;? callback.resolve:callback.reject; if(!cb)&#123; next(value) return; &#125; const ret = cb(value) next(ret) &#125; function resolve(newValue)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return if(newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;))&#123; const &#123;then&#125; = newValue if(typeof then === &#x27;function&#x27;)&#123; // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve //相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调 then.call(newValue,resolve, reject) return &#125; &#125; state = &#x27;fulfilled&#x27;; value = newValue handelCb() &#125; setTimeout(fn,0) &#125; function reject(error)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return if(error &amp;&amp; (typeof error === &#x27;object&#x27; || typeof error === &#x27;function&#x27;))&#123; const &#123;then&#125; = error if(typeof then === &#x27;function&#x27;)&#123; then.call(error,resolve, reject) return &#125; &#125; state = &#x27;rejected&#x27;; value = error handelCb() &#125; setTimeout(fn,0) &#125; function handelCb()&#123; while(callbacks.length) &#123; const fn = callbacks.shift(); handle(fn); &#125;; &#125; fn(resolve, reject)&#125; 异常处理异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。 handle代码改造如下： 1234567891011121314151617181920function handle(callback)&#123; if(state === &#x27;pending&#x27;)&#123; callbacks.push(callback) return; &#125; const cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled:callback.onRejected; const next = state === &#x27;fulfilled&#x27;? callback.resolve:callback.reject; if(!cb)&#123; next(value) return; &#125; try &#123; const ret = cb(value) next(ret) &#125; catch (e) &#123; callback.reject(e); &#125; &#125; 我们实际使用时，常习惯注册 catch 方法来处理错误，例： 1234567891011new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething return test()&#125;).catch((ex) =&gt; &#123; console.log(&#x27;error&#x27;, ex)&#125;) 实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法： 1234567891011121314151617function Promise(fn)&#123; ... this.then = function (onFulfilled,onRejected)&#123; return new Promise((resolve, reject)=&gt;&#123; handle(&#123; onFulfilled, onRejected, resolve, reject &#125;) &#125;) &#125; this.catch = function (onError)&#123; this.then(null,onError) &#125; ...&#125; Finally方法在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑： 12345678910function Promise(fn)&#123; ... this.catch = function (onError)&#123; this.then(null,onError) &#125; this.finally = function (onDone)&#123; this.then(onDone,onDone) &#125; ...&#125; resolve 方法和 reject 方法实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子： 12345Promise.resolve(&#123;name:&#x27;winty&#x27;&#125;)Promise.reject(&#123;name:&#x27;winty&#x27;&#125;)// 等价于new Promise(resolve =&gt; resolve(&#123;name:&#x27;winty&#x27;&#125;))new Promise((resolve,reject) =&gt; reject(&#123;name:&#x27;winty&#x27;&#125;)) 这些情况下，Promise.resolve 的入参可能有以下几种情况： 无参数 [直接返回一个resolved状态的 Promise 对象] 普通数据对象 [直接返回一个resolved状态的 Promise 对象] 一个Promise实例 [直接返回当前实例] 一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。] 基于以上几点，我们可以实现一个 Promise.resolve 方法如下： 123456789101112131415161718function Promise(fn)&#123; ... this.resolve = function (value)&#123; if (value &amp;&amp; value instanceof Promise) &#123; return value; &#125; else if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;)&#123; let then = value.then; return new Promise(resolve =&gt; &#123; then(resolve); &#125;); &#125; else if (value) &#123; return new Promise(resolve =&gt; resolve(value)); &#125; else &#123; return new Promise(resolve =&gt; resolve()); &#125; &#125; ...&#125; Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下： 12345678910function Promise(fn)&#123; ... this.reject = function (value)&#123; return new Promise(function(resolve, reject) &#123; reject(value); &#125;); &#125; ...&#125; Promise.all入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。 1234567891011121314151617181920212223242526272829303132333435function Promise(fn)&#123; ... this.all = function (arr)&#123; var args = Array.prototype.slice.call(arr); return new Promise(function(resolve, reject) &#123; if(args.length === 0) return resolve([]); var remaining = args.length; function res(i, val) &#123; try &#123; if(val &amp;&amp; (typeof val === &#x27;object&#x27; || typeof val === &#x27;function&#x27;)) &#123; var then = val.then; if(typeof then === &#x27;function&#x27;) &#123; then.call(val, function(val) &#123; res(i, val); &#125;, reject); return; &#125; &#125; args[i] = val; if(--remaining === 0) &#123; resolve(args); &#125; &#125; catch(ex) &#123; reject(ex); &#125; &#125; for(var i = 0; i &lt; args.length; i++) &#123; res(i, args[i]); &#125; &#125;); &#125; ...&#125; Promise.race有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。 1234567891011function Promise(fn)&#123; ... this.race = function(values) &#123; return new Promise(function(resolve, reject) &#123; for(var i = 0, len = values.length; i &lt; len; i++) &#123; values[i].then(resolve, reject); &#125; &#125;); &#125; ...&#125; 总结Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。 补充说明虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。 参考资料 PromiseA+规范 Promise 实现原理精解 30分钟，让你彻底明白Promise原理 完整 Promise 模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153function Promise(fn) &#123; let state = &#x27;pending&#x27; let value = null const callbacks = [] this.then = function (onFulfilled, onRejected) &#123; return new Promise((resolve, reject) =&gt; &#123; handle(&#123; onFulfilled, onRejected, resolve, reject, &#125;) &#125;) &#125; this.catch = function (onError) &#123; return this.then(null, onError) &#125; this.finally = function (onDone) &#123; this.then(onDone, onError) &#125; this.resolve = function (value) &#123; if (value &amp;&amp; value instanceof Promise) &#123; return value &#125; if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;) &#123; const &#123; then &#125; = value return new Promise((resolve) =&gt; &#123; then(resolve) &#125;) &#125; if (value) &#123; return new Promise(resolve =&gt; resolve(value)) &#125; return new Promise(resolve =&gt; resolve()) &#125; this.reject = function (value) &#123; return new Promise(((resolve, reject) =&gt; &#123; reject(value) &#125;)) &#125; this.all = function (arr) &#123; const args = Array.prototype.slice.call(arr) return new Promise(((resolve, reject) =&gt; &#123; if (args.length === 0) return resolve([]) let remaining = args.length function res(i, val) &#123; try &#123; if (val &amp;&amp; (typeof val === &#x27;object&#x27; || typeof val === &#x27;function&#x27;)) &#123; const &#123; then &#125; = val if (typeof then === &#x27;function&#x27;) &#123; then.call(val, (val) =&gt; &#123; res(i, val) &#125;, reject) return &#125; &#125; args[i] = val if (--remaining === 0) &#123; resolve(args) &#125; &#125; catch (ex) &#123; reject(ex) &#125; &#125; for (let i = 0; i &lt; args.length; i++) &#123; res(i, args[i]) &#125; &#125;)) &#125; this.race = function (values) &#123; return new Promise(((resolve, reject) =&gt; &#123; for (let i = 0, len = values.length; i &lt; len; i++) &#123; values[i].then(resolve, reject) &#125; &#125;)) &#125; function handle(callback) &#123; if (state === &#x27;pending&#x27;) &#123; callbacks.push(callback) return &#125; const cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled : callback.onRejected const next = state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject if (!cb) &#123; next(value) return &#125; let ret; try &#123; ret = cb(value) &#125; catch (e) &#123; callback.reject(e) &#125; callback.resolve(ret); &#125; function resolve(newValue) &#123; const fn = () =&gt; &#123; if (state !== &#x27;pending&#x27;) return if (newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;)) &#123; const &#123; then &#125; = newValue if (typeof then === &#x27;function&#x27;) &#123; // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve // 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调 then.call(newValue, resolve, reject) return &#125; &#125; state = &#x27;fulfilled&#x27; value = newValue handelCb() &#125; setTimeout(fn, 0) &#125; function reject(error) &#123; const fn = () =&gt; &#123; if (state !== &#x27;pending&#x27;) return if (error &amp;&amp; (typeof error === &#x27;object&#x27; || typeof error === &#x27;function&#x27;)) &#123; const &#123; then &#125; = error if (typeof then === &#x27;function&#x27;) &#123; then.call(error, resolve, reject) return &#125; &#125; state = &#x27;rejected&#x27; value = error handelCb() &#125; setTimeout(fn, 0) &#125; function handelCb() &#123; while (callbacks.length) &#123; const fn = callbacks.shift() handle(fn) &#125; &#125; try &#123; fn(resolve, reject) &#125; catch(ex) &#123; reject(ex); &#125;&#125;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://andylinwenqin.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"}]},{"title":"JS的基础知识点","slug":"JS的基础知识点","date":"2021-06-26T12:39:17.000Z","updated":"2021-06-26T13:42:20.520Z","comments":true,"path":"2021/06/26/JS的基础知识点/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/JS%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"JS的数据类型JS一共有6种基本数据类型分别是undefined, null, boolean, number, string, symbol, 引用数据类型object, array, function symbol作用: 定义一个独一无二的值 基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问 引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用 string是个基本数据类型，为什么可以使用String的一些方法除去Object, Array等引用类型，JavaScript还提供了三种特殊的引用类型: String, Number和Boolean，方便我们操作对应的基本类型，所以在调用String方法时，并不是基本数据类型stirng执行了自身方法，而是后台为它创建了一个对应的基本包装类型String，它根据基本类型的值实例化了一个实例，让这个实例去调用指定的方法，最后销毁这个实例 var, let, const的区别var声明的变量没有块级作用域而let声明的变量拥有块级作用域，const声明的是常量，声明之后无法对其进行修改， const保证的实际上并不是变量的值不得改变，而是变量指向的那个内存地址不得改动，对于复合类型的数据如对象，数组，变量指向的内存地址保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的 在代码块内，使用let命令声明变量之前，该变量都是不可用的，在语法上称为暂时性死区 ==, ===, Object.is的区别==: 会进行强制的类型转换,在转换类型后，二者相等也会返回True,而===不会进行转换, Object.is也不会进行强制类型转换，但与===不同的是，+0===0, Object.is(+0, -0) false, Nan !== Nan, Object.is(Nan, Nan) false 如果Type(x)和Type(y)相同，返回x===y的结果如果Type(x)和Type(y)不同如果x是null，y是undefined，返回true如果x是undefined，y是null，返回true如果Type(x)是Number，Type(y)是String，返回 x==ToNumber(y) 的结果如果Type(x)是String，Type(y)是Number，返回 ToNumber(x)==y 的结果如果Type(x)是Boolean，返回 ToNumber(x)==y 的结果如果Type(y)是Boolean，返回 x==ToNumber(y) 的结果如果Type(x)是String或Number或Symbol中的一种并且Type(y)是Object，返回 x==ToPrimitive(y) 的结果如果Type(x)是Object并且Type(y)是String或Number或Symbol中的一种，返回 ToPrimitive(x)==y 的结果其他返回false slice()和splice()`的区别slice: 只能截取数组中的一段，且截取后原数据不会发生变化; splice: 不仅仅能够截取数组中的一段，还能够在原数组中进行替换 push(), pop(), shift()和unshift()(1). push, pop:类似于栈的行为，后进先出 (2). shift, unshift: 类似于队列的行为, 先进先出 数组方法 1234567891011(1). 修改器方法 push, pop, unshift, shift, sort, reverse, splice(2). 访问方法 (返回新的数组) concat, slice(3). 迭代方法 forEach, filter, map, reduce map和setmap是一组键值对的结构，具有极快的查找速度 set和map类似，也是一组key的集合，但不储存value，在set中，key不可重复 现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。 null和undefined，怎么判断是nullnull: 表示一个值被定义了，定义为”空值”; undefined: 表示根本不存在定义; 12345let exp = undefinedif (typeof (exp) === &#x27;undefined&#x27;) console.log(&#x27;undefined&#x27;);exp = nullif (!exp) console.log(&#x27;null&#x27;); arguments在调用函数时，我们所传递的实参都会在arguments中保存，是一个类似于数组的对象，只有数组的length，没有数组方法 call, apply和bind的用法call, apply, bind都是用来改变this的指向 apply接收两个参数，第一个参数是this的指向，第二个参数是函数接收的参数，以数组的形式进行传递 call第一个参数也是用来改变this的指向，后面的参数均是函数接收的参数 apply与call均只改变this的指向一次 bind第一个参数也是改变this的指向，后面与call类似也是传入参数列表，但与call不同的是，bind的可以不需要一次性传入所有参数，并且bind改变this指向后不会立即执行而是返回一个永久改变this指向的函数 三者的区别: (1). 都可以改变this的指向;(2). 第一个参数都是this要指向的对象;(3). 三个都可以传参，但是方法各不相同，apply是数组，bind和call都是利用参数列表进行传参但是bind可以分多次传参，call只可以传一次;(4). bind是返回绑定this之后的函数，apply和call是立即调用 123// step 1: 调用函数的上下文指向obj// step 2: 传参// step 3: 执行函数并返回结果 12345678910111213141516171819202122232425262728293031let myApply = (context) =&gt; &#123; context = context ? Object(context) : window context.fn = this let args = [...arguments][1] if (!args) return context.fn() let res = context.fn(...args) delete context.fn return res&#125;let myCall = (context) =&gt; &#123; context = context ? Object(context) : window context.fn = this let args = [...arguments].slice(1) let res = context.fn(...args) delete context.fn return res&#125;let myBind = (context) =&gt; &#123; let me = this return function () &#123; return me.call(context, arguments) &#125;&#125; CommonJS和ES6模块的区别(1). CommonJS输出的是一个值的拷贝，ES6模块输出的是值的引用，换句话说就是CommonJS在模块内部发生的后续变化影响不了外部对这个值的使用; (2). CommonJS模块是运行时加载，ES6模块是编译时输出接口; (3). CommonJS顶层this指向当前模块, 而在ES6模块中this指向undefined innerHtml, innerText, outerHtmlinnerHtml: 是指从对象的起始位置到终止位置的全部内容包括html标签 innerText: 从起始位置到终止位置的内容，不包括html标签 outerHtml: 除了包含innerHtml全部内容外还包含了对象标签本身 怎么判断是数组 (1). instanceof; (2). constructor arr.constructor === Array; (3). toString example: Object.prototype.toString.call(arr) === &#39;[object Array]&#39;;; (4). Array.isArray(arr) 数组拷贝浅拷贝: 直接将数组引用复制的方法是浅拷贝 深拷贝: 递归复制了所有层级 JSON.parse(JSON.stringify(arr)); slice和concat在多维数组中无效 闭包闭包就是能够读取其他函数内部变量的函数，本质上闭包就是函数内部与函数外部的一座桥梁 promise与async/awaitPromise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了 说到底，Promise 也还是使用回调函数，只不过是把回调封装在了内部，使用上一直通过 then 方法的链式调用，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。 promise可解决回调地狱的问题 (1). promise是ES6的语法，async/await是ES7的语法; (2). promise的错误可以通过catch来捕捉，而async/await的错误用try-catch来捕捉，因为await只会返回promise成功的值; async与generator async相当于自执行的generator函数，相当于自带一个状态机，在await的部分等待即过，返回后自动执行下一步 js中0.1+0.2为什么不等于0.3,怎么解决计算机是用二进制储存数的，而十进制小数转二进制的方法是用2去乘小数部分，这会导致小数不能精确的表达所以当两个小数相加时，很有可能产生误差 解决方法是可以将数组转为整数先进行加法再除以他们放大的倍数或者利用第三方库 js垃圾回收机制(1). 标记清理 在垃圾程序运行的时候，会标记内存中存储的所有变量然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存 ;(2). 引用计数 对每个值都记录它被引用的次数，声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1，类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.当一个值的引用数为0时，就说明没发再访问这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存; 垃圾回收算法: (1). 标记空间中可达的值; (2). 回收不可达的值所占据的内存; (3). 做内存整理; 分代收集: (1). 浏览器将数据分为两种，一种是临时对象，一种是长久对象;(2). 临时对象: 函数内部声明的变量，块级作用域中的变量; 长久对象: 生命周期很长的对象，比如全局的window，DOM(3). 两种不同的对象对应不同的回收策略，V8把堆分成新生代和老生代两个区域，新生代中存放临时对象，老生代中存放持久对象并且让副垃圾回收器，主垃圾回收器分别负责新生代和老生代的垃圾回收，这样就可以高效的垃圾回收(4). 主垃圾回收器: 负责老生代的垃圾回收，有两个特点: 对象占用空间大，对象存活时间长。它使用标记清除的算法执行垃圾回收。在遍历的过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据，然后是垃圾清除，直接将标记为垃圾的数据清理掉，这样会产生大量的不连续的内存碎片，需要进行内存整理(5). 副垃圾回收器: 负责新生代的垃圾回收，通常只支持1-8M的容量，新生代被分为两个区域：一般是对象区域，一半是空闲区域。新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。先给对象区域所有垃圾做标记；标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍；这就回到我们前面留下的问题 – 副垃圾回收器没有碎片整理。因为空闲区域里此时是有序的，没有碎片，也就不需要整理了；复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。这样，就完成了垃圾回收。因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://andylinwenqin.github.io/tags/JS/"}]},{"title":"let var const","slug":"let-var-const","date":"2021-06-26T12:36:09.000Z","updated":"2021-06-26T12:50:59.354Z","comments":true,"path":"2021/06/26/let-var-const/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/let-var-const/","excerpt":"","text":"var, let, const的区别varvar声明的变量没有块级作用域而let声明的变量拥有块级作用域， constconst声明的是常量，声明之后无法对其进行修改， const保证的实际上并不是变量的值不得改变，而是变量指向的那个内存地址不得改动，对于复合类型的数据如对象，数组，变量指向的内存地址保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的 let在代码块内，使用let命令声明变量之前，该变量都是不可用的，在语法上称为暂时性死区","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://andylinwenqin.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"}]},{"title":"浏览器工作原理","slug":"浏览器工作原理","date":"2021-06-26T07:25:39.000Z","updated":"2021-06-26T09:21:12.844Z","comments":true,"path":"2021/06/26/浏览器工作原理/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"从输入 URL 到页面加载完成的过程中都发生了什么？简单路径线（掌握即可）：1.键盘或触屏输入URL并回车确认 2.URL解析/DNS解析查找域名IP地址 3.网络连接发起HTTP请求 4.HTTP报文传输过程 5.服务器接收数据 6.服务器响应请求/MVC 7.服务器返回数据 8.客户端接收数据 9.浏览器加载/渲染页面 10.打印绘制输出 详细路径线（看看就好）：键盘或触屏输入URL并回车确认事情的开端要追溯到服务器启动监听服务的时候，在某个未知的时刻，一台机房里普普通通的服务器，加上电，启动了操作系统，随着操作系统的就绪，服务器启动了 http 服务进程，这个 http 服务的守护进程（daemon），可能是 Apache、Nginx、IIS、Lighttpd中的一个，不管怎么说，这个 http 服务进程开始定位到服务器上的 www 文件夹（网站根目录），一般是位于 /var/www ，然后启动了一些附属的模块，例如 php，或者，使用 fastcgi 方式连接到 php 的 fpm 管理进程，然后，向操作系统申请了一个 tcp 连接，然后绑定在了 80 端口，调用了 accept 函数，开始了默默的监听，监听着可能来自位于地球任何一个地方的请求，随时准备做出响应。这个时候，典型的情况下，机房里面应该还有一个数据库服务器，或许，还有一台缓存服务器，如果对于流量巨大的网站，那么动态脚本的解释器可能还有单独的物理机器来跑，如果是中小的站点，那么，上述的各色服务，甚至都可能在一台物理机上，这些服务监听之间的关系，可以通过自己搭建一次 Apache PHP MySQL 环境来了解一下，不管怎么说，他们做好了准备，静候差遣。 然后是开始键盘或手机触屏输入URL，然后通过某种机制传到CPU（过程略），CPU进行内部处理（过程略），处理完后，再从CPU传到操作系统内核（过程略），然后再由操作系统GUI传到浏览器，再由浏览器到浏览器内核。（很浅显意会即可） 上面一步操作系统 GUI 会将输入事件传递到浏览器中，在这过程中，浏览器可能会做一些预处理，甚至已经在智能匹配所有可能的URL了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的URL，来预估所输入字符对应的网站，然后给出智能提示，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「www.baidu.com 」，因此就会在输入回车前就马上开始建立 TCP 链接了。对于 Chrome这种变态的浏览器，他甚至会直接从缓存中把网页渲染出来，就是说，你还没有按下「回车」键，页面就已经出来了，再比如Chrome会在浏览器启动时预先查询10个你有可能访问的域名等等，这里面还有很多其它策略，不详细讲了。感兴趣的推荐阅读 High Performance Networking in Chrome。 URL 解析/DNS 查询接着是输入 URL 「回车」后，这时浏览器会对 URL 进行检查，这里需要对URL有个回顾，请见百科《URL》，完整的URL由几个部分构成：协议、网络地址、资源路径、文件名、动态参数 URL完整格式为：协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志 例如：https://www.zhihu.com/question/55998388/answer/166987812 协议部分：https 网络地址：www.zhihu.com（依次为 子/三级域名.二级域名.顶/一级域名） 资源路径：/question/55998388/answer/166987812 DNS递归查询和迭代查询的区别？ 递归查询是以本地名称服务器为中心的，是DNS客户端和服务器之间的查询活动，递归查询的过程中“查询的递交者” 一直在更替，其结果是直接告诉DNS客户端需要查询的网站目标IP地址。 迭代查询则是DNS客户端自己为中心的，是各个服务器和服务器之间的查询活动，迭代查询的过程中“查询的递交者”一直没变化，其结果是间接告诉DNS客户端另一个DNS服务器的地址。 应用层客户端发送HTTP请求互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示： 从上面的步骤中得到 IP 地址后，浏览器会开始构造一个 HTTP 请求，应用层客户端向服务器端发送的HTTP请求包括：请求报头和请求主体两个部分，其中请求报头（request header）包含了至关重要的信息，包括请求的方法（GET / POST和不常用的PUT / DELETE以及更不常用的HEAD / OPTION / TRACE，一般的浏览器只能发起 GET 或者 POST 请求）、目标url、遵循的协议（HTTP / HTTPS / FTP…），返回的信息是否需要缓存，以及客户端是否发送Cookie等信息。需要注意的是，因为 HTTP 请求是纯文本格式的，所以在 TCP 的数据段中可以直接分析 HTTP 文本的。 传输层TCP传输报文当应用层的 HTTP 请求准备好后，浏览器会在传输层发起一条到达服务器的 TCP 连接，位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。 这里需要谈一下 TCP 的 Head-of-line blocking 问题：假设客户端的发送了 3 个 TCP 片段（segments），编号分别是 1、2、3，如果编号为 1 的包传输时丢了，即便编号 2 和 3 已经到达也只能等待，因为 TCP 协议需要保证顺序，这个问题在 HTTP pipelining 下更严重，因为 HTTP pipelining 可以让多个 HTTP 请求通过一个 TCP 发送，比如发送两张图片，可能第二张图片的数据已经全收到了，但还得等第一张图片的数据传到。为了解决 TCP 协议的性能问题，Chrome 团队提出了 QUIC 协议，它是基于 UDP 实现的可靠传输，比起 TCP，它能减少很多来回（round trip）时间，还有前向纠错码（Forward Error Correction）等功能。目前 Google Plus、 Gmail、Google Search、blogspot、Youtube 等几乎大部分 Google 产品都在使用 QUIC，可以通过chrome://net-internals/#spdy 页面来发现。另外，浏览器对同一个域名有连接数限制，大部分是 6，但并非将这个连接数改大后就会提升性能，Chrome 团队有做过实验，发现从 6 改成 10 后性能反而下降了，造成这个现象的因素有很多，如建立连接的开销、拥塞控制等问题，而像 SPDY、HTTP 2.0 协议尽管只使用一个 TCP 连接来传输数据，但性能反而更好，而且还能实现请求优先级。 网络层IP协议查询MAC地址IP协议的作用是把TCP分割好的各种数据包封装到IP包里面传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址才可以。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。 数据到达数据链路层在找到对方的MAC地址后，已被封装好的IP包再被封装到数据链路层的数据帧结构中，将数据发送到数据链路层传输，再通过物理层的比特流送出去。这时，客户端发送请求的阶段结束。 服务器接收数据接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。 服务器响应请求并返回相应文件服务接收到客户端发送的HTTP请求后，服务器上的的 http 监听进程会得到这个请求，然后一般情况下会启动一个新的子进程去处理这个请求，同时父进程继续监听。http 服务器首先会查看重写规则，然后如果请求的文件是真实存在，例如一些图片，或 html、css、js 等静态文件，则会直接把这个文件返回，如果是一个动态的请求，那么会根据 url 重写模块的规则，把这个请求重写到一个 rest 风格的 url 上，然后根据动态语言的脚本，来决定调用什么类型的动态文件脚本解释器来处理这个请求。 我们以 php 语言为例来说的话，请求到达一个 php 的 mvc 框架之后，框架首先应该会初始化一些环境的参数，例如远端 ip，请求参数等等，然后根据请求的 url 送到一个路由器类里面去匹配路由，路由由上到下逐条匹配，一旦遇到 url 能够匹配的上，而且请求的方法也能够命中的话，那么请求就会由这个路由所定义的处理方法去处理。 请求进入处理函数之后，如果客户端所请求需要浏览的内容是一个动态的内容，那么处理函数会相应的从数据源里面取出数据，这个地方一般会有一个缓存，例如 memcached 来减小 db 的压力，如果引入了 orm 框架的话，那么处理函数直接向 orm 框架索要数据就可以了，由 orm 框架来决定是使用内存里面的缓存还是从 db 去取数据，一般缓存都会有一个过期的时间，而 orm 框架也会在取到数据回来之后，把数据存一份在内存缓存中的。 orm 框架负责把面向对象的请求翻译成标准的 sql 语句，然后送到后端的 db 去执行，db 这里以 mysql 为例的话，那么一条 sql 进来之后，db 本身也是有缓存的，不过 db 的缓存一般是用 sql 语言 hash 来存取的，也就是说，想要缓存能够命中，除了查询的字段和方法要一样以外，查询的参数也要完全一模一样才能够使用 db 本身的查询缓存，sql 经过查询缓存器，然后就会到达查询分析器，在这里，db 会根据被搜索的数据表的索引建立情况，和 sql 语言本身的特点，来决定使用哪一个字段的索引，值得一提的是，即使一个数据表同时在多个字段建立了索引，但是对于一条 sql 语句来说，还是只能使用一个索引，所以这里就需要分析使用哪个索引效率最高了，一般来说，sql 优化在这个点上也是很重要的一个方面。 sql 由 db 返回结果集后，再由 orm 框架把结果转换成模型对象，然后由 orm 框架进行一些逻辑处理，把准备好的数据，送到视图层的渲染引擎去渲染，渲染引擎负责模板的管理，字段的友好显示，也包括负责一些多国语言之类的任务。对于一条请求在 mvc 中的生命周期，可以参考这里，临摹了一个 PHP MVC 框架，在视图层把页面准备好后，再从动态脚本解释器送回到 http 服务器，由 http 服务器把这些正文加上一个响应头，封装成一个标准的 http 响应包，再通过 tcp ip 协议，送回到客户机浏览器。 浏览器开始处理数据信息并渲染页面历经千辛万苦，我们请求的响应终于成功到达了客户端的浏览器，响应到达浏览器之后，浏览器首先会根据返回的响应报文里的一个重要信息——状态码，来做个判断。如果是 200 开头的就好办，表示请求成功，直接进入渲染流程，如果是 300 开头的就要去相应头里面找 location 域，根据这个 location 的指引，进行跳转，这里跳转需要开启一个跳转计数器，是为了避免两个或者多个页面之间形成的循环的跳转，当跳转次数过多之后，浏览器会报错，同时停止。比如：301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。如果是 400 开头或者 500 开头的状态码，浏览器也会给出一个错误页面。比如：404 not found 就表示客户端请求的资源找不到。 当浏览得到一个正确的 200 响应之后，接下来面临的一个问题就是多国语言的编码解析了，响应头是一个 ascii 的标准字符集的文本，这个还好办，但是响应的正文本质上就是一个字节流，对于这一坨字节流，浏览器要怎么去处理呢？首先浏览器会去看响应头里面指定的 encoding 域，如果有了这个东西，那么就按照指定的 encoding 去解析字符，如果没有的话，那么浏览器会使用一些比较智能的方式，去猜测和判断这一坨字节流应该使用什么字符集去解码。相关的笔记可以看这里，字符集编码 接下来就是构建 dom 树了，在 html 语言嵌套正常而且规范的情况下，这种 xml 标记的语言是比较容易的能够构建出一棵 dom 树出来的，当然，对于互联网上大量的不规范的页面，不同的浏览器应该有自己不同的容错去处理。构建出来的 dom 本质上还是一棵抽象的逻辑树，构建 dom 树的过程中，如果遇到了由 script 标签包起来的 js 动态脚本代码，那么会把代码送到 js 引擎里面去跑，如果遇到了 style 标签包围起来的 css 代码，也会保存下来，用于稍后的渲染。如果遇到了 img 或 css 和 js等引用外部文件的标签，那么浏览器会根据指定的 url 再次发起一个新的 http 请求，去把这个文件拉取回来，值得一提的是，对于同一个域名下的下载过程来说，浏览器一般允许的并发请求是有限的，通常控制在两个左右，所以如果有很多的图片的话，一般出于优化的目的，都会把这些图片使用一台静态文件的服务器来保存起来，负责响应，从而减少主服务器的压力。 dom 树构造好了之后，就是根据 dom 树和 css 样式表来构造 render 树了，这个才是真正的用于渲染到页面上的一个一个的矩形框的树，网页渲染是浏览器最复杂、最核心的功能，对于 render 树上每一个框，需要确定他的 x y 坐标，尺寸，边框，字体，形态，等等诸多方面的东西，render 树一旦构建完成，整个页面也就准备好了，可以上菜了。需要说明的是，下载页面，构建 dom 树，构建 render 树这三个步骤，实际上并不是严格的先后顺序的，为了加快速度，提高效率，让用户不要等那么久，现在一般都并行的往前推进的，现代的浏览器都是一边下载，下载到了一点数据就开始构建 dom 树，也一边开始构建 render 树，构建了一点就显示一点出来，这样用户看起来就不用等待那么久了。 将渲染好的页面图像显示出来，并开始响应用户的操作这一步主要涉及显卡，内存及显示器原理等知识，不做详细解说，大概就是从内存到 LCD/LED，再由光线进入人眼的一个过程。 总结以上过程简单讲主要是：从输入 URL 到浏览器接收（回车前），从浏览器接收到数据如何发送给网卡（回车后），再把接收的数据从本机网卡发送到服务器，服务器接收到数据后做了怎么的处理？服务器返回数据后浏览器又做了哪些处理？浏览器又是如何将处理好的页面展现在屏幕上的？的这么一个过程。 但只是最基本的一些步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及。即使基本步骤本身也有很复杂的子步骤，TCP/IP、DNS、HTTP、HTML等等，还需要考虑很多情况，比如广播、拆包解包合并包丢包重传、路由表，NAT、TCP 状态机、CDN、HTTPS 证书校验与中间人攻击检测、RSA 密钥协商、AES 加解密、浏览器解析 HTTP 的有限自动状态机、GUI 库与绘图、OpenGL 绘图、GPU 加速（OpenCL 与 CUDA）、JIT（JavaScript 会把 JavaScript 代码编译成汇编代码）、服务器的数据库 NoSQL 或 SQL 查询、主从数据库同步、服务器和浏览器的内存管理（WebKit 实现的 fastMalloc()，服务器上可能是 TCMalloc 或者 JeMalloc）、服务器上的语言解释器（可能也是 JIT）、多媒体：傅里叶变换、H.264 解码（硬件解码，硬件解码的话 GPU 的处理单元又在计算…….或软件解码）、音频解码、WebGL 绘图、浏览器的 Sandbox、服务器的 SQL 注入检查、产生的键盘中断信号处理（或者是高级层面的输入输出驱动）、网卡驱动、网络栈的 TCP FastOpen、SYN Cookie 之类众多技术……每一个都可以展开成庞大的课题，而浏览器的基础——操作系统、编译器、硬件等更是一个比一个复杂。即便是计算机专业的同学看了也会头大，但我保证这里面的每一个步骤都经过深思熟虑和时间的考验的，并不是谁闲的蛋疼非要搞得那么复杂，不复杂也不行啊。你输入URL即可浏览互联网，而计算机系统在背后做了无数你看不到的工作，计算机各个子领域无数工程师为此付出了你难以想象的努力。 参考资料： 了解html页面的渲染过程 前端工程师手册 浏览器渲染那些事 手机上从输入URL到页面加载完成的过程中都发生了什么？ 当页面渲染时，浏览器发生了什么？ 浏览器工作原理分析与首屏加载 https://www.youtube.com/watch?v=eeS4brbDVuU 卐鑫卍","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"性能优化","slug":"性能优化","permalink":"https://andylinwenqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"html&浏览器","slug":"html-浏览器","permalink":"https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"重排和重绘","slug":"重排和重绘","date":"2021-06-26T06:27:49.000Z","updated":"2021-07-11T06:47:17.409Z","comments":true,"path":"2021/06/26/重排和重绘/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"","text":"重排(reflow)和重绘(repaint) 页面生成的过程：1.HTML 被 HTML 解析器解析成 DOM 树； 2.CSS 被 CSS 解析器解析成 CSSOM 树； 3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment； 4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点； 5.将布局绘制(paint)在屏幕上，显示出整个页面。 第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。 渲染：在页面的生命周期中，网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。 重排比重绘大：大，在这个语境里的意思是：谁能影响谁？ 重绘：某些元素的外观被改变，例如：元素的填充颜色 重排：重新生成布局，重新排列元素。 就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。 也就是说：重绘不一定导致重排，但重排一定会导致重绘。 重排(reflow)：概念：当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 重排也叫回流，简单的说就是重新生成布局，重新排列元素。 下面情况会发生重排： 页面初始渲染，这是开销最大的一次重排 添加/删除可见的DOM元素 改变元素位置 改变元素尺寸，比如边距、填充、边框、宽度和高度等 改变元素内容，比如文字数量，图片大小等 改变元素字体大小 改变浏览器窗口尺寸，比如resize事件发生时 激活CSS伪类（例如：:hover） 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。 常见引起重排属性和方法 – – – width height margin padding display border-width border position overflow font-size vertical-align min-height clientWidth clientHeight clientTop clientLeft offsetWudth offsetHeight offsetTop offsetLeft scrollWidth scrollHeight scrollTop scrollLeft scrollIntoView() scrollTo() getComputedStyle() getBoundingClientRect() scrollIntoViewIfNeeded() 重排影响的范围：由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种： 全局范围：从根节点html开始对整个渲染树进行重新布局。 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局 全局范围重排： 123456789101112&lt;body&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h4&gt;hello&lt;/h4&gt; &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt; &lt;h5&gt;male&lt;/h5&gt; &lt;ol&gt; &lt;li&gt;coding&lt;/li&gt; &lt;li&gt;loving&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt;复制代码 当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。 局部范围重排： 用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。 重绘(Repaints):概念：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 常见的引起重绘的属性： 属性： – – – color border-style visibility background text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 重排优化建议：重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。 减少重排范围我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。 尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 减少重排次数1.样式集中改变不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 cssText 变量中编辑。虽然现在大部分现代浏览器都会有 Flush 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。 1234567891011121314// badvar left = 10;var top = 10;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;;// 当top和left的值是动态计算而成时...// better el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;// betterel.className += &quot; className&quot;;复制代码 2.分离读写操作DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。 123456789101112131415161718// bad 强制刷新 触发四次重排+重绘div.style.left = div.offsetLeft + 1 + &#x27;px&#x27;;div.style.top = div.offsetTop + 1 + &#x27;px&#x27;;div.style.right = div.offsetRight + 1 + &#x27;px&#x27;;div.style.bottom = div.offsetBottom + 1 + &#x27;px&#x27;;// good 缓存布局信息 相当于读写分离 触发一次重排+重绘var curLeft = div.offsetLeft;var curTop = div.offsetTop;var curRight = div.offsetRight;var curBottom = div.offsetBottom;div.style.left = curLeft + 1 + &#x27;px&#x27;;div.style.top = curTop + 1 + &#x27;px&#x27;;div.style.right = curRight + 1 + &#x27;px&#x27;;div.style.bottom = curBottom + 1 + &#x27;px&#x27;;复制代码 原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制： 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。 3.将 DOM 离线“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做： 使用 display:none 一旦我们给元素设置 display:none 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 display属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，visibility : hidden 的元素只对重绘有影响，不影响重排。 通过 documentFragment 创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上工作，然后替换它！ 4.使用 absolute 或 fixed 脱离文档流使用绝对定位会使的该元素单独成为渲染树中 body 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。 5.优化动画 可以把动画效果应用到 position属性为 absolute 或 fixed 的元素上，这样对其他元素影响较小。 动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多 启用GPU加速 GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。 GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。 12345678910 /* * 根据上面的结论 * 将 2d transform 换成 3d * 就可以强制开启 GPU 加速 * 提高动画性能 */ div &#123; transform: translate3d(10px, 10px, 0); &#125;复制代码 如何在浏览器中查看页面渲染时间1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图 蓝色: 网络通信和HTML解析 黄色: JavaScript执行 紫色: 样式计算和布局，即重排 绿色: 重绘 哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。 2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图： 3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。 4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。 小结： 渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。 CSS3 就是在 GPU 发生的：Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。 参考文档掌握浏览器重绘(repaint)重排(reflow))-前端进阶 csstriggers CSS硬件加速的好与坏 本文来自齐小神的重排重绘","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"性能优化","slug":"性能优化","permalink":"https://andylinwenqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"CSS性能优化","slug":"CSS性能优化","date":"2021-06-26T06:19:07.000Z","updated":"2021-06-26T06:32:24.788Z","comments":true,"path":"2021/06/26/CSS性能优化/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/CSS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"提高性能的方法有哪些? 合并css文件，如果页面加载10个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。 减少css嵌套，最好不要嵌套三层以上。 不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。 建立公共样式类，把相同样式提取出来作为公共类使用。 减少通配符*或者类似[hidden=”true”]这类选择器的使用，挨个查找所有…这性能能好吗？ 巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。 拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。 不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。 少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。 cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。 善后工作，css压缩(在线压缩工具 YUI Compressor) GZIP压缩，是一种流行的文件压缩算法。 性能优化避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。首先，使用@import引入css会影响浏览器的并行下载。使用@import引用的css文件只有在引用它的那个css文件被下载，解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析，构建render tree等一系列操作，这就导致浏览器无法并行下载所需的样式文件。其次，多个@import会导致下载顺序紊乱，在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件优先于@import下载，并且打乱甚至破坏@import自身的并行下载。所以不要使用这一方法，使用link标签就行了。 避免过分重排 浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow 浏览器根据定义好的样式来计算，并将元素放到该出现的位置上，这个过程叫做reflow 页面上任何一个节点触发来reflow，会导致他的子节点和祖先节点重新渲染 导致reflow发生的情况 123456789101. 改变窗口的大小 2. 改变文字的大小3. 添加 删除样式表4. 内容的改变 输入框输入内容也会5. 伪类的激活6. 操作class属性7. 脚本操作dom js改变css类8. 计算offsetWidth和offsetHeight9. 设置style属性10.改变元素的内外边距 常见重排元素 12341. 大小有关的 width,height,padding,margin,border-width,border,min-height2. 布局有关的 display,top,position,float,left,right,bottom3. 字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align4. 隐藏有关的 overflow,overflow-x,overflow-y 减少reflow对性能的影响的建议 1234561. 不要一条条的修改dom的样式，预先定义好class，然后修改dom的classname2. 不要修改影响范围较大的dom3. 为动画元素使用绝对定位4. 不要table布局，因为一个很小的改动会造成整个table重新布局5. 避免设置大量的style属性，通过设置style属性改变节点样式的话，每一次设置都会触发一次reflow，所以最好使用class属性6. 如果css里面有计算表达式，每次都会重新计算一遍，触发一次reflow repaint 当一个元素的外观被改变，但是布局没有改变的情况 当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素 常见的重绘元素 123- 颜色 color,background- 边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width- 背景有关 background,backgound-image,background-position,background-repeat,background-size CSS动画 css动画启用GPU加速，应用GPU的图形性能对浏览器中的一些图形操作交给GPU完成。canvas2D，布局合成，css3转换，css3d变换，webGL，视频 2d加速 3d加速 文件压缩性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。 去除无用CSS虽然文件压缩能够降低文件大小，但css文件压缩通常只会去除无用的空格，这样就限制来css文件的压缩比例。如果压缩后的文件仍然超过来预期的大小，可以试着找到并删除代码中无用的css。一般情况下，会存在这两种无用的CSS代码： 不同元素或者其他情况下的重复代码， 整个页面内没有生效的CSS代码 有选择地使用选择器css选择器的匹配是从右向左进行的，这一策略导致来不同种类的选择器之间的性能也存在差异。相比于 #markdown-content-h3,显然使用 #markdown.content h3时，浏览器生成渲染树所要花费的时间更多。因为后者需要先找到DOM中的所有h3元素，再过滤掉祖先元素不是.content的，最后过滤掉.content不是#markdown的。试想，页面中的元素更多，那么匹配所要花费的时间代价自然更高。显得浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微，此外不同选择器在不同浏览器中的性能表现也不统一，在编写css的时候无法兼顾每种浏览器，鉴于这两点，在使用选择器时，尽量记住以下几点： 12341. 保持简单，不要使用嵌套过多过于复杂的选择器2. 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。3. 不要使用类选择器和ID选择器修饰元素标签，如：h3#markdown-content，这一多此一举，还会降低效率4. 不要为了追求速度而放弃可读性和可维护性 TIPS：为什么css选择器是从右向左匹配的？css中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得css选择器在不匹配的时候效率更高。 减少使用昂贵的属性在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价，而页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写css时，应该尽量减少使用昂贵属性，如:box-shadow, border-radius, filter, 透明度, :nth-child等当然并不是不要使用这些属性，这些都是经常使用的属性，只是这里可以作为一个了解。当有其他方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，这一网站的性能会在不知不觉中得到一定的提升。 硬件加速的好坏 仅仅依靠GPU还是不行的，许多动画还是需要CPU的介入，连接cpu和GPU的总带宽不是无限的，所以需要注意数据在cpu和GPU之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输。 一个重点是了解创建的合成层的数量，每一个层都对应来一个GPU纹理，太多的层会消耗很多内存。 **chrome://flags/#composited-layer-borders**观察的地址。 每一个dom元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层 另一个重点是保持GPU和CPU之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给GPU。 因为为了高性能，动画开始之后避免层的更新也是非常重要的，避免动画进行中其他层一直更新导致拥堵。 也就是使用这些css属性来实现动画：transformation, opacity, filter 使用性能工具检测优化的合理性，timeline检测优化是否合理，还需要实现自动操作来做性能回归测试。 检测层数和层更新次数是非常有用的。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"},{"name":"性能优化","slug":"性能优化","permalink":"https://andylinwenqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"事件委托","slug":"事件委托","date":"2021-06-26T04:33:56.000Z","updated":"2021-09-04T05:37:14.655Z","comments":true,"path":"2021/06/26/事件委托/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件委托 基本概念事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素； 一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。 三个阶段1.捕获阶段2.执行阶段3.冒泡阶段 个人理解捕获执行是有外到内的 div＞ui＞li执行冒泡是由内到外的 li＞ui＞div给父元素绑定事件监听，通过内部判断点击的位置再给对应的DOM附上操作 阻止冒泡那如何阻止时间冒泡？ 使用 e（event）.stopPropagation() 起到阻止捕获和冒泡阶段中当前事件的进一步传播。 事件对象e : 事件触发的时候会自动生成一个事件对象，生命周期是从事件开始到事件结束，有位置信息（事件本身是谁）、触发的事件类型、触发的事件元素等...... 这样做的好处减少事件数量，提高性能预测未来元素，新增元素仍可以触发该事件避免内存外泄，在低版本的ie中，防止删除元素没有移除元素造成的内存溢出","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"CSS选择器","slug":"CSS选择器","date":"2021-06-26T03:47:25.000Z","updated":"2021-06-26T04:31:04.095Z","comments":true,"path":"2021/06/26/CSS选择器/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/CSS%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"CSS选择器 通用选择器 * 0元素选择器 1类选择器 class 10id选择器 id 100组合选择器 A＞B 行内样式 1000！important ∞","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"}]},{"title":"git工具","slug":"git工具","date":"2021-06-26T03:41:09.000Z","updated":"2021-08-19T12:30:30.926Z","comments":true,"path":"2021/06/26/git工具/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/git%E5%B7%A5%E5%85%B7/","excerpt":"","text":"git工具 git工具git add . 添加到暂存区git branch 查看分支状态git checkout master 切换到master分支git commit -m “” 将暂存区内容添加到本地仓库并加备注git push 上传远程仓库并合并git merge login 合并分支git status 查看仓库状态显示变更文件git log 查看历史提交记录git reset 回退版本git rm 删除工作区文件git mv 重命名或者移动工作区文件 git branch [name] 本地创建分支git工具git push origin [name] 本地上传新分支git branch -d [name] 删除本地分支git push origin :[name] 删除远程分支git clone -b dev [] 拉取指定分支代码 github 拉去所有分支 git clone xxxgit branch -r | grep -v ‘-&gt;’ | while read remote; do git branch –track “${remote#origin/}” “$remote”; donegit fetch –allgit pull –all","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"},{"name":"git","slug":"git","permalink":"https://andylinwenqin.github.io/tags/git/"}]},{"title":"This指向","slug":"This指向","date":"2021-06-26T03:40:56.000Z","updated":"2021-06-26T12:51:06.785Z","comments":true,"path":"2021/06/26/This指向/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/This%E6%8C%87%E5%90%91/","excerpt":"","text":"this指向（五种） 默认绑定web全局环境下的this指向windowconsole.log(this); // window 函数独立调用非严格模式下，函数内部的this指向window 严格模式下，为undefined 12345678910function fn() &#123; console.log(this);&#125;fn(); // windowwindow.fn();&#x27;use strict&#x27;function fn() &#123; console.log(this);&#125;fn(); // undefined 被嵌套的函数独立调用时，this默认指向window12345678910var obj = &#123; a: 2, foo: function() &#123; function test() &#123; console.log(this); // window &#125; test(); &#125;&#125;obj.foo(); IIFE自执行函数1234567891011(function() &#123; console.log(this); // window&#125;)()var obj2 = &#123; foo: function() &#123; (function () &#123; console.log(this); // window &#125;)() &#125;&#125;obj2.foo() 闭包中this默认指向window12345678910111213var obj3 = &#123; a: 2, foo: function() &#123; console.log(this); // obj3 var c = this.a; // 2 return function test() &#123; console.log(this); // window return c; &#125; &#125;&#125;var fn = obj3.foo();console.log(fn()); // 2 隐式绑定当函数当做方法使用时，this指向直接对象12345678910111213var obj3 = &#123; a: 2, foo: function() &#123; console.log(this); // obj3 var c = this.a; // 2 return function test() &#123; console.log(this); // window return c; &#125; &#125;&#125;var fn = obj3.foo();console.log(fn()); // 2 1234567891011function foo() &#123; console.log(this); // obj5&#125;var obj4 = &#123; foo: foo, obj5: &#123; a:1, foo: foo &#125;&#125;obj4.obj5.foo(); 12345678function foo1() &#123; console.log(this); // obj6&#125;var obj6 = &#123; a: 2, foo: foo1&#125;var bar = obj6.foo(); // 在这就已经执行了方法 隐式丢失被隐式绑定的函数丢失了绑定对象，从而默认绑定到window123456789function foo1() &#123; console.log(this); // window&#125;var obj6 = &#123; a: 2, foo: foo1&#125;var bar = obj6.foo; // 在这并未执行方法bar(); // 在这执行了方法 参数传递12345678910111213function foo3()&#123; console.log(this);&#125;function bar1(fn) &#123; // 默认赋值 fn = obj7.foo fn(); // window&#125;var obj7 = &#123; a: 1, foo: foo3&#125;bar1(obj7.foo); setTimeout() 和 setInterval() 第一个参数的回调函数中的this 默认指向window123setTimeout(function() &#123; console.log(this); // window &#125;, 0) 显示绑定callcall方法除了第一个参数以外还可以添加多个参数 123456789var a = &#123; user:&quot;追梦子&quot;, fn:function(e,ee)&#123; console.log(this.user); //追梦子 console.log(e+ee); //3 &#125;&#125;var b = a.fn;b.call(a,1,2); call代码实现 12345678Function.prototype.defineCall = function (context) &#123; context = context || window context.fn = this let args = [...arguments].slice(1) let res = context.fn(...args) delete context.fn return res&#125; apply同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组，如下： 123456789var a = &#123; user:&quot;追梦子&quot;, fn:function(e,ee)&#123; console.log(this.user); //追梦子 console.log(e+ee); //11 &#125;&#125;var b = a.fn;b.apply(a,[10,1]); apply代码实现 123456789Function.prototype.defineApply = function (context) &#123; context = context || window context.fn = this let args = [...arguments][1] if (!args) return context.fn() let res = context.fn(...args) delete context.fn return res&#125; bindbind方法返回的是一个修改过后的函数，bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的 12345678910var a = &#123; user:&quot;追梦子&quot;, fn:function(e,d,f)&#123; console.log(this.user); //追梦子 console.log(e,d,f); //10 1 2 &#125;&#125;var b = a.fn;var c = b.bind(a,10);c(1,2); bind代码实现 123456Function.prototype.defineBind = function (context) &#123; let self.this return function () &#123; return self.call(context, agruments) &#125; &#125; 显示绑定总结call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。 new关键字new关键字来执行函数，相当于构造函数来实例化对象，则this指向当前实例化的对象1234function Fn() &#123; console.log(this); // Fn&#123;&#125;&#125;var fn = new Fn(); 箭头函数箭头函数中的this指向外层函数（非箭头函数）的作用域中的this指向。所有绑定规则不适应箭头函数。 123456789101112function foo () &#123; console.log(this); // obj var test = () =&gt; &#123; console.log(this); // obj &#125; test();&#125;var obj = &#123; a: 1, foo: foo&#125;obj.foo(); 箭头函数特点1.没有单独的this2.不绑定arguments3.不能用作构造器，和new一起用会抛出错误4.箭头函数没有prototype5.箭头函数指向外层函数 箭头函数为什么不能做构造器箭头函数会导致new的指向改变错乱，使用时会抛出错误 指向优先级箭头函数＞new绑定＞显示绑定＞隐式绑定＞默认绑定 综合练习123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;;var obj1 = &#123; name: 1, fn1: function() &#123; console.log(this); &#125;, fn2: () =&gt; &#123; console.log(this); &#125;, fn3: function() &#123; return function() &#123; console.log(this); &#125; &#125;, fn4:function() &#123; return () =&gt; console.log(this); &#125;&#125;var obj2 = &#123; name:2&#125; obj1.fn1(); // obj1obj1.fn1.call(obj2); // obj2 obj1.fn2(); // windowobj1.fn2.call(obj2); // window obj1.fn3()(); // windowobj1.fn3().call(obj2); // obj2obj1.fn3.call(obj2)(); // window obj1.fn4()(); // obj1obj1.fn4().call(obj2); // obj1obj1.fn4.call(obj2)(); // obj2 1234567891011121314151617181920212223242526function Foo() &#123; getName = function() &#123; console.log(1); &#125; console.log(this); console.log(this.getName); return this;&#125;Foo.getName = function() &#123; console.log(2);&#125;Foo.prototype.getName = function() &#123; console.log(3);&#125;var getName = function() &#123; console.log(4);&#125;function getName() &#123; console.log(5);&#125; Foo.getName(); // 2getName(); // 4Foo().getName(); //1 Foo()执行，全局getName被覆盖为1，返回的this为windowgetName(); //1 上面把全局getName覆盖为1了， 所以这里为1","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"}]},{"title":"继承","slug":"继承","date":"2021-06-26T03:40:31.000Z","updated":"2021-06-26T12:51:23.814Z","comments":true,"path":"2021/06/26/继承/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承 原型链继承1234567891011121314151617function Parent () &#123; this.name = &#x27;kevin&#x27;;&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () &#123; this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push(&#x27;yayu&#x27;);console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;] 2.在创建 Child 的实例时，不能向Parent传参 借用构造函数(经典继承)1234567891011121314151617function Parent () &#123; this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push(&#x27;yayu&#x27;);console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child(&#x27;kevin&#x27;);console.log(child1.name); // kevinvar child2 = new Child(&#x27;daisy&#x27;);console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 组合继承原型链继承和经典继承双剑合璧。 123456789101112131415161718192021222324252627282930313233function Parent (name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);child1.colors.push(&#x27;black&#x27;);console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 = new Child(&#x27;daisy&#x27;, &#x27;20&#x27;);console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 原型式继承12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: &#x27;kevin&#x27;, friends: [&#x27;daisy&#x27;, &#x27;kelly&#x27;]&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = &#x27;person1&#x27;;console.log(person2.name); // kevinperson1.firends.push(&#x27;taylor&#x27;);console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) &#123; var clone = Object.create(o); clone.sayName = function () &#123; console.log(&#x27;hi&#x27;); &#125; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之new的模拟实现》 《JavaScript深入之创建对象》 本文来自JavaScript深入之继承的多种方式和优缺点","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"}]},{"title":"柯里化","slug":"柯里化","date":"2021-06-26T03:39:54.000Z","updated":"2021-07-18T06:42:10.060Z","comments":true,"path":"2021/06/26/柯里化/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"柯里化 柯里化是一种将多个参数的一个函数转换成一系列使用一个参数的函数技术 12345678function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个 curry 函数可以做到柯里化var addCurry = curry(add);addCurry(1)(2) // 3","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"预加载和懒加载","slug":"预加载和懒加载","date":"2021-06-26T03:39:34.000Z","updated":"2021-06-26T04:32:11.500Z","comments":true,"path":"2021/06/26/预加载和懒加载/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"预加载和懒加载 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"CSS盒模型","slug":"CSS盒模型","date":"2021-06-26T03:39:14.000Z","updated":"2021-06-26T06:06:44.341Z","comments":true,"path":"2021/06/26/CSS盒模型/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"CSS盒模型的完整介绍 盒模型的认识 基本概念：标准模型+IE模型。 包括margin,border,padding,content 标准模型和IE模型的区别 css如何设置获取这两种模型的宽和高 js如何设置获取盒模型对应的宽和高 根据盒模型解释边距重叠 BFC（边距重叠解决方案，还有IFC）解决边距重叠 基本概念：标准模型+IE模型什么是盒模型：盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如图： 由于IE盒模型的怪异模式，IE模型和标准模型的内容计算方式不同。 标准模型和IE模型的区别IE模型和标准模型唯一的区别是内容计算方式的不同，如下图所示： IE模型元素宽度width=content+padding+border，高度计算相同 标准模型元素宽度width=content，高度计算相同 css如何设置获取这两种模型的宽和高通过css3新增的属性 box-sizing: content-box | border-box分别设置盒模型为标准模型（content-box）和IE模型（border-box）。 12345678.content-box &#123; box-sizing:content-box; width: 100px; height: 50px; padding: 10px; border: 5px solid red; margin: 15px;&#125; .content-box设置为标准模型，它的元素宽度width=100px。 12345678.border-box &#123; box-sizing: border-box; width: 100px; height: 50px; padding: 10px; border: 5px solid red; margin: 15px;&#125; .border-box设置为IE模型，它的元素宽度width=content + 2 padding + 2 border = 70px + 2 10px + 2 5px = 100px。 javascript如何设置获取盒模型对应的宽和高 dom.style.width/height 只能取到行内样式的宽和高，style标签中和link外链的样式取不到。 dom.currentStyle.width/height 取到的是最终渲染后的宽和高，只有IE支持此属性。 window.getComputedStyle(dom).width/height 同（2）但是多浏览器支持，IE9以上支持。 dom.getBoundingClientRect().width/height 也是得到渲染后的宽和高，大多浏览器支持。IE9以上支持，除此外还可以取到相对于视窗的上下左右的距离 以上API在浏览器中测试过，有兴趣可以都试一下 外边距重叠当两个垂直外边距相遇时，他们将形成一个外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。注意：只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。 且看下面例子： 1234567891011121314151617&lt;section id=&quot;sec&quot;&gt; &lt;style media=&quot;screen&quot;&gt; * &#123; margin: 0; padding: 0; &#125; #sec &#123; background: #f00; &#125; .child &#123; height: 100px; margin-top: 10px; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;child&quot;&gt;&lt;/article&gt;&lt;/section&gt; 这里父元素section的高度是多少呢，100px，但是我们给section设置overflow:hidden后高度就变成110px，这是为什么呢，其实这里我们给父元素创建了BFC。，什么是BFC,请看下面的介绍。 BFC**BFC(Block Formatting Context)**：块级格式化上下文。BFC决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当设计到可视化布局的时候，BFC提供了一个环境，HTML元素在这个环境中按照一定的规则进行布局。一个环境中的元素不会影响到其他环境中的布局。 BFC的原理（渲染规则） BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠 BFC的区域不会与浮动元素的布局重叠。 BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。 计算BFC高度的时候，浮动元素也会参与计算(清除浮动) 如何创建BFC overflow不为visible; float的值不为none； position的值不为static或relative； display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex; 说了这么多规则，放几个实类出来看看。 12345678910111213141516171819202122&lt;section id=&quot;margin&quot;&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; #margin &#123; background: pink; overflow: hidden; &#125; p &#123; margin: 15px auto 25px; background: red; &#125; &lt;/style&gt; &lt;p&gt;1&lt;/p&gt; &lt;div style=&quot;overflow: hidden&quot;&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt;&lt;/section&gt; 请看这里的第二个p元素2他被一个父元素包裹，并且父元素有 overflow:hidden 样式，前面的如何创建BFC的第一条就说了 overflow:hidden 可以创建一个BFC。结果如下图所示。 我们看这里的2，它的上下外边距都没有与1和3发生重叠，但3与4外边距发生了重叠。这就解释了BFC创建了一个独立的环境，这个环境中的元素不会影响到其他环境中的布局，所以BFC内的外边距不与外部的外边距发生重叠。 再看看下面的列子： 12345678910111213141516171819&lt;section id=&quot;layout&quot;&gt; &lt;style media=&quot;screen&quot;&gt; #layout &#123; background: red; &#125; #layout .left &#123; float: left; width: 100px; height: 100px; background: pink; &#125; #layout .right &#123; height: 110px; background: #ccc; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/section&gt; 效果如下： 写过前端页面的我们肯定遇到过这种情况，这里其实是浮动元素叠在 .right 元素的上面，如果我们想让.right元素不会延伸到 float元素怎么办,其实我们在.right元素上加 overflow:hidden （用其他的方式创建BFC也可以）创建BFC就可以解决。因为BFC不会与浮动元素发生重叠。 还有一种情况很常见，就是由于子元素浮动，导致父元素的高度不会把浮动元素算在内，那么我们在父元素创建BFC就可以让可以让浮动元素也参与高度计算。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"}]},{"title":"居中","slug":"居中","date":"2021-06-26T03:39:02.000Z","updated":"2021-06-26T05:43:44.419Z","comments":true,"path":"2021/06/26/居中/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E5%B1%85%E4%B8%AD/","excerpt":"","text":"居中 水平居中行内元素水平居中1234// 父元素text-align：center；// 子元素display：inline-block； margin1margin：0 auto； flex12display：flex；justify-context：center； div居中flex居中12display：flex；justify-context：center； 向上50%向下50%减去自身一半距离 123top: 50%; left: 50%; transform: translate(-50%, -50%); margin1margin：0 auto； table-celltable-cell会破坏css属性不要和float，position：absolute一起使用 123display: table-cell; text-align: center;/*使元素水平居中 */ vertical-align: middle;/*使元素垂直居中 */","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"}]},{"title":"布局","slug":"布局","date":"2021-06-26T03:32:03.000Z","updated":"2021-06-26T03:36:44.787Z","comments":true,"path":"2021/06/26/布局/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E5%B8%83%E5%B1%80/","excerpt":"","text":"三栏布局 圣杯布局1.首先把left、middle、right都放出2.给它们三个设置上float: left, 脱离文档流；3.一定记得给container设置上overflow：hidden; 可以形成BFC撑开文档4.left、right设置上各自的宽度5.middle设置width: 100%;6.给left、middle、right设置position: relative;7.left设置 left: -leftWidth, right设置 right: -rightWidth;8.container设置padding: 0, rightWidth, 0, leftWidth;9.给left、middle、right设置padding-bottom: 9999px; margin-bottom: -9999px;（无限高） 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;圣杯布局&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .container&#123; overflow: hidden; padding: 0 220px 0 200px; &#125; .left, .right, .middle&#123; float: left; position: relative; min-height: 130px; word-break: break-all; &#125; .middle&#123; width: 100%; background-color: aqua; &#125; .left&#123; margin-left: -100%; left: -200px; width: 200px; background-color: blue; &#125; .right&#123; margin-left: -220px; right: -220px; width: 220px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;h4&gt;middle&lt;/h4&gt; &lt;p&gt; middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt; &lt;h4&gt;left&lt;/h4&gt; &lt;p&gt; leftleftleftleftleftleftleftleftleftleftleftleft &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;h4&gt;right&lt;/h4&gt; &lt;p&gt; rightrightrightrightrightrightrightrightrightright &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;双飞翼布局&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .header, .footer &#123; height: 100px; line-height: 100px; background-color: green; text-align: center; font-size: 30px; font-weight: bolder; &#125; .footer &#123; background-color: goldenrod; &#125; .container &#123; overflow: hidden; padding: 0, 220px, 0, 200px; &#125; .left, .middle, .right &#123; float: left; min-height: 130px; word-break: break-all; padding-bottom: 9999px; margin-bottom: -9999px; &#125; .left &#123; margin-left: -100%; width: 200px; background-color: red; &#125; .right &#123; margin-left: -220px; width: 220px; background-color: green; &#125; .middle &#123; width: 100%; height: 100%; background-color: blue; &#125; .inner &#123; margin: 0 220px 0 200px; min-height: 130px; background: blue; word-break: break-all; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;h4&gt;middle&lt;/h4&gt; &lt;p&gt;middlemiddlemiddlemiddlemiddle &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt; &lt;h4&gt;left&lt;/h4&gt; &lt;p&gt;leftleftleftleftleftleftleftleftleftleftleftleft &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;h4&gt;right&lt;/h4&gt; &lt;p&gt;rightrightrightrightrightrightright &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"}]},{"title":"flex","slug":"flex","date":"2021-06-26T03:30:01.000Z","updated":"2021-06-26T03:31:43.009Z","comments":true,"path":"2021/06/26/flex/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/flex/","excerpt":"","text":"Flex使用 容器属性flex-direction: 主轴方向,flex-wrap: 是否换行,flex-flow: flex-direction与flex-wrap的简写,justify-content: 主轴的对齐方式,algin-items: 交叉轴的对齐方式,align-content: 多根轴线的对齐方式","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"}]},{"title":"new操作符","slug":"new操作符","date":"2021-06-26T03:16:27.000Z","updated":"2021-06-26T12:51:17.200Z","comments":true,"path":"2021/06/26/new操作符/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/new%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"new操作符做了哪些事情 用new操作符调用构造函数实际上会经历以下5个步骤:​ (1). 创建一个新的对象;​ (2). 将构造函数的prototype关联到实例的__proto__;​ (3). 将构造函数的作用域赋给新对象(因此this就指向了这个新对象);​ (4). 执行构造函数中的代码(为这个新对象添加属性);​ (5). 返回新对象;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"}]},{"title":"map和forEach的区别","slug":"map和forEach的区别","date":"2021-06-26T03:15:46.000Z","updated":"2021-06-26T03:24:33.514Z","comments":true,"path":"2021/06/26/map和forEach的区别/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"map和forEach的区别 forEach()forEach()方法不会返回执行结果，也就是说forEach会修改原来的数组 mapmap()会得到一个新的数组并返回，不会修改原来的数组 (声明一个新的变量来储存map的结果而不是去修改原数组)","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://andylinwenqin.github.io/tags/JS/"}]},{"title":"JS的获取，更新，添加，删除","slug":"JS的获取，更新，添加，删除","date":"2021-06-26T03:15:27.000Z","updated":"2021-06-26T03:23:14.151Z","comments":true,"path":"2021/06/26/JS的获取，更新，添加，删除/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/JS%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E6%B7%BB%E5%8A%A0%EF%BC%8C%E5%88%A0%E9%99%A4/","excerpt":"","text":"JS对节点的操作 获取123456document.getElementById() // 获取唯一的节点document.getElementsByTagName ();document.getElementsByClassName(); // 都是获取一组节点document.querySelector() // 返回文档中匹配指定CSS选择器的第一个元素document.querySelectorAll() 更新修改节点的文本 innerHTML和innerText 插入12345// 插入parentElement.insertBefore(newElement, referenceElement)// 插入到最后parentElement.insertBefore(newElement, referenceElement) 删除1parentElement.removeChild(deleteElement)","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://andylinwenqin.github.io/tags/JS/"}]},{"title":"Vue的双向绑定","slug":"Vue的双向绑定","date":"2021-06-26T02:28:04.000Z","updated":"2021-06-26T04:29:19.785Z","comments":true,"path":"2021/06/26/Vue的双向绑定/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","excerpt":"","text":"Vue数据的双向绑定 什么是数据的双向绑定Vue是一个MVVM框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是vue的精髓之处了。值得注意的是，我们所说的数据双向绑定，一定是对于UI控件来说的，非UI控件不会涉及到数据双向绑定。 为什么要实现数据的双向绑定？在Vue中，如果使用Vuex，实际上数据还是单向的，之所以说是数据双向绑定，这是对于的UI控件来说，对于我们处理表单，Vue的双向数据绑定用起来就特别舒服了。 即两者并不互斥， 在全局性数据流使用单向，方便跟踪； 局部性数据流使用双向，简单易操作。 如何实现双向绑定？Vue是通过“数据劫持”+“发布-订阅模式”实现数据的双向绑定的。 “订阅-发布”模式：Watcher：用于订阅事件。该类中主要包含： 我们将实例化的一个个Wacher对象比作一个个的顾客 1.在构造函数中创建一个回调（其中包含着根据最新的数据重新渲染界面的方法）。 因为回调中包含了渲染页面的方法，我们就将回调比作顾客想要做某件事的方法（例如看书的方法）2.update：在这个方法中，可以拿到最新的数据，然后触发回调。（该方法供给Dep的notify方法来控制调用执行） 将获取最新数据比作拿到书，触发回调比作用上面的看书的方法来看书 Dep：主要作用是进行依赖收集，触发所收集的依赖。该类中主要包含： 我们将Dep比作一个咖啡馆 1.[ ] ：一个数组，专门存放所有的订阅者信息。这个数组中包含了一个个的订阅信息，就像咖啡馆坐着一个个想要看书、聊天、玩游戏的人，他们知道自己想做什么，但是要等到notify方法执行的时候，轮到自己了才可以做2.add：向数组添加订阅。 比作向咖啡馆拉有事要做的人，让他们在咖啡馆做3.notify：循环触发数组的每个订阅信息，向DOM发布通知（其中就包含执行每个订阅的update和保存在其中的回调函数）。让每桌的顾客，按顺序地来做他们想做的事。第一桌的顾客先看书，看完第二桌的顾客去聊天，聊完第三桌的顾客去玩游戏。 简单实现12345678910111213var obj = &#123;&#125;;Object.defineProperty(obj,&quot;name&quot;,&#123; get:function()&#123; console.log(&quot;get方法被调用了&quot;); return name; &#125;, set:function(val)&#123; name = val; console.log(&quot;set方法被调用了，参数是&quot;+val); &#125;&#125;);obj.name=&quot;张三&quot;;console.log(obj.name); 总结大佬Vue双向绑定总结","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"Es6新增内容","slug":"ES6新增内容","date":"2021-06-26T02:16:53.000Z","updated":"2021-06-26T12:52:07.176Z","comments":true,"path":"2021/06/26/ES6新增内容/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/ES6%E6%96%B0%E5%A2%9E%E5%86%85%E5%AE%B9/","excerpt":"","text":"ES6新增内容归纳总结 1.let块级作用域 const常量2.箭头函数3.解构赋值4.class继承 语法糖不是一个面向对象编程语言5.map, set, WeakMap, WeakSet ;WeakMap, WeakSet作为属性键的对象如果没有别的变量引用他们，则会被回收释放掉6.扩展运算符 …rest7.import导入模块 export导出模块8.模板字符串 反斜杠9.promise","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"}]},{"title":"数组扁平化","slug":"数组扁平化","date":"2021-06-26T02:10:07.000Z","updated":"2021-06-26T02:16:24.160Z","comments":true,"path":"2021/06/26/数组扁平化/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/","excerpt":"","text":"数组扁平(拍平) 调用数组的toString或者join方法，将数组变为字符串然后再用split分割还原为数组123456function flatten(arr) &#123; return arr.toString().split(&#x27;,&#x27;).map( function(item) &#123; return Number(item); &#125;)&#125; 递归实现1234567891011function flatten(arr) &#123; var res = []; arr.map(item =&gt; &#123; if(Array.isArray(item)) &#123; res = res.concat(flatten(item)); &#125; else &#123; res.push(item); &#125; &#125;); return res;&#125; 扩展运算符123456function flatten(arr) &#123; while(arr.some(item=&gt;Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; reduce实现12345function flatten(arr) &#123; return arr.reduce((result, item)=&gt; &#123; return result.concat(Array.isArray(item) ? flatten(item) : item); &#125;, []);&#125;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"基础算法","slug":"基础算法","permalink":"https://andylinwenqin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"防抖和节流","slug":"防抖和节流","date":"2021-06-25T15:36:37.000Z","updated":"2021-06-26T02:07:20.634Z","comments":true,"path":"2021/06/25/防抖和节流/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/25/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖与节流 防抖所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。 12345678910111213141516171819202122232425function debounce(fn, delay) &#123; // 维护一个timer，用来记录当前函数的执行状态 let timer = null; return function() &#123; // 通过this和arguments获取函数的作用域和变量 let context = this; let args = arguments // 清理正在执行的函数，并重新执行 clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args) &#125;, delay) &#125;&#125;let flag = 0; // 记录当前函数调用次数// 当用户滚动时被调用的函数function foo() &#123; flag += 1 console.log(&#x27;Number of calls: %d&#x27;, flag)&#125;// 在 debounce 中包装我们的函数，过 2 秒触发一次documenet.body.addEventListener(&#x27;scroll&#x27;, debounce(foo, 2000)) 节流所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率 节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。 123456789function debounce(fn) &#123; let timeout = null return function ()&#123; clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, 500) &#125;&#125; 总结 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。代码实现重在清零 clearTimeout 节流：控制流量，单位时间内事件只能触发一次，如果服务器端的限流即 Rate Limit。代码实现重在开锁关锁 timer=timeout; timer=null","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"排序","slug":"排序","date":"2021-06-25T13:37:37.000Z","updated":"2021-06-26T02:09:14.237Z","comments":true,"path":"2021/06/25/排序/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/25/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序 快速排序123456789101112131415161718192021function jsQuickSort(array) &#123; if (array.length &lt;= 1) &#123; return array; &#125; const pivotIndex=Math.floor(array.length / 2); const pivot = array.splice(pivotIndex, 1)[0]; //从数组中取出我们的&quot;基准&quot;元素 const left = [],right = []; array.forEach((item) =&gt; &#123; if (item &lt; pivot) &#123; //left 存放比 pivot 小的元素 left.push(item); &#125; else &#123; //right 存放大于或等于 pivot 的元素 right.push(item); &#125; &#125;); //至此，我们将数组分成了left和right两个部分 return jsQuickSort(left).concat(pivot, jsQuickSort(right)); //分而治之&#125;const arr = [98, 42, 25, 54, 15, 3, 25, 72, 41, 10, 121];console.log(jsQuickSort(arr)); //输出：[ 3, 10, 15, 25, 25, 41, 42, 54, 72, 98, 121 ] 冒泡排序12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; var temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 原生自带sort1arr.sort（）","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"基础算法","slug":"基础算法","permalink":"https://andylinwenqin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"数组去重","slug":"数组去重","date":"2021-06-25T11:29:33.000Z","updated":"2021-06-26T02:09:31.016Z","comments":true,"path":"2021/06/25/数组去重/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/25/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"数组去重 var arr = arr1.concat(arr2) // 合并数组 ES6 set用法转换对象，在转回数组123function uq(arr1，arr2) &#123; return Array.from(new Set(arr));&#125; Object键值对去重12345678910111213141516var toObject = function (array) &#123; var obj = &#123;&#125;; length = array.length; for (var i = 0; i &lt; length; i++) &#123; obj[array[i]] = true; &#125; return obj;&#125;;var toArray = function (obj) &#123; var arr = []; for (var i in obj) &#123; arr.push(i); &#125; return arr;&#125;;console.log(toArray(toObject(arr))); indexOf循环去重123456789function find(arr) &#123; var result = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) == -1) &#123; result.push(arr[i]); &#125; &#125;&#125; find(arr);","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"基础算法","slug":"基础算法","permalink":"https://andylinwenqin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"vue","slug":"vue","permalink":"https://andylinwenqin.github.io/tags/vue/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"},{"name":"CSS","slug":"CSS","permalink":"https://andylinwenqin.github.io/tags/CSS/"},{"name":"工作积累","slug":"工作积累","permalink":"https://andylinwenqin.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"},{"name":"Linux","slug":"Linux","permalink":"https://andylinwenqin.github.io/tags/Linux/"},{"name":"小程序","slug":"小程序","permalink":"https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"通信机制","slug":"通信机制","permalink":"https://andylinwenqin.github.io/tags/%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"},{"name":"html&浏览器","slug":"html-浏览器","permalink":"https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"协议","slug":"协议","permalink":"https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"JS","slug":"JS","permalink":"https://andylinwenqin.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"},{"name":"性能优化","slug":"性能优化","permalink":"https://andylinwenqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"git","slug":"git","permalink":"https://andylinwenqin.github.io/tags/git/"},{"name":"基础算法","slug":"基础算法","permalink":"https://andylinwenqin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]}