{"meta":{"title":"Andylin's Blog","subtitle":"永无止境，奋斗不息","description":"个人知识积累","author":"林文钦","url":"https://andylinwenqin.github.io","root":"/andylin.github.io/"},"pages":[{"title":"","date":"2021-06-25T14:36:23.055Z","updated":"2021-06-25T14:36:23.055Z","comments":true,"path":"-data/link.json","permalink":"https://andylinwenqin.github.io/-data/link.json","excerpt":"","text":"null"},{"title":"友情链接","date":"2021-06-25T14:22:28.000Z","updated":"2021-06-25T14:40:58.893Z","comments":true,"path":"link/index.html","permalink":"https://andylinwenqin.github.io/link/index.html","excerpt":"","text":""},{"title":"about","date":"2021-06-26T07:20:25.000Z","updated":"2021-06-26T07:21:07.967Z","comments":true,"path":"about/index.html","permalink":"https://andylinwenqin.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-06-23T10:32:03.000Z","updated":"2021-06-25T15:28:00.560Z","comments":true,"path":"categories/index.html","permalink":"https://andylinwenqin.github.io/categories/index.html","excerpt":"","text":""},{"title":"时间轴","date":"2021-06-25T15:22:45.000Z","updated":"2021-06-25T15:28:30.333Z","comments":true,"path":"archives/index.html","permalink":"https://andylinwenqin.github.io/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-23T10:31:55.000Z","updated":"2021-06-25T14:40:33.896Z","comments":true,"path":"tags/index.html","permalink":"https://andylinwenqin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序基础API的使用","slug":"小程序基础API的使用","date":"2021-07-17T14:14:41.000Z","updated":"2021-07-18T11:13:36.185Z","comments":true,"path":"2021/07/17/小程序基础API的使用/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80API%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"基础API的使用 路由wx.switchTab(Object object)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的 tabBar 页面的路径 (代码包路径)（需在 app.json 的 tabBar 字段定义的页面），路径后不能带参数。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123456789101112// app.json&#123; &quot;tabBar&quot;: &#123; &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;,&#123; &quot;pagePath&quot;: &quot;other&quot;, &quot;text&quot;: &quot;其他&quot; &#125;] &#125;&#125; 123wx.switchTab(&#123; url: &#x27;/index&#x27;&#125;) wx.reLaunch(Object object)关闭所有页面，打开到应用内的某个页面 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的应用内页面路径 (代码包路径)，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’ success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123wx.reLaunch(&#123; url: &#x27;test?id=1&#x27;&#125;) 123456// testPage(&#123; onLoad (option) &#123; console.log(option.query) &#125;&#125;) wx.redirectTo(Object object)关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 ‘path?key=value&amp;key2=value2’ success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123wx.redirectTo(&#123; url: &#x27;test?id=1&#x27;&#125;) wx.navigateTo(Object object)保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。 参数 属性 类型 默认值 必填 说明 url string 是 需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 ‘path?key=value&amp;key2=value2’ events Object 否 页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.success 回调函数 属性 类型 说明 eventChannel EventChannel 和被打开页面进行通信 示例代码1234567891011121314151617wx.navigateTo(&#123; url: &#x27;test?id=1&#x27;, events: &#123; // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function(data) &#123; console.log(data) &#125;, someEvent: function(data) &#123; console.log(data) &#125; ... &#125;, success: function(res) &#123; // 通过eventChannel向被打开页面传送数据 res.eventChannel.emit(&#x27;acceptDataFromOpenerPage&#x27;, &#123; data: &#x27;test&#x27; &#125;) &#125;&#125;) 12345678910111213//test.jsPage(&#123; onLoad: function(option)&#123; console.log(option.query) const eventChannel = this.getOpenerEventChannel() eventChannel.emit(&#x27;acceptDataFromOpenedPage&#x27;, &#123;data: &#x27;test&#x27;&#125;); eventChannel.emit(&#x27;someEvent&#x27;, &#123;data: &#x27;test&#x27;&#125;); // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据 eventChannel.on(&#x27;acceptDataFromOpenerPage&#x27;, function(data) &#123; console.log(data) &#125;) &#125;&#125;) wx.navigateBack(Object object) 以 Promise 风格 调用：支持 需要页面权限：小程序不能在插件页面中调用该接口，插件也不能在小程序页面中调用该接口 小程序插件：支持，需要小程序基础库版本不低于 2.1.0 在小程序插件中使用时，只能在当前插件的页面中调用 微信 Windows 版：支持 微信 Mac 版：支持 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。 参数 属性 类型 默认值 必填 说明 delta number 1 否 返回的页面数，如果 delta 大于现有页面数，则返回到首页。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码12345678910111213141516// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码// 此处是A页面wx.navigateTo(&#123; url: &#x27;B?id=1&#x27;&#125;)// 此处是B页面wx.navigateTo(&#123; url: &#x27;C?id=1&#x27;&#125;)// 在C页面内 navigateBack，将返回A页面wx.navigateBack(&#123; delta: 2&#125;) 跳转wx.navigateToMiniProgram(Object object)打开另一个小程序 参数 属性 类型 默认值 必填 说明 appId string 是 要打开的小程序 appId path string 否 打开的页面路径，如果为空则打开首页。path 中 ? 后面的部分会成为 query，在小程序的 App.onLaunch、App.onShow 和 Page.onLoad 的回调函数或小游戏的 wx.onShow 回调函数、wx.getLaunchOptionsSync 中可以获取到 query 数据。对于小游戏，可以只传入 query 部分，来实现传参效果，如：传入 “?foo=bar”。 extraData object 否 需要传递给目标小程序的数据，目标小程序可在 App.onLaunch，App.onShow 中获取到这份数据。如果跳转的是小游戏，可以在 wx.onShow、wx.getLaunchOptionsSync 中可以获取到这份数据数据。 envVersion string release 否 要打开的小程序版本。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.envVersion 的合法值 值 说明 最低版本 develop 开发版 trial 体验版 release 正式版 使用限制需要用户触发跳转从 2.3.0 版本开始，若用户未点击小程序页面任意位置，则开发者将无法调用此接口自动跳转至其他小程序。 需要用户确认跳转从 2.3.0 版本开始，在跳转至其他小程序前，将统一增加弹窗，询问是否跳转，用户确认后才可以跳转其他小程序。如果用户点击取消，则回调 fail cancel。 无需声明跳转名单，不限跳转数量（众测中） 从2020年4月24日起，使用跳转其他小程序功能将无需在全局配置中声明跳转名单，调用此接口时将不再校验所跳转的 AppID 是否在 navigateToMiniProgramAppIdList 中。 从2020年4月24日起，跳转其他小程序将不再受数量限制，使用此功能时请注意遵守运营规范。 运营规范平台将坚决打击小程序盒子等互推行为，使用此功能时请严格遵守《微信小程序平台运营规范》，若发现小程序违反运营规范将被下架处理。 关于调试 在开发者工具上调用此 API 并不会真实的跳转到另外的小程序，但是开发者工具会校验本次调用跳转是否成功。详情 开发者工具上支持被跳转的小程序处理接收参数的调试。详情 示例代码1234567891011wx.navigateToMiniProgram(&#123; appId: &#x27;&#x27;, path: &#x27;page/index/index?id=123&#x27;, extraData: &#123; foo: &#x27;bar&#x27; &#125;, envVersion: &#x27;develop&#x27;, success(res) &#123; // 打开成功 &#125;&#125;) wx.navigateBackMiniProgram(Object object)返回到上一个小程序。只有在当前小程序是被其他小程序打开时可以调用成功 注意：微信客户端 iOS 6.5.9，Android 6.5.10 及以上版本支持 参数 属性 类型 默认值 必填 说明 extraData Object {} 否 需要返回给上一个小程序的数据，上一个小程序可在 App.onShow 中获取到这份数据。 详情。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码12345678wx.navigateBackMiniProgram(&#123; extraData: &#123; foo: &#x27;bar&#x27; &#125;, success(res) &#123; // 返回成功 &#125;&#125;) wx.exitMiniProgram(Object object)退出当前小程序。必须有点击行为才能调用成功。 参数 属性 类型 默认值 必填 说明 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 数据缓存wx.setStorageSync(string key, any data) 以 Promise 风格 调用：支持 小程序插件：支持，需要小程序基础库版本不低于 1.9.6 wx.setStorage 的同步版本 参数string key本地缓存中指定的 key any data需要存储的内容。只支持原生类型、Date、及能够通过JSON.stringify序列化的对象。 示例代码1234wx.setStorage(&#123; key:&quot;key&quot;, data:&quot;value&quot;&#125;) 123try &#123; wx.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;)&#125; catch (e) &#123; &#125; wx.setStorage(Object object) 以 Promise 风格 调用：支持 小程序插件：支持，需要小程序基础库版本不低于 1.9.6 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 参数 属性 类型 默认值 必填 说明 key string 是 本地缓存中指定的 key data any 是 需要存储的内容。只支持原生类型、Date、及能够通过JSON.stringify序列化的对象。 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码1234wx.setStorage(&#123; key:&quot;key&quot;, data:&quot;value&quot;&#125;) 123try &#123; wx.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;)&#125; catch (e) &#123; &#125; wx.getStorage(Object object)从本地缓存中异步获取指定 key 的内容。缓存相关策略请查看 存储。 参数 属性 类型 默认值 必填 说明 key string 是 本地缓存中指定的 key success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.success 回调函数 属性 类型 说明 data any key对应的内容 示例代码123456wx.getStorage(&#123; key: &#x27;key&#x27;, success (res) &#123; console.log(res.data) &#125;&#125;) 12345678try &#123; var value = wx.getStorageSync(&#x27;key&#x27;) if (value) &#123; // Do something with return value &#125;&#125; catch (e) &#123; // Do something when catch error&#125; wx.getStorageInfo(Object object)异步获取当前storage的相关信息。缓存相关策略请查看 存储。 参数 属性 类型 默认值 必填 说明 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.success 回调函数 属性 类型 说明 keys Array. 当前 storage 中所有的 key currentSize number 当前占用的空间大小, 单位 KB limitSize number 限制的空间大小，单位 KB 示例代码1234567wx.getStorageInfo(&#123; success (res) &#123; console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize) &#125;&#125;) 12345678try &#123; const res = wx.getStorageInfoSync() console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize)&#125; catch (e) &#123; // Do something when catch error&#125; wx.clearStorage(Object object)清理本地数据缓存。缓存相关策略请查看 存储。 参数 属性 类型 默认值 必填 说明 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码123456wx.clearStorage()try &#123; wx.clearStorageSync()&#125; catch(e) &#123; // Do something when catch error&#125;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序登录接口的更新","slug":"小程序登录接口的更新","date":"2021-07-17T04:19:31.000Z","updated":"2021-07-17T14:16:19.525Z","comments":true,"path":"2021/07/17/小程序登录接口的更新/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/","excerpt":"","text":"获取用户信息（2021.4.28微信更新） wx.login调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。 object.success 回调函数 属性 类型 说明 code string 用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 auth.code2Session，使用 code 换取 openid、unionid、session_key 等信息 示例代码123456789101112131415wx.login(&#123; success (res) &#123; if (res.code) &#123; //发起网络请求 wx.request(&#123; url: &#x27;https://example.com/onLogin&#x27;, data: &#123; code: res.code &#125; &#125;) &#125; else &#123; console.log(&#x27;登录失败！&#x27; + res.errMsg) &#125; &#125;&#125;) 实际使用代码1234567891011121314151617wx.login(&#123; success: res =&gt; &#123; that.globalData.code = res.code console.log(glo.copy(res)) let u = &#x27;https://golaxy.weiqiai.com:8080/user/authorize&#x27; that.getData(u, &#123; js_code: res.code &#125;) .then(function (r) &#123; console.log(glo.copy(r)) that.globalData.openId = r.openid let session_key = r.session_key; let u = &#x27;https://golaxy.weiqiai.com:8080/user/getUserInfo&#x27; &#125;, function () &#123; success(false) &#125;) // 发送 res.code 到后台换取 openId, sessionKey, unionId &#125;&#125;) 拿到了openId等信息 wx.getUserProfile获取用户信息。页面产生点击事件（例如 button 上 bindtap 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo。该接口用于替换 wx.getUserInfo， 这个函数只能通过点击事件触发 object.success 回调函数 属性 类型 说明 最低版本 userInfo UserInfo 用户信息对象 2.10.4 rawData string 不包括敏感信息的原始数据字符串，用于计算签名 2.10.4 signature string 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，详见 用户数据的签名验证和加解密 2.10.4 encryptedData string 包括敏感数据在内的完整用户信息的加密数据，详见 用户数据的签名验证和加解密 2.10.4 iv string 加密算法的初始向量，详见 用户数据的签名验证和加解密 2.10.4 cloudID string 敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据，详细见云调用直接获取开放数据 2.10.4 示例代码在开发者工具中预览效果 123456789101112&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;userinfo&quot;&gt; &lt;block wx:if=&quot;&#123;&#123;!hasUserInfo&#125;&#125;&quot;&gt; &lt;button wx:if=&quot;&#123;&#123;canIUseGetUserProfile&#125;&#125;&quot; bindtap=&quot;getUserProfile&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;/block&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334Page(&#123; data: &#123; userInfo: &#123;&#125;, hasUserInfo: false, canIUseGetUserProfile: false, &#125;, onLoad() &#123; if (wx.getUserProfile) &#123; this.setData(&#123; canIUseGetUserProfile: true &#125;) &#125; &#125;, getUserProfile(e) &#123; // 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认 // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗 wx.getUserProfile(&#123; desc: &#x27;用于完善会员资料&#x27;, // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写 success: (res) =&gt; &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125;, getUserInfo(e) &#123; // 不推荐使用getUserInfo获取用户信息，预计自2021年4月13日起，getUserInfo将不再弹出弹窗，并直接返回匿名的用户个人信息 this.setData(&#123; userInfo: e.detail.userInfo, hasUserInfo: true &#125;) &#125;,&#125;) 实际使用代码123456789101112wx.getUserProfile(&#123; desc: &#x27;test&#x27;,&#125;).then(res =&gt; &#123; let userInfo = res.userInfo || &#123;&#125; wx.setStorageSync(&#x27;userInfo&#x27;, userInfo) // that.globalData.userInfo = userInfo this.userInfoSet() success(userInfo) // that.globalData.loged = true&#125;).catch(function (reason) &#123; console.log(reason);&#125;); 个人理解虽然微信这个变动让很多小程序开发者苦不堪言，但是还是很方便的，之前的方式是wx.login获取code给wx.getUserInfo去拿取session_key和openid，然后传给后端，后端去请求用户个人信息，对此很多程序员都封装了组件，类似套娃的方法去实现。 在这次更新后，wx.getUserProfile取缔wx.getUserInfo，wx.getUserProfile必须用点击事件触发例如bindtap(),之前的’套娃组件‘也都要废弃，改成了更加简单的方式，封装一个函数，在app.js页面一开始调用wx.login获取openid。然后在写一个button点击事件bindtap()调用wx.getUserProfile获取以下信息 然后前端在调用接口传个后端存进数据库","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://andylinwenqin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"单工,半双工,全双工三者区别","slug":"单工-半双工-全双工三者区别","date":"2021-07-11T07:10:38.000Z","updated":"2021-07-11T07:15:35.137Z","comments":true,"path":"2021/07/11/单工-半双工-全双工三者区别/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/11/%E5%8D%95%E5%B7%A5-%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%85%A8%E5%8F%8C%E5%B7%A5%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/","excerpt":"","text":"单工 半双工 全双工三者区别 单工单工就是指A只能发信号，而B只能接收信号，通信是单向的，就象灯塔之于航船-灯塔发出光信号而航船只能接收信号以确保自己行驶在正确的航线上。 半双工（Half Duplex）半双工就是指A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。最典型的例子就象我们在影视作品中看到的对讲机一样： 007：呼叫总部，请求支援，OVER 总部：收到，增援人员将在5分钟内赶到，OVER 007：要5分钟这么久？！要快呀！OVER 总部：„„ 在这里，每方说完一句话后都要说个OVER，然后切换到接收状态，同时也告之对方-你可以发言了。如果双方同时处于收状态，或同时处于发状态，便不能正常通信了。 全双工 （Full Duplex）全双工比半双工又进了一步。在A给B发信号的同时，B也可以给A发信号。典型的例子就是打电话。A：我跟你说呀„„B：你先听我说，情况是这样的„„A和B在说的同时也能听到对方说的内容，这就是全双工。 相关链接原文链接","categories":[],"tags":[{"name":"通信机制","slug":"通信机制","permalink":"https://andylinwenqin.github.io/tags/%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"}]},{"title":"Stomp","slug":"STOMP","date":"2021-07-06T11:12:57.000Z","updated":"2021-07-17T03:15:40.158Z","comments":true,"path":"2021/07/06/STOMP/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/06/STOMP/","excerpt":"","text":"学习血汗史查了各类资料花了整整三天才学通，又被跨域卡了一天，直到第五天才完完全全跑通，下一步学习emoji的表情包用法 stomp over websocket协议原理http协议http协议是单工的, 只能由client发请求再由server返回请求结果, 在http协议中server是不能主动发请求到client的. 大多数情况下http协议都是适用的, 但当遇到在线聊天, 股票行情这样需要实时获取取服务端信息的应用时, client需要频繁轮询server过程如下: client 建立连接client 问server有没有新的消息, 并根据返回结果进行处理client 关闭连接client 建立连接client 问server有没有新的消息, 并根据返回结果进行处理client 关闭连接… 为了拿到最新信息, client一直这样循环下去server如果一直没有新的消息, client的大多请求都是无效的, 效率低下. 为了提高效率需要有一种协议可以让server主动发消息给client.这样就不需要client频繁轮询, 只要server有新消息就会主动推送给client. 这种协议就是websocket协议(效果：服务端主动向客户端发送信息). websocket协议webSocket协议是基于TCP的一种网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。在webscoket协议中, client利用http来建立tcp连接, 建立tcp连接之后, client与server就可以基于tcp连接来愉快的进行通信了. 那么webscoket如何利用http建立连接的呢? 先看一个经典图示 建立连接client与server是利用http的一次request, response来建立连接的.其中http request消息体如下: 1234567GET /echo HTTP/1.1Host:jingxu.test.com:8100Origin:http://jingxu.test.com:8099Sec-WebSocket-Extensions:permessage-deflate; client_max_window_bitsSec-WebSocket-Key:rVX0XFeQzA9QVXXEfjm0yw==Sec-WebSocket-Version:13Upgrade:websocket 其中前三个header:Get, Host, Origin都是http协议之前就有, 不多做解释, 主要解释一下后面这几个headerSec-WebSocket-Extensions: 用于对websocket协议进行扩展. 比如websocket协议本身不支持压缩, 但可以通过Sec-WebSocket-Extensions中的permessage-deflate来协商压缩.Sec-WebSocket-Key:client随机生成的一段key. 详情之后response中Sec-WebSocket-Accept的解释.Sec-WebSocket-Version:协议的版本号Upgrade:通过http的Upgrade对协议进行切换. 告诉server, 建立连接后用websocket协议. http response消息体如下: 12345Connection:upgradeDate:Mon, 04 Dec 2017 10:05:18 GMTSec-WebSocket-Accept:q3dUKg4lRGCqqRhGIvmE7sH8Yuc=Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits=15Upgrade:websocket Connection与Date都是http协议之前就有的header, 主要解释一下后面的.Sec-WebSocket-Accept:对应于request中的Sec-WebSocket-Key.server会根据request中的Sec-WebSocket-Key的值来生成response中的Sec-WebSocket-Accept的值.具体的算法是根据Sec-WebSocket-Key与协议中已定义的一个guid “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”进行拼接再对结果进行sha1, 再对sha1的结果进行base64, 最后得到Sec-WebSocket-Accept的值. client通过验证server返回的Sec-WebSocket-Accept的值, 来确定两件事情:server理解websocket协议.如果server不理解, 那么server不会返回正确的Sec-WebSocket-Accept.如果server没有返回正确的Sec-WebSocket-Accept, 那么建立websocket连接失败. server返回的response是对于client的此次reuqest的响应而不是之前的缓存.主要是防止有些缓存服务器返回缓存的response. 发送数据现在websocket连接已经建立, 由于websocket没有规范payload的格式, 所以应用需要自己去定义payload的格式. websocket的payload可以是文本也可以是二进制.应用一般会选择用文本.这个文本是什么格式websocket协议本身并没有规定, 由应用自己来定. 比如我要请求发送消息这个接口, 那么我的payload可以写成: /send | params=我是消息 这里我自己定义了一个格式, 中坚线之前的是要调用的地址, 中竖线之后是参数.由于格式是自己定义的, 所以在服务端我也需要自己写代码来解析这个格式.把/send路由到相应的处理方法. 那有没有一种统一的协议呢? 统一的标准呢?因为这样就会有相应的已经实现的库来解析路由, 而不用自己去写, 自己去定义格式. 这个统一的协议就是stomp协议(一个基于webSocket的通信协议或者说一种标准). stomp协议stomp是一个用于client之间进行异步消息传输的简单文本协议, 全称是Simple Text Oriented Messaging Protocol. 对于stomp协议来说, client分为消费者client与生产者client两种. server是指broker, 也就是消息队列的管理者. stomp协议并不是为websocket设计的, 它是属于消息队列的一种协议, 和amqp, jms平级.只不过由于它的简单性恰巧可以用于定义websocket的消息体格式.stomp协议很多mq都已支持, 比如rabbitmq, activemq. 很多语言也都有stomp协议的解析client库. 可以这么理解, websocket结合stomp相当于一个面向公网对用户比较友好的一种消息队列. stomp协议中的client分为两角色: 生产者: 通过SEND命令给某个目的地址(destination)发送消息. 消费者: 通过SUBSCRIBE命令订阅某个目的地址(destination), 当生产者发送消息到目的地址后, 订阅此目的地址的消费者会即时收到消息. stomp协议的结构与http结构相似, 结构如下: 12345COMMANDheader1:value1 header2:value2 Body^@ 其中^@代表null结尾. 与http相似有三部分组成: 命令, header, 消息体.命令与header使用utf-8格式, body可以是二进制也可以是文本. 命令有SEND, SUBSCRIBE, MESSAGE, CONNECT, CONNECTED等. header类似http有content-length, content-type等.消息体类似http可以是二进制也可以是文本. 下面例举一些主要命令和http, websocket类似, 首先要确认双方都懂stomp这个协议, 通过建立连接来确认.由于我们已经建立了webscoket连接, 接下来我只需要在webscoket连接的基础上建立stomp连接. 将以下内容写到websocket的payload中, 来发送建立stomp连接请求 12345CONNECTaccept-version:1.2host:stomp.github.org^@ stomp协议并不与websocket协议耦合, 比如双方建立了tcp连接, 那么完成可以在tcp连接上建立stomp连接, 也就是将上述内容写到tcp的payload中. server收到后回复, 同样以下内容是在server回复的websocket的消息体中 1234CONNECTEDversion:1.2 ^@ 这样一个stomp连接就建立了, 协议版本为1.2. 由于stomp连接是一个长连接, stomp协议定义了发送心跳来监测stomp连接是否存活. 在CONNECT命令消息中加入heart-beat心跳header来建立连接就开启了心跳: 123456CONNECT accept-version:1.2 heart-beat:&lt;cx&gt;,&lt;cy&gt; host:stomp.github.org ^@ 12345CONNECTED version:1.2heart-beat:&lt;sx&gt;,&lt;sy&gt;^@ 其中&lt;cx&gt;, &lt;cy&gt;, &lt;sx&gt;, &lt;sy&gt;分别代表一个以毫秒为单位的数字. client发送的CONNECT命令消息中的&lt;cx&gt;,&lt;cy&gt;分别代表: &lt;cx&gt;:client能保证的发送心跳的最小间隔, 如果是0代表client不发送心跳.&lt;cy&gt;:client希望收到server心跳的间隔, 如果是0代表client不希望收到server的心跳.与client类似, server发送的CONNECTED命令消息中的,分别代表: &lt;sx&gt;:server能保证的发送心跳的最小间隔, 如果是0代表server不发送心跳. &lt;sy&gt;:server希望收到client心跳的间隔, 如果是0代表server不希望收到client的心跳 如果在建立连接时没有心跳header, 默认当作heart-beat:0,0. 也就是不发心跳, 也不希望对方发心跳. 加入心跳header进行连接后, 最终协商得出发送心跳的频率的逻辑如下:对于client来说, 取与的最大值, 也就是说client会取client最小能发送的间隔与server希望client发送间隔的最大值来发送心跳.如果或中任何一个为0, client都不发送心跳. 类似, 对于server来说, 取与的最大值, 也就是说server取server最小能发送的间隔与client希望server发送间隔的最大值来发送心跳.如果或中任何一个为0, server都不发送心跳. 举个例子, 如下建立连接 123456CONNECTaccept-version:1.2heart-beat:1000,2000host:stomp.github.org^@123456 12345CONNECTEDversion:1.2heart-beat:3000,4000^@ 上述, client发送CONNECT命令消息中heart-beat为1000, 2000.解释为client最小能保证发送心跳间隔为1000毫秒, 希望server发送心跳间隔为2000毫秒 server回复的CONNECTED命令消息中heart-beat为3000,4000解释为server最小能保证发送心跳间隔为3000毫秒, 希望client发送心跳间隔为4000毫秒 最终的协商结果, client取自己能保证的最小心跳间隔1000毫秒与server希望client发送心跳间隔4000毫秒的最大值得出client会每4000毫秒发一次心跳, 同理, server取自己能保证的最小心跳间隔3000毫秒与client希望server发送心跳间隔2000毫秒的最大值得出server会每3000毫秒发一次心跳. client和server根据心跳来判定对方已经挂掉了的逻辑如下: 以server为例, 假设经过协商, client每10秒发送一个心跳. client必须在10秒以内给server至少发送一次数据, 不管是心跳还是正常数据.如果在10秒内client未发送数据, 那么server认为与client的stomp连接已经挂掉.现在连接已经建立, 接下来准备发送stomp消息. 发送消息发送消息使用SEND这个COMMAND, 如下: 123456SENDdestination:/topic/a content-type:text/plain hello world^@ 其中destination这个header的值为发送消息的目的地址.上述SEND命令消息的意思为, 给/topic/a这个目的地址发送一条类型为text/plain, 内容是hello world的消息.所有订阅/topic/a这个目的地址的消费者client都会收到hello world这条消息. stomp协议并没有规定destination的格式, 这个是由使用stomp协议的应用自己来定义.比如, /topic/a, /queue/a, queue.a, topic.a, topic-a, queue-a对于stomp协议来说都是正确的.应用可以自己规定不同的格式以及此格式代表的含义.比如, 应用自己可以定义以/topic打头的为发布订阅模式, 消息会被所有消费者client收到,以/queue打头的为负载平衡模式, 只会被一个消费都client收到. client发送SEND命令消息如何确保server收到了这条消息呢? 协议规定, 可以在SEND命令消息中加入receipt header. receipt header的值唯一确定一次send.server收到有receipt header的SEND命令消息后, 需要回复一个RECEIPT命令消息,里面会包含receipt-id header, receipt-id的值就是SEND命令消息中receipt header的值.这样当client收到了这条RECEIPT命令消息后, 就能确定server已收到SEND命令消息. 例如: 12345SENDdestination:/queue/areceipt:message-12345hello queue a^@12345 1234RECEIPTreceipt-id:message-12345^@ 接下来看一下消费者client如何订阅消息. 订阅消息订阅消息用SUBSCRIBE命令, 如下: 123456SUBSCRIBE id:0 destination:/topic/foo ack:client ^@ 上述代表client订阅/topic/foo这个目的地址.其中多了两个新的header: id与ack. 订阅中的id header此id能唯一确定一个订阅.一个client对于一个server可以订阅多次, 甚至对于同一个目的地址都可以订阅多次.为了唯一确定一次订阅, 协议规定必须包含id header, 此id要求在同一连接中唯一. 订阅中的ack headerack header告诉server, server如何确认client已经收到消息.有三个值: auto, client, client-individual auto表示当server发出消息后就立即确认client收到了消息. 也就是说当client收到消息后不会对server进行确认.client表示只有当server收到client的ack后才确认client收到了消息, 也就是说client需要对server发ack进行确认.这个确认是累积的, 意思是说收到某条消息的ack, 那么这条消息之前的所有的消息, server都认为client已收到.client-individual与client类似. 只不过不是累积的. 每收到一条消息都需要给server回复ack来确认. 有订阅消息, 那肯定有取消订阅消息. 取消订阅取消订阅用UNSUBSCRIBE这个命令 1234UNSUBSCRIBEid:0^@ 取消订阅相对来说比较简单只需要传一个id header.这个id header的值来自订阅时id header值. 这样server才能唯一确定到底要取消哪个订阅. 当有生产者client给目的地址发消息后, 首先server会收到消息, server收到消息后会把消息发送给所有订阅这个目的地址的client, 那么server是如何发送这个消息到消费都client的呢? server发送消息server发送消息用MESSAGE这个命令来给client发送消息, 如下 1234567MESSAGEsubscription:0message-id:007destination:/queue/acontent-type:text/plainhello queue a^@ message-id这个header的值能唯一确定一条消息subscription的值就是订阅时SUBSCRIBE命令中id header的值, 表示这条消息属于哪个订阅. 到此, 介绍了一些stomp常用的命令, 还有一些其他命令, 有兴趣可以查看stomp协议文档: 协议总结由于http是一个单工的协议, server不能主动发送消息给client, 导致http在处理实时性要求高的应用时效率不高. 为了提高效率, 我们使用了全双工的websocket协议, 可以让server主动推送消息. 又由于websocket协议是个底层协议, 不是应用层协议, 未对payload的格式进行规范, 导致我们需要自己定义消息体格式, 自己解析消息体, 成本高, 扩展性也不好, 所以我们引入了已被很多库和消息队列厂商实现的stomp协议, 将websocket协议与stomp协议结合. 我们再总结一下websocket与stomp的优点 websocket相对于http的优点:全双工. 相对于http协议只能由client发送消息. 全双工的websocket协议, server与client都可以发送消息.消息体更轻量. http的一个请求比websocket的请求大不少. 主要因为http的每次请求都要加很多的header. stomp over websocket相对于websocket的优点:不需要自己去规定消息的格式, 以及对消息的格式做解析.由于stomp是一个统一的标准, 有很多库与厂商都对stomp协议进行了支持. 拿来用就可以. 成本低, 扩展好.理论到此为止, 接下来我们一起了解下spring websocket是如何实现stomp over websocket协议的. Stomp使用文档(官方文档翻译版)STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议，它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。 创建STOMP客户端在web浏览器中使用普通的Web Socket STOMP javascript 客户端会使用ws://的URL与STOMP 服务端进行交互。 为了创建一个STOMP客户端js对象，你需要使用Stomp.client(url)，而这个URL连接着服务端的WebSocket的代理 12var url = &quot;ws://localhost:61614/stomp&quot;;var client = Stomp.client(url); Stomp.client(url, protocols)也可以用来覆盖默认的subprotocols。第二个参数可以是一个字符串或一个字符串数组去指定多个subprotocols。 在web浏览器中使用定制的WebSocket 浏览器提供了不同的WebSocket的协议，一些老的浏览器不支持WebSocket的脚本或者使用别的名字。默认下，stomp.js会使用浏览器原生的WebSocket class去创建WebSocket。 但是利用Stomp.over(ws)这个方法可以使用其他类型的WebSockets。这个方法得到一个满足WebSocket定义的对象。 例如，可以使用由SockJS实现的Websocket。 如果使用原生的Websockets就使用Stomp.client(url)，如果需要使用其他类型的Websocket（例如由SockJS包装的Websocket）就使用Stomp.over(ws)。除了初始化有差别，Stomp API在这两种方式下是相同的。 在node.js程序中 通过stompjs npm package同样也可以在node.js程序中使用这个库。 1npm install stompjs 在node.js app中，require这个模块：var Stomp = require(&#39;stompjs&#39;); 为了与建立在TCP socket的STOMP-broker连接，使用Stomp.overTCP(host, port)方法。 1var client = Stomp.overTCP(&#x27;localhost&#x27;, 61613); 为了与建立在Web Socket的STOMP broker连接，使用Stomp.overWS(url)方法。 1var client = Stomp.overWS(&#x27;ws://localhost:61614/stomp&#x27;); 除了初始化不同，无论是浏览器还是node.js环境下，Stomp API都是相同的。 连接服务端 一旦Stomp 客户端建立了，必须调用它的connect()方法去连接Stomp服务端进行验证。这个方法需要两个参数，用户的登录和密码凭证。这种情况下，客户端会使用Websocket打开连接，并发送一个CONNECT frame。 这个连接是异步进行的：你不能保证当这个方法返回时是有效连接的。为了知道连接的结果，你需要一个回调函数。 123var connect_callback = function() &#123; // called back after the client is connected and authenticated to the STOMP server&#125;; 但是如果连接失败会发生什么呢？ connect()方法接受一个可选的参数(error_callback)，当客户端不能连接上服务端时，这个回调函数error_callback会被调用，该函数的参数为对应的错误对象。 1234var error_callback = function(error) &#123; // display the error&#x27;s message header: alert(error.headers.message);&#125;; 在大多数情况下，connect()方法可接受不同数量的参数来提供简单的API： 123client.connect(login, passcode, connectCallback);client.connect(login, passcode, connectCallback, errorCallback);client.connect(login, passcode, connectCallback, errorCallback, host); login和passcode是strings，connectCallback和errorCallback则是functions。（有些brokers（代理）还需要传递一个host（String类型）参数。） 如果你需要附加一个headers头部，connect方法还接受其他两种形式的参数： 12client.connect(headers, connectCallback);client.connect(headers, connectCallback, errorCallback); header是map形式，connectCallback和errorCallback为functions。 需要注意：如果你使用上述这种方式，你需要自行在headers添加login、passcode（甚至host）： 1234567var headers = &#123; login: &#x27;mylogin&#x27;, passcode: &#x27;mypasscode&#x27;, // additional header &#x27;client-id&#x27;: &#x27;my-client-id&#x27;&#125;;client.connect(headers, connectCallback); 断开连接时，调用disconnect方法，这个方法也是异步的，当断开成功后会接收一个额外的回调函数的参数。如下所示。 123client.disconnect(function() &#123; alert(&quot;See you next time!&quot;);&#125;; 当客户端与服务端断开连接，就不会再发送或接收消息了。 Heart-beating(心跳) 如果STOMP broker(代理)接收STOMP 1.1版本的帧，heart-beating是默认启用的。 heart-beating也就是频率，incoming是接收频率，outgoing是发送频率。通过改变incoming和outgoing可以更改客户端的heart-beating(默认为10000ms)： 12345client.heartbeat.outgoing = 20000; // client will send heartbeats every 20000msclient.heartbeat.incoming = 0;// client does not want to receive heartbeats// from the server heart-beating是利用window.setInterval()去规律地发送heart-beats或者检查服务端的heart-beats。 发送消息 当客户端与服务端连接成功后，可以调用send()来发送STOMP消息。这个方法必须有一个参数，用来描述对应的STOMP的目的地。另外可以有两个可选的参数：headers，object类型包含额外的信息头部；body，一个String类型的参数。 12client.send(&quot;/queue/test&quot;, &#123;priority: 9&#125;, &quot;Hello, STOMP&quot;);// client会发送一个STOMP发送帧给/queue/test，这个帧包含一个设置了priority为9的header和内容为“Hello, STOMP”的body。 如果你想发送一个有body的信息，也必须传递headers参数。如果没有headers需要传递，那么就传&#123;&#125;即可。 1client.send(destination, &#123;&#125;, body); 订阅（Subscribe）和接收（receive）消息 为了在浏览器中接收消息，STOMP客户端必须先订阅一个目的地destination。 你可以使用subscribe()去订阅。这个方法有2个必需的参数：目的地(destination)，回调函数(callback)；还有一个可选的参数headers。其中destination是String类型，对应目的地，回调函数是伴随着一个参数的function类型。 1var subscription = client.subscribe(&quot;/queue/test&quot;, callback); subscribe()方法返回一个object，这个object包含一个id属性，对应这个这个客户端的订阅ID。 而unsubscribe()可以用来取消客户端对这个目的地destination的订阅。 默认情况下，如果没有在headers额外添加，这个库会默认构建一个独一无二的ID。在传递headers这个参数时，可以使用你自己的ID。 12var mysubid = &#x27;...&#x27;;var subscription = client.subscribe(destination, callback, &#123; id: mysubid &#125;); 这个客户端会向服务端发送一个STOMP订阅帧（SUBSCRIBE frame）并注册回调事件。每次服务端向客户端发送消息时，客户端都会轮流调用回调函数，参数为对应消息的STOMP帧对象（Frame object）。 subscribe()方法，接受一个可选的headers参数用来标识附加的头部。 12var headers = &#123;ack: &#x27;client&#x27;, &#x27;selector&#x27;: &quot;location = &#x27;Europe&#x27;&quot;&#125;;client.subscribe(&quot;/queue/test&quot;, message_callback, headers); 这个客户端指定了它会确认接收的信息，只接收符合这个selector : location = &#39;Europe&#39;的消息。 如果想让客户端订阅多个目的地，你可以在接收所有信息的时候调用相同的回调函数： 12345onmessage = function(message) &#123; // called every time the client receives a message&#125;var sub1 = client.subscribe(&quot;queue/test&quot;, onmessage);var sub2 = client.subscribe(&quot;queue/another&quot;, onmessage) 如果要中止接收消息，客户端可以在subscribe()返回的object对象调用unsubscribe()来结束接收。 123var subscription = client.subscribe(...);...subscription.unsubscribe(); 支持JSON STOMP消息的body必须为字符串。如果你需要发送/接收JSON对象，你可以使用JSON.stringify()和JSON.parse()去转换JSON对象。 确认(Acknowledgment) 默认情况，在消息发送给客户端之前，服务端会自动确认（acknowledged）。 客户端可以选择通过订阅一个目的地时设置一个ack header为client或client-individual来处理消息确认。 在下面这个例子，客户端必须调用message.ack()来通知服务端它已经接收了消息。 123456789var subscription = client.subscribe(&quot;/queue/test&quot;, function(message) &#123; // do something with the message ... // and acknowledge it message.ack(); &#125;, &#123;ack: &#x27;client&#x27;&#125;); ack()接受headers参数用来附加确认消息。例如，将消息作为事务(transaction)的一部分，当要求接收消息时其实代理（broker）已经将ACK STOMP frame处理了。 123var tx = client.begin();message.ack(&#123; transaction: tx.id, receipt: &#x27;my-receipt&#x27; &#125;);tx.commit(); 事务(Transactions) 可以在将消息的发送和确认接收放在一个事务中。 客户端调用自身的begin()方法就可以开始启动事务了，begin()有一个可选的参数transaction，一个唯一的可标识事务的字符串。如果没有传递这个参数，那么库会自动构建一个。这个方法会返回一个object。这个对象有一个id属性对应这个事务的ID，还有两个方法： commit()提交事务 abort()中止事务 在一个事务中，客户端可以在发送/接受消息时指定transaction id来设置transaction。 123456// start the transactionvar tx = client.begin();// send the message in a transactionclient.send(&quot;/queue/test&quot;, &#123;transaction: tx.id&#125;, &quot;message in a transaction&quot;);// commit the transaction to effectively send the messagetx.commit(); 如果你在调用send()方法发送消息的时候忘记添加transction header，那么这不会称为事务的一部分，这个消息会直接发送，不会等到事务完成后才发送。 123456var txid = &quot;unique_transaction_identifier&quot;;// start the transactionvar tx = client.begin();// oops! send the message outside the transactionclient.send(&quot;/queue/test&quot;, &#123;&#125;, &quot;I thought I was in a transaction!&quot;);tx.abort(); // Too late! the message has been sent 调试 有一些测试代码能有助于你知道库发送或接收的是什么，从而来调试程序。 客户端可以将其debug属性设置为一个函数，传递一个字符串参数去观察库所有的debug语句。默认情况，debug消息会被记录在在浏览器的控制台。 1234client.debug = function(str) &#123; // append the debug log to a #debug div somewhere in the page using JQuery: $(&quot;#debug&quot;).append(str + &quot;\\n&quot;);&#125;; 使用情况123var error_callback = function(error) &#123; 第一次连接失败和连接后断开连接都会调用这个函数&#125;; 关闭控制台调试数据：设置client.debug = null 就可以，stompjs会去检测debug是否是函数，不是函数就不会调用输出 个人实例跨域问题（之后专门写一个跨域）首先我没有后端，用的github现成的Java项目，所以需要做跨域请求，在Java中进行了跨域 12345678910/** * 注册STOMP的节点，并映射指定的url * * @param registry */@Overridepublic void registerStompEndpoints(StompEndpointRegistry registry) &#123; // 注册STOMP的endpoint，并指定使用SockJS协议 registry.addEndpoint(StompConstant.STOMP_ENDPOINT).setAllowedOrigins(&quot;*&quot;).withSockJS();&#125; 添加了.setAllowedOrigins(&quot;*&quot;)对所有端口开放 vue项目中做了 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; //配置跨域 &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8080&#x27;,// 实际访问地址和端口号 ws: true, changOrigin: true, //允许跨域 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27;// 使用/api代替Target &#125; &#125;, &#125; &#125;,&#125; 用/api替代实际访问地址 连接服务器并配置心跳1234567891011connect () &#123; var socket = new SockJS(&#x27;/api/xechat&#x27;); this.stompClient = Stomp.over(socket); // 配置stomp // 心跳 this.stompClient.heartbeat.outgoing = 30000; // 客户端不接受服务器心跳检测 this.stompClient.heartbeat.incoming = 0; // 订阅地址 this.sub();&#125;, CONNECT发送连接服务器请求，CONNECTED服务器返回连接情况 订阅服务器地址订阅了四个地址，并在连接成功后返回信息，进行广播 1234567891011121314151617181920212223242526272829303132333435sub () &#123; var _this = this; var user = this.createUser(); this.stompClient.connect(user, function connectCallback (frame) &#123; _this.uid = frame.headers[&#x27;user-name&#x27;]; console.log(&#x27;连接成功&#x27;) // 聊天室订阅 _this.stompClient.subscribe(&#x27;/topic/chatRoom&#x27;, function (data) &#123; console.log(&#x27;订阅成功&#x27;) _this.handleMessage(_this.getData(data.body)); &#125;); // 本地订阅 _this.stompClient.subscribe(&#x27;/user/&#x27; + _this.uid + &#x27;/chat&#x27;, function (data) &#123; _this.handleMessage(_this.getData(data.body)); &#125;); // 错误信息订阅 _this.stompClient.subscribe(&#x27;/user/&#x27; + _this.uid + &#x27;/error&#x27;, function (data) &#123; _this.getData(data.body); &#125;); // 聊天室动态订阅 _this.stompClient.subscribe(&#x27;/topic/status&#x27;, function (data) &#123; var obj = _this.getData(data.body); console.log(&#x27;看这里&#x27;) console.log(obj) _this.handleMessage(obj); _this.showOnlineNum(obj.onlineCount); &#125;); &#125;, function errorCallBack (error) &#123; alert(&#x27;请重新连接！&#x27;); _this.refresh(); &#125;);&#125;, 成功订阅并接受到广播信息 SUBSCRIBE订阅地址 实现进入效果 发送消息1234567891011121314sendMessage (pub, header, data) &#123; this.stompClient.send(pub, header, data);&#125;,//发送信息到聊天室sendToChatRoom () &#123; // 获取发送的内容 var content = document.getElementById(&#x27;sendTxt&#x27;).value; var data = &#123; &quot;message&quot;: content &#125;; var pub = &#x27;/chatRoom&#x27;; data = JSON.stringify(data); this.sendMessage(pub, &#123;&#125;, data);&#125;, SEND发送 MESSAGE接收到广播信息 实现效果 等待补充1.断开自动刷新连接服务器 2.中断订阅地址 3.对事务的理解 相关链接Stomp官方文档 StompJS使用文档总结 stomp over websocket协议原理与实现","categories":[],"tags":[{"name":"html&浏览器","slug":"html-浏览器","permalink":"https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"协议","slug":"协议","permalink":"https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"WebSocket","slug":"Web-Socket","date":"2021-07-02T04:11:54.000Z","updated":"2021-07-17T04:18:57.501Z","comments":true,"path":"2021/07/02/Web-Socket/","link":"","permalink":"https://andylinwenqin.github.io/2021/07/02/Web-Socket/","excerpt":"","text":"WebSocket 教程 WebSocket 是一种网络通信协议，很多高级功能都需要它。 本文介绍 WebSocket 协议的使用方法。 为什么需要 WebSocket？初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 客户端的简单示例WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 123456789101112131415var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) &#123; console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;);&#125;;ws.onmessage = function(evt) &#123; console.log( &quot;Received Message: &quot; + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log(&quot;Connection closed.&quot;);&#125;; 客户端的 APIWebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket(&#x27;ws://localhost:8080&#x27;); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 webSocket.readyStatereadyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; webSocket.onopen实例对象的onopen属性，用于指定连接成功后的回调函数。 123ws.onopen = function () &#123; ws.send(&#x27;Hello Server!&#x27;);&#125; 如果要指定多个回调函数，可以使用addEventListener方法。 123ws.addEventListener(&#x27;open&#x27;, function (event) &#123; ws.send(&#x27;Hello Server!&#x27;);&#125;); webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。 12345678910111213ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener(&quot;close&quot;, function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); webSocket.onmessage实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 123456789ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener(&quot;message&quot;, function(event) &#123; var data = event.data; // 处理数据&#125;); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。 12345678910ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log(&quot;Received data string&quot;); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log(&quot;Received arraybuffer&quot;); &#125;&#125; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 1234567891011// 收到的是 blob 数据ws.binaryType = &quot;blob&quot;;ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = &quot;arraybuffer&quot;;ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; webSocket.send()实例对象的send()方法用于向服务器发送数据。 发送文本的例子。 1ws.send(&#x27;your message&#x27;); 发送 Blob 对象的例子。 1234var file = document .querySelector(&#x27;input[type=&quot;file&quot;]&#x27;) .files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 1234567// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); webSocket.bufferedAmount实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 12345678var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; webSocket.onerror实例对象的onerror属性，用于指定报错时的回调函数。 1234567socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener(&quot;error&quot;, function(event) &#123; // handle error event&#125;); 服务端的实现WebSocket 服务器的实现，可以查看维基百科的列表。 常用的 Node 实现有以下三种。 µWebSockets Socket.IO WebSocket-Node 具体的用法请查看它们的文档，这里不详细介绍了。 WebSocketd下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。 它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。 举例来说，下面是一个 Bash 脚本counter.sh。 123456789#!/bin/bashecho 1sleep 1echo 2sleep 1echo 3 命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。 1$ bash ./counter.sh 现在，启动websocketd，指定这个脚本作为服务。 1$ websocketd --port=8080 bash ./counter.sh 上面的命令会启动一个 WebSocket 服务器，端口是8080。每当客户端连接这个服务器，就会执行counter.sh脚本，并将它的输出推送给客户端。 12345var ws = new WebSocket(&#x27;ws://localhost:8080/&#x27;);ws.onmessage = function(event) &#123; console.log(event.data);&#125;; 上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。 有了它，就可以很方便地将命令行的输出，发给浏览器。 1$ websocketd --port=8080 ls 上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。 更多的用法可以参考官方示例。 Bash 脚本读取客户端输入的例子 五行代码实现一个最简单的聊天服务器 websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务greeter.js。 12345678process.stdin.setEncoding(&#x27;utf8&#x27;);process.stdin.on(&#x27;readable&#x27;, function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write(&#x27;data: &#x27; + chunk); &#125;&#125;); 启动这个脚本的命令如下。 1$ websocketd --port=8080 node ./greeter.js 官方仓库还有其他各种语言的例子。 参考链接 How to Use WebSockets WebSockets - Send &amp; Receive Messages Introducing WebSockets: Bringing Sockets to the Web 本文来自阮一峰的 WebSocker仅作为学习使用","categories":[],"tags":[{"name":"html&浏览器","slug":"html-浏览器","permalink":"https://andylinwenqin.github.io/tags/html-%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"协议","slug":"协议","permalink":"https://andylinwenqin.github.io/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"mini-vue","slug":"mini-vue","date":"2021-06-27T09:14:43.000Z","updated":"2021-06-27T10:23:42.952Z","comments":true,"path":"2021/06/27/mini-vue/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/mini-vue/","excerpt":"","text":"mini-vue 实现一个 mini-vue 之 vdomB 站传送门 (opens new window)vue 总共包含三大部分: 模板编译 虚拟 dom 响应式 api 这篇文章主要很简单的实现一下虚拟 dom 部分 #h 函数h 函数很简单,就是返回一个 js 对象. 1234567function h(tag, props, children) &#123; return &#123; tag, props, children, &#125;;&#125; mountmount 函数接受两个参数,第一个是虚拟节点也就是 h 函数生成的 vnode,第二个是要挂载到的真实 dom 节点. mount 的主要作用是将虚拟节点挂载到真实 dom 节点上,也不是很复杂. 123456789101112131415161718192021222324252627282930313233function mount(vnode, container) &#123; const &#123; tag, props, children &#125; = vnode; //这里要将生成的真实dom节点保存到vnode上 const el = (vnode.el = document.createElement(tag)); //添加dom属性 if (props) &#123; for (let key in props) &#123; const value = props[key]; if (key.startsWith(&quot;on&quot;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), value); &#125; else &#123; el.setAttribute(key, value); &#125; &#125; &#125; //添加子节点 if (children) &#123; if (Array.isArray(children)) &#123; children.forEach((child) =&gt; &#123; if (typeof child === &quot;string&quot;) &#123; el.append(child); &#125; else if (typeof child === &quot;object&quot;) &#123; //child是一个对象时,说明child是一个元素节点 //这时就要递归调用mount mount(child, el); &#125; &#125;); &#125; else &#123; el.append(children); &#125; &#125; container.append(el);&#125; patch虚拟 dom 部分里最复杂的就是 patch 函数,这个函数的作用是,比对两个虚拟节点, 进行 diff 算法,从而实现最小量更新,也就是尽可能的减少对真实 dom 的操作,因为操作真实 dom 的性能开销远大于操作 js 对象,这也是 vue 使用虚拟 dom 的原因之一. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function patch(n1, n2) &#123; if (n1.tag === n2.tag) &#123; //这个分支为新旧节点tag类型相同 //这里需要将真实dom节点el,在每次patch时向后传递,保证每次更新的都是 //这个节点. const el = (n2.el = n1.el); //diff props const oldProps = n1.props || &#123;&#125;; const newProps = n2.props || &#123;&#125;; //添加新的属性或更改原来已有但变化了的属性 for (let key in newProps) &#123; const oldValue = oldProps[key]; const newValue = newProps[key]; if (newValue !== oldValue) &#123; el.setAttribute(key, newValue); &#125; &#125; //移除新属性中没有的属性 for (let key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key); &#125; &#125; //diff children const oldChildren = n1.children; const newChildren = n2.children; //在diff children的时候,有四个主要分支 // 1.新老都是string // 2.新: array 老: string // 3.新: string 老: array // 4.新老都是array if (typeof newChildren === &quot;string&quot;) &#123; if (typeof oldChildren === &quot;string&quot;) &#123; //情况1 if (oldChildren !== newChildren) &#123; el.innerHTML = newChildren; &#125; &#125; else &#123; //情况3 el.innerHTML = newChildren; &#125; &#125; else if (typeof oldChildren === &quot;string&quot; &amp;&amp; Array.isArray(newChildren)) &#123; //情况2 el.innerHTML = &quot;&quot;; newChildren.forEach((child) =&gt; mount(child, el)); &#125; else if (Array.isArray(oldChildren) &amp;&amp; Array.isArray(newChildren)) &#123; //情况4 是最复杂的情况 //这里简单起见并没有真正实现vue中的diff算法,而是选取了一个低效但 //容易理解的算法,但其实vue中如果不给元素提供key的话,也会使用这个 //算法,这个算法在子元素的tag不会变的情况下非常高效,但如果tag会变 //则会因为不必要的创造和删除节点,而变得不那么高效. const minLength = Math.min(oldChildren.length, newChildren.length); for (let i = 0; i &lt; minLength; i++) &#123; patch(oldChildren[i], newChildren[i]); &#125; //老的children长度较小,则说明要添加节点 if (oldChildren.length === minLength) &#123; for (let i = minLength; i &lt; newChildren.length; i++) &#123; mount(newChildren[i], el); &#125; &#125; else &#123; //反之,则说明要删除节点 for (let i = minLength; i &lt; oldChildren.length; i++) &#123; el.removeChild(oldChildren[i].el); &#125; &#125; &#125; &#125; else &#123; //标签类型不同时需要用新节点替换节点 //这里并没有实现😂 //回头再补 &#125;&#125; 实现一个 mini-vue 之 reactive简单的实现一下 vue3 的响应式原理核心 Dep 类要理解 vue 响应式原理,首先要明白 Dep 类是干什么的. Dep 故名思意,就是依赖的意思. 为什么叫依赖,因为视图的变化,实际上是数据的变化所导致的. 所以现在数据就是视图的依赖. 现在我们假设视图的变化是由一个神奇的函数 render 的调用的结果也就是 view = render(data). 现在我们在 data 变化时想改变视图,就要手动调用这个函数,而响应式就是要避免这个操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243//Dep类的实例就是依赖class Dep &#123; constructor(value) &#123; //在构造函数里传入了value,这时dep同时也是数据的载体 this._value = value; //这里dep保存着它的订阅者,注意是set,意味着不能重复 this.subs = new Set(); &#125; //通过js特性对象数据访问器getter和setter, //进行订阅者的注册和依赖改变后副作用的执行,也就是发布 get value() &#123; //get时注册订阅者 this.depend(); return this._value; &#125; set value(newValue) &#123; this._value = newValue; //set后通知订阅者,执行副作用 this.notify(); &#125; depend() &#123; //这里的activeEffect为全局变量,指向当前要被注册的订阅者 if (activeEffect) &#123; this.subs.add(activeEffect); &#125; &#125; notify() &#123; //执行所有副作用,也就是订阅者 this.subs.forEach((sub) =&gt; sub()); &#125;&#125;let activeEffect = null;function watchEffect(effect) &#123; //这步赋值置空的操作,保证了只能在watchEffect中进行订阅者的注册 activeEffect = effect; effect(); activeEffect = null;&#125; Copied! 测试 12345678910const count = new Dep(1);watchEffect(() =&gt; &#123; console.log(count.value);&#125;);count.value++; // log 2count.value++; // log 3count.value++; // log 4count.value = 15; // log 15 reactive在 Dep 类中了解了 vue 中基本的响应式原理后,对 reactive-api 就好理解了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Dep类和当前要注册的订阅者//和上面的区别是,这里Dep不再是数据的载体//而只负责整个发布订阅过程let activeEffect = null;class Dep &#123; subs = new Set(); depend() &#123; if (activeEffect) &#123; this.subs.add(activeEffect); &#125; &#125; notify() &#123; this.subs.forEach((sub) =&gt; sub()); &#125;&#125;function watchEffect(effect) &#123; activeEffect = effect; effect(); activeEffect = null;&#125;//我们从上到下看//reactive接收一个原始的对象//返回一个原始对象的代理// Proxy(target, handler)function reactive(raw) &#123; return new Proxy(raw, reactiveHandlers);&#125;const reactiveHandlers = &#123; get(target, key, receiver) &#123; //依旧是get时进行订阅者的注册 //问题是我的dep从哪获取,这里暂时认为getDep帮我拿到了 //这个target和这个key对应的dep //这里为了简单起见,没有处理深层嵌套对象的响应式转换 const dep = getDep(target, key); dep.depend(); return Reflect.get(target, key, receiver); &#125;, set(target, key, value, receiver) &#123; //set时触发所有副作用 //同样需要获得对应的dep const dep = getDep(target, key); const ret = Reflect.set(target, key, value, receiver); dep.notify(); return ret; &#125;,&#125;;//最后我们看是如何获取对应的dep的/* 我们先搞明白一个对应关系 target是个对象,对应着一组key, value, dep的depend和notify操作,就是在对target[key], get和set时进行的,dep储存着所有订阅者,所以一个key 对应着一个dep,这个数据结构可以使用Map储存这一组key,value. 而前面我们知道,一个target对应着一组key,value,所以这个 数据结构也是一个Map(这里考虑到垃圾回收使用了WeakMap).*/const targetMap = new WeakMap();function getDep(target, key) &#123; if (!targetMap.has(target)) &#123; targetMap.set(target, new Map()); &#125; const depMap = targetMap.get(target); if (!depMap.has(key)) &#123; depMap.set(key, new Dep()); &#125; return depMap.get(key);&#125; 实现一个 mini-vue我们来执行最后一步,将前面的函数进行组合,得到最终可以运行的 mini-vue. 先将之前所有的代码复制过来. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//vdom部分function h(tag, props, children) &#123; return &#123; tag, props, children, &#125;;&#125;function mount(vnode, container) &#123; const &#123; tag, props, children &#125; = vnode; const el = (vnode.el = document.createElement(tag)); if (props) &#123; for (let key in props) &#123; const value = props[key]; if (key.startsWith(&quot;on&quot;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), value); &#125; else &#123; el.setAttribute(key, value); &#125; &#125; &#125; if (children) &#123; if (Array.isArray(children)) &#123; children.forEach((child) =&gt; &#123; if (typeof child === &quot;string&quot;) &#123; el.append(child); &#125; else if (typeof child === &quot;object&quot;) &#123; mount(child, el); &#125; &#125;); &#125; else &#123; el.append(children); &#125; &#125; container.append(el);&#125;function patch(n1, n2) &#123; if (n1.tag === n2.tag) &#123; const el = (n2.el = n1.el); //diff props const oldProps = n1.props || &#123;&#125;; const newProps = n2.props || &#123;&#125;; //添加新的属性或更改原来已有但变化了的属性 for (let key in newProps) &#123; const oldValue = oldProps[key]; const newValue = newProps[key]; if (newValue !== oldValue) &#123; el.setAttribute(key, newValue); &#125; &#125; //移除新属性中没有的属性 for (let key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key); &#125; &#125; //diff children const oldChildren = n1.children; const newChildren = n2.children; if (typeof newChildren === &quot;string&quot;) &#123; if (typeof oldChildren === &quot;string&quot;) &#123; if (oldChildren !== newChildren) &#123; el.innerHTML = newChildren; &#125; &#125; &#125; else if (typeof oldChildren === &quot;string&quot; &amp;&amp; Array.isArray(newChildren)) &#123; el.innerHTML = &quot;&quot;; newChildren.forEach((child) =&gt; mount(child, el)); &#125; else if (Array.isArray(oldChildren) &amp;&amp; Array.isArray(newChildren)) &#123; const minLength = Math.min(oldChildren.length, newChildren.length); for (let i = 0; i &lt; minLength; i++) &#123; patch(oldChildren[i], newChildren[i]); &#125; if (oldChildren.length === minLength) &#123; for (let i = minLength; i &lt; newChildren.length; i++) &#123; mount(newChildren[i], el); &#125; &#125; else &#123; for (let i = minLength; i &lt; oldChildren.length; i++) &#123; el.removeChild(oldChildren[i].el); &#125; &#125; &#125; &#125; else &#123; //replace &#125;&#125;//reactivity部分let activeEffect = null;class Dep &#123; subs = new Set(); depend() &#123; if (activeEffect) &#123; this.subs.add(activeEffect); &#125; &#125; notify() &#123; this.subs.forEach((sub) =&gt; sub()); &#125;&#125;function watchEffect(effect) &#123; activeEffect = effect; effect(); activeEffect = null;&#125;const targetMap = new WeakMap();function getDep(target, key) &#123; if (!targetMap.has(target)) &#123; targetMap.set(target, new Map()); &#125; const depMap = targetMap.get(target); if (!depMap.has(key)) &#123; depMap.set(key, new Dep()); &#125; return depMap.get(key);&#125;const reactiveHandlers = &#123; get(target, key, receiver) &#123; // dep const dep = getDep(target, key); dep.depend(); return Reflect.get(target, key, receiver); &#125;, set(target, key, value, receiver) &#123; const dep = getDep(target, key); const ret = Reflect.set(target, key, value, receiver); dep.notify(); return ret; &#125;,&#125;;function reactive(raw) &#123; return new Proxy(raw, reactiveHandlers);&#125; mountApp12345678910111213141516171819//component组件实例//container要挂载的dom元素function mountApp(component, container) &#123; let isMounted = false; let oldVdom; watchEffect(() =&gt; &#123; if (!isMounted) &#123; //第一次挂载 oldVdom = component.render(); mount(oldVdom, container); isMounted = true; &#125; else &#123; //数据变化,要进行更新 const newVdom = component.render(); patch(oldVdom, newVdom); oldVdom = newVdom; &#125; &#125;);&#125; 测试12345678910111213141516171819const App = &#123; data: reactive(&#123; count: 0, &#125;), render() &#123; return h(&quot;div&quot;, null, [ h( &quot;div&quot;, &#123; onClick: () =&gt; App.data.count++, &#125;, String(this.data.count) ), ]); &#125;,&#125;;//一个点击自增的计数器mountApp(App, document.getElementById(&quot;app&quot;));","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"Vue的diff算法","slug":"Vue的diff算法","date":"2021-06-27T08:49:57.000Z","updated":"2021-06-27T09:17:16.707Z","comments":true,"path":"2021/06/27/Vue的diff算法/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"Vue如何操作节点及diff算法 前言当数据发生变化时，vue是怎么更新节点的？要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。 我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。 diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。 virtual DOM和真实DOM的区别？virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的： 123&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 对应的virtual DOM（伪代码）： 123456var Vnode = &#123; tag: &#x27;div&#x27;, children: [ &#123; tag: &#x27;p&#x27;, text: &#x27;123&#x27; &#125; ]&#125;; （温馨提示：VNode和oldVNode都是对象，一定要记住） diff的比较方式？1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;456&lt;/span&gt;&lt;/div&gt; 上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图： diff流程图当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。 具体分析patch来看看patch是怎么打补丁的（代码只保留核心部分） 1234567891011121314151617function patch (oldVnode, vnode) &#123; // some code if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode) &#125; else &#123; const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) // 父元素 createEle(vnode) // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null &#125; &#125; // some code return vnode&#125; patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode 12345678910function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 )&#125; 不值得比较则用Vnode替换oldVnode 如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。 patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？ 1234567891011121314151617patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el&#x27;s children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125; 这个函数做了以下事情： 找到对应的真实dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 其他几个点都很好理解，我们详细来讲一下updateChildren updateChildren代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125;else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125;else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125;else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125;else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 图解updateChildren终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。 粉红色的部分为oldCh和vCh 我们将它们取出来并分别用s和e指针指向它们的头child和尾child 现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方 如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后 如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动 如果四种匹配没有一对是成功的，那么遍历oldChild，S挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将S对应的节点插入到dom中对应的oldS位置，oldS和S指针向中间移动。 再配个图 第一步 12oldS = a, oldE = d；S = a, E = b; oldS和S匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d 第二步 12oldS = b, oldE = d；S = c, E = b; oldS和E匹配，就将原本的b节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，此时dom的位置为：a d b 第三步 12oldS = d, oldE = d；S = c, E = d; oldE和E匹配，位置不变此时dom的位置为：a d b 第四步 123oldS++;oldE--;oldS &gt; oldE; 遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b 一次模拟完成。 这个匹配过程的结束有两个条件： oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据index添加到dom中去（如上图） S &gt; E表示vCh先遍历完，那么就在真实dom中将区间为[oldS, oldE]的多余节点删掉(本图第二第三步画错了应该对换位置) 下面再举一个例子，可以像上面那样自己试着模拟一下 当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码 123if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode)&#125; 就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。也将dom的所有补丁都打好啦。那么现在再回过去看updateChildren的代码会不会容易很多呢？ 总结以上为diff算法的全部过程，放上一张文章开始就发过的总结图，可以试试看着这张图回忆一下diff的过程。 参考资料本文摘抄自详解vue的diff算法 尤大的mini-vue","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"SPA单页面应用和多页应用优缺点","slug":"SPA单页面应用","date":"2021-06-27T08:42:42.000Z","updated":"2021-06-27T08:55:06.006Z","comments":true,"path":"2021/06/27/SPA单页面应用/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/","excerpt":"","text":"SPA单页应用 其所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。 优 点: 减轻服务端的压力，可维护性高 缺点: 首次加载速度慢，搜索引擎优化效果不好 为什么首屏时间慢，SEO 差？单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。 SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。 多页应用多页面应用: 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://andylinwenqin.github.io/tags/Vue/"}]},{"title":"Promise","slug":"Promise","date":"2021-06-27T06:39:46.000Z","updated":"2021-06-27T08:54:58.524Z","comments":true,"path":"2021/06/27/Promise/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/27/Promise/","excerpt":"","text":"彻底弄懂 Promise 原理 Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。 基本过程： 初始化 Promise 状态（pending） 立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理 执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次） Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。 真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise. 链式调用先从 Promise 执行结果看一下，有如下一段代码： 123456789101112131415new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) resolve(&#123; test: 2 &#125;) reject(&#123; test: 2 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data)&#125;,(data1)=&gt;&#123; console.log(&#x27;result2&#x27;,data1)&#125;).then((data) =&gt; &#123; console.log(&#x27;result3&#x27;, data)&#125;)//result1 &#123; test: 1 &#125;//result3 undefined 显然这里输出了不同的 data。由此可以看出几点： 可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。 只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。 then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。 基于以上几点，我们先写个基于 PromiseA+ 规范的只含 resolve 方法的 Promise 模型: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Promise(fn)&#123; let state = &#x27;pending&#x27;; let value = null; const callbacks = []; this.then = function (onFulfilled)&#123; return new Promise((resolve, reject)=&gt;&#123; handle(&#123; //桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中 onFulfilled, resolve &#125;) &#125;) &#125; function handle(callback)&#123; if(state === &#x27;pending&#x27;)&#123; callbacks.push(callback) return; &#125; if(state === &#x27;fulfilled&#x27;)&#123; if(!callback.onFulfilled)&#123; callback.resolve(value) return; &#125; const ret = callback.onFulfilled(value) //处理回调 callback.resolve(ret) //处理下一个 promise 的resolve &#125; &#125; function resolve(newValue)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return state = &#x27;fulfilled&#x27;; value = newValue handelCb() &#125; setTimeout(fn,0) //基于 PromiseA+ 规范 &#125; function handelCb()&#123; while(callbacks.length) &#123; const fulfiledFn = callbacks.shift(); handle(fulfiledFn); &#125;; &#125; fn(resolve)&#125; 这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。 但是如果仅仅是例子中的情况，我们可以这样写： 1234567891011new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething console.log(&#x27;result3&#x27;)&#125;)//result1 &#123; test: 1 &#125;//result3 实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子： 12345678910111213141516171819202122new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething return test()&#125;).then((data) =&gt; &#123; console.log(&#x27;result2&#x27;, data)&#125;)function test(id) &#123; return new Promise(((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 2 &#125;) &#125;, 5000) &#125;))&#125;//基于第一个 Promise 模型，执行后的输出//result1 &#123; test: 1 &#125;//result2 Promise &#123;then: ƒ&#125; 用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下: 123456789101112131415161718192021222324function Promise(fn)&#123; ... function resolve(newValue)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return if(newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;))&#123; const &#123;then&#125; = newValue if(typeof then === &#x27;function&#x27;)&#123; // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve //相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调 then.call(newValue,resolve) return &#125; &#125; state = &#x27;fulfilled&#x27;; value = newValue handelCb() &#125; setTimeout(fn,0) &#125; ...&#125; 用这个模型，再测试我们的例子，就得到了正确的结果： 123456789101112131415161718192021new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething return test()&#125;).then((data) =&gt; &#123; console.log(&#x27;result2&#x27;, data)&#125;)function test(id) &#123; return new Promise(((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 2 &#125;) &#125;, 5000) &#125;))&#125;//result1 &#123; test: 1 &#125;//result2 &#123; test: 2 &#125; 显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。 显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。 我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。 基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表： Promise callback P1 [{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}] P2 (P1 调用 then 时产生) [{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}] P3 (P2 调用 then 时产生) [] P4 (执行c1中产生[调用 test ]) [{onFulfilled:p2resolve,resolve:p5resolve}] P5 (调用p2resolve 时，进入 then.call 逻辑中产生) [] 有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是： c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; [] 以上就是链式调用的原理了。 reject下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。 完整代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function Promise(fn)&#123; let state = &#x27;pending&#x27;; let value = null; const callbacks = []; this.then = function (onFulfilled,onRejected)&#123; return new Promise((resolve, reject)=&gt;&#123; handle(&#123; onFulfilled, onRejected, resolve, reject &#125;) &#125;) &#125; function handle(callback)&#123; if(state === &#x27;pending&#x27;)&#123; callbacks.push(callback) return; &#125; const cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled:callback.onRejected; const next = state === &#x27;fulfilled&#x27;? callback.resolve:callback.reject; if(!cb)&#123; next(value) return; &#125; const ret = cb(value) next(ret) &#125; function resolve(newValue)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return if(newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;))&#123; const &#123;then&#125; = newValue if(typeof then === &#x27;function&#x27;)&#123; // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve //相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调 then.call(newValue,resolve, reject) return &#125; &#125; state = &#x27;fulfilled&#x27;; value = newValue handelCb() &#125; setTimeout(fn,0) &#125; function reject(error)&#123; const fn = ()=&gt;&#123; if(state !== &#x27;pending&#x27;)return if(error &amp;&amp; (typeof error === &#x27;object&#x27; || typeof error === &#x27;function&#x27;))&#123; const &#123;then&#125; = error if(typeof then === &#x27;function&#x27;)&#123; then.call(error,resolve, reject) return &#125; &#125; state = &#x27;rejected&#x27;; value = error handelCb() &#125; setTimeout(fn,0) &#125; function handelCb()&#123; while(callbacks.length) &#123; const fn = callbacks.shift(); handle(fn); &#125;; &#125; fn(resolve, reject)&#125; 异常处理异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。 handle代码改造如下： 1234567891011121314151617181920function handle(callback)&#123; if(state === &#x27;pending&#x27;)&#123; callbacks.push(callback) return; &#125; const cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled:callback.onRejected; const next = state === &#x27;fulfilled&#x27;? callback.resolve:callback.reject; if(!cb)&#123; next(value) return; &#125; try &#123; const ret = cb(value) next(ret) &#125; catch (e) &#123; callback.reject(e); &#125; &#125; 我们实际使用时，常习惯注册 catch 方法来处理错误，例： 1234567891011new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; test: 1 &#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log(&#x27;result1&#x27;, data) //dosomething return test()&#125;).catch((ex) =&gt; &#123; console.log(&#x27;error&#x27;, ex)&#125;) 实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法： 1234567891011121314151617function Promise(fn)&#123; ... this.then = function (onFulfilled,onRejected)&#123; return new Promise((resolve, reject)=&gt;&#123; handle(&#123; onFulfilled, onRejected, resolve, reject &#125;) &#125;) &#125; this.catch = function (onError)&#123; this.then(null,onError) &#125; ...&#125; Finally方法在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑： 12345678910function Promise(fn)&#123; ... this.catch = function (onError)&#123; this.then(null,onError) &#125; this.finally = function (onDone)&#123; this.then(onDone,onDone) &#125; ...&#125; resolve 方法和 reject 方法实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子： 12345Promise.resolve(&#123;name:&#x27;winty&#x27;&#125;)Promise.reject(&#123;name:&#x27;winty&#x27;&#125;)// 等价于new Promise(resolve =&gt; resolve(&#123;name:&#x27;winty&#x27;&#125;))new Promise((resolve,reject) =&gt; reject(&#123;name:&#x27;winty&#x27;&#125;)) 这些情况下，Promise.resolve 的入参可能有以下几种情况： 无参数 [直接返回一个resolved状态的 Promise 对象] 普通数据对象 [直接返回一个resolved状态的 Promise 对象] 一个Promise实例 [直接返回当前实例] 一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。] 基于以上几点，我们可以实现一个 Promise.resolve 方法如下： 123456789101112131415161718function Promise(fn)&#123; ... this.resolve = function (value)&#123; if (value &amp;&amp; value instanceof Promise) &#123; return value; &#125; else if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;)&#123; let then = value.then; return new Promise(resolve =&gt; &#123; then(resolve); &#125;); &#125; else if (value) &#123; return new Promise(resolve =&gt; resolve(value)); &#125; else &#123; return new Promise(resolve =&gt; resolve()); &#125; &#125; ...&#125; Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下： 12345678910function Promise(fn)&#123; ... this.reject = function (value)&#123; return new Promise(function(resolve, reject) &#123; reject(value); &#125;); &#125; ...&#125; Promise.all入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。 1234567891011121314151617181920212223242526272829303132333435function Promise(fn)&#123; ... this.all = function (arr)&#123; var args = Array.prototype.slice.call(arr); return new Promise(function(resolve, reject) &#123; if(args.length === 0) return resolve([]); var remaining = args.length; function res(i, val) &#123; try &#123; if(val &amp;&amp; (typeof val === &#x27;object&#x27; || typeof val === &#x27;function&#x27;)) &#123; var then = val.then; if(typeof then === &#x27;function&#x27;) &#123; then.call(val, function(val) &#123; res(i, val); &#125;, reject); return; &#125; &#125; args[i] = val; if(--remaining === 0) &#123; resolve(args); &#125; &#125; catch(ex) &#123; reject(ex); &#125; &#125; for(var i = 0; i &lt; args.length; i++) &#123; res(i, args[i]); &#125; &#125;); &#125; ...&#125; Promise.race有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。 1234567891011function Promise(fn)&#123; ... this.race = function(values) &#123; return new Promise(function(resolve, reject) &#123; for(var i = 0, len = values.length; i &lt; len; i++) &#123; values[i].then(resolve, reject); &#125; &#125;); &#125; ...&#125; 总结Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。 补充说明虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。 参考资料 PromiseA+规范 Promise 实现原理精解 30分钟，让你彻底明白Promise原理 完整 Promise 模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153function Promise(fn) &#123; let state = &#x27;pending&#x27; let value = null const callbacks = [] this.then = function (onFulfilled, onRejected) &#123; return new Promise((resolve, reject) =&gt; &#123; handle(&#123; onFulfilled, onRejected, resolve, reject, &#125;) &#125;) &#125; this.catch = function (onError) &#123; return this.then(null, onError) &#125; this.finally = function (onDone) &#123; this.then(onDone, onError) &#125; this.resolve = function (value) &#123; if (value &amp;&amp; value instanceof Promise) &#123; return value &#125; if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;) &#123; const &#123; then &#125; = value return new Promise((resolve) =&gt; &#123; then(resolve) &#125;) &#125; if (value) &#123; return new Promise(resolve =&gt; resolve(value)) &#125; return new Promise(resolve =&gt; resolve()) &#125; this.reject = function (value) &#123; return new Promise(((resolve, reject) =&gt; &#123; reject(value) &#125;)) &#125; this.all = function (arr) &#123; const args = Array.prototype.slice.call(arr) return new Promise(((resolve, reject) =&gt; &#123; if (args.length === 0) return resolve([]) let remaining = args.length function res(i, val) &#123; try &#123; if (val &amp;&amp; (typeof val === &#x27;object&#x27; || typeof val === &#x27;function&#x27;)) &#123; const &#123; then &#125; = val if (typeof then === &#x27;function&#x27;) &#123; then.call(val, (val) =&gt; &#123; res(i, val) &#125;, reject) return &#125; &#125; args[i] = val if (--remaining === 0) &#123; resolve(args) &#125; &#125; catch (ex) &#123; reject(ex) &#125; &#125; for (let i = 0; i &lt; args.length; i++) &#123; res(i, args[i]) &#125; &#125;)) &#125; this.race = function (values) &#123; return new Promise(((resolve, reject) =&gt; &#123; for (let i = 0, len = values.length; i &lt; len; i++) &#123; values[i].then(resolve, reject) &#125; &#125;)) &#125; function handle(callback) &#123; if (state === &#x27;pending&#x27;) &#123; callbacks.push(callback) return &#125; const cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled : callback.onRejected const next = state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject if (!cb) &#123; next(value) return &#125; let ret; try &#123; ret = cb(value) &#125; catch (e) &#123; callback.reject(e) &#125; callback.resolve(ret); &#125; function resolve(newValue) &#123; const fn = () =&gt; &#123; if (state !== &#x27;pending&#x27;) return if (newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;)) &#123; const &#123; then &#125; = newValue if (typeof then === &#x27;function&#x27;) &#123; // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve // 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调 then.call(newValue, resolve, reject) return &#125; &#125; state = &#x27;fulfilled&#x27; value = newValue handelCb() &#125; setTimeout(fn, 0) &#125; function reject(error) &#123; const fn = () =&gt; &#123; if (state !== &#x27;pending&#x27;) return if (error &amp;&amp; (typeof error === &#x27;object&#x27; || typeof error === &#x27;function&#x27;)) &#123; const &#123; then &#125; = error if (typeof then === &#x27;function&#x27;) &#123; then.call(error, resolve, reject) return &#125; &#125; state = &#x27;rejected&#x27; value = error handelCb() &#125; setTimeout(fn, 0) &#125; function handelCb() &#123; while (callbacks.length) &#123; const fn = callbacks.shift() handle(fn) &#125; &#125; try &#123; fn(resolve, reject) &#125; catch(ex) &#123; reject(ex); &#125;&#125;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://andylinwenqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://andylinwenqin.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://andylinwenqin.github.io/tags/ES6/"}]},{"title":"JS的基础知识点","slug":"JS的基础知识点","date":"2021-06-26T12:39:17.000Z","updated":"2021-06-26T13:42:20.520Z","comments":true,"path":"2021/06/26/JS的基础知识点/","link":"","permalink":"https://andylinwenqin.github.io/2021/06/26/JS%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"JS的数据类型JS一共有6种基本数据类型分别是undefined, null, boolean, number, string, symbol, 引用数据类型object, array, function symbol作用: 定义一个独一无二的值 基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问 引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用 string是个基本数据类型，为什么可以使用String的一些方法除去Object, Array等引用类型，JavaScript还提供了三种特殊的引用类型: String, Number和Boolean，方便我们操作对应的基本类型，所以在调用String方法时，并不是基本数据类型stirng执行了自身方法，而是后台为它创建了一个对应的基本包装类型String，它根据基本类型的值实例化了一个实例，让这个实例去调用指定的方法，最后销毁这个实例 var, let, const的区别var声明的变量没有块级作用域而let声明的变量拥有块级作用域，const声明的是常量，声明之后无法对其进行修改， const保证的实际上并不是变量的值不得改变，而是变量指向的那个内存地址不得改动，对于复合类型的数据如对象，数组，变量指向的内存地址保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的 在代码块内，使用let命令声明变量之前，该变量都是不可用的，在语法上称为暂时性死区 ==, ===, Object.is的区别==: 会进行强制的类型转换,在转换类型后，二者相等也会返回True,而===不会进行转换, Object.is也不会进行强制类型转换，但与===不同的是，+0===0, Object.is(+0, -0) false, Nan !== Nan, Object.is(Nan, Nan) false 如果Type(x)和Type(y)相同，返回x===y的结果如果Type(x)和Type(y)不同如果x是null，y是undefined，返回true如果x是undefined，y是null，返回true如果Type(x)是Number，Type(y)是String，返回 x==ToNumber(y) 的结果如果Type(x)是String，Type(y)是Number，返回 ToNumber(x)==y 的结果如果Type(x)是Boolean，返回 ToNumber(x)==y 的结果如果Type(y)是Boolean，返回 x==ToNumber(y) 的结果如果Type(x)是String或Number或Symbol中的一种并且Type(y)是Object，返回 x==ToPrimitive(y) 的结果如果Type(x)是Object并且Type(y)是String或Number或Symbol中的一种，返回 ToPrimitive(x)==y 的结果其他返回false slice()和splice()`的区别slice: 只能截取数组中的一段，且截取后原数据不会发生变化; splice: 不仅仅能够截取数组中的一段，还能够在原数组中进行替换 push(), pop(), shift()和unshift()(1). push, pop:类似于栈的行为，后进先出 (2). shift, unshift: 类似于队列的行为, 先进先出 数组方法 1234567891011(1). 修改器方法 push, pop, unshift, shift, sort, reverse, splice(2). 访问方法 (返回新的数组) concat, slice(3). 迭代方法 forEach, filter, map, reduce map和setmap是一组键值对的结构，具有极快的查找速度 set和map类似，也是一组key的集合，但不储存value，在set中，key不可重复 现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。 null和undefined，怎么判断是nullnull: 表示一个值被定义了，定义为”空值”; undefined: 表示根本不存在定义; 12345let exp = undefinedif (typeof (exp) === &#x27;undefined&#x27;) console.log(&#x27;undefined&#x27;);exp = nullif (!exp) console.log(&#x27;null&#x27;); arguments在调用函数时，我们